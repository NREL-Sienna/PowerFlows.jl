var documenterSearchIndex = {"docs":
[{"location":"reference/developers/lcc_model/#Aspects-of-LCC-implementation-in-PSSE","page":"LCC Model Implementation","title":"Aspects of LCC implementation in PSSE","text":"In real-world operation, on-load tap changers (OLTCs) adjust transformer taps so that the converter reaches its minimum firing or extinction angle limits (αmin or γmin). The objective is to reduce the firing/extinction angle to minimize reactive power (Q) demand.\n\nAs OLTCs operate typically over several seconds, the thyristor angles act as fast control. First, the thyristor angles respond to fast power flow changes. Afterwards, the OLTCs are adjusted to keep maintaining the power set point while also minimizing the thyristor angles.\n\nIn PSSE, the control using OLTCs is ignored in power flow calculations. Instead, PSSE adjusts the thyristor angles to represent the fast control.  PSSE solves for the rectifier firing angle (α) such that Idc = Iset, and for the inverter extinction angle (γ) such that Udc = Uset. The solver adjusts α and γ automatically to satisfy these setpoints and only switches control mode if a limit is violated.\n\nOLTC actions are not represented in the load-flow process because they operate on a slower time scale (seconds). The rationale is to provide a starting point for dynamic simulations. The tap positions can be set manually.\n\nFor safe operation and to avoid commutation failure, the rectifier should normally operate close to its minimum firing angle (α_min) with a small safety margin. Overly broad firing angle settings should be avoided. For example, setting max firing angle to 90° is too permissive. A narrower range encourages PSSE to adjust taps appropriately.\n\nIn PSSE, the variable VSched (scheduled DC voltage) represents the DC voltage reference, not the AC-side voltage. If VSched is set too low, the inverter will use unnecessarily large extinction angles (γ) to transfer power.\n\nPower flow calculation in PSSE often fails to converge with LCC. In this case, it can help to first run the Gauss-Seidel algorithm, then Newton will also converge in PSSE.","category":"section"},{"location":"reference/developers/lcc_model/#Implementation-in-Sienna","page":"LCC Model Implementation","title":"Implementation in Sienna","text":"We implement the control logic of LCC based on the principle of maintaining the thyristor angles at their respective minimum limits, and using transformer tap adjustments for active power control. This control principle is better suited for representing realistic steady-state grid conditions.\n\nThe AC power flow calculation in Sienna is modified to directly solve for tap steps and thyristor angles of the LCC system. To this end, the state vector, the Jacobian matrix, the residuals are modified. The state vector is extended by 4 additional variables for each LCC system, namely 2 for tap positions and 2 for thyristor angles of the rectifier and inverter sides of the LCC system. The Jacobian matrix is extended by additional terms that represent the relevant partial derivatives. The residuals are extended by 4 terms per LCC system to match the additional state variables. The first two account for the active power set point and active power balance in the LCC system using the tap steps. The other two residual terms control for keeping the thyristor angles at their respective minimum limits. This approach follows the method in Panosyan, A. (2010). Modeling of Advanced Power Transmission System Controllers (PhD dissertation).\n\nThe complex apparent power for a rectifier or inverter is calculated as S = V t fracsqrt6pi I_dc e^j phi, where V is the magnitude of AC voltage at the terminal, I_dc is the DC current in the LCC system (positive for flow direction rectifier to inverter, and vice versa), and phi is the angle between AC voltage and current.\n\nTo allow for the Jacobian implementation, a simplified calculation of the angle between the AC current and voltage at the LCC terminals was used. The equation below represents the calculation used for the angle:\n\nphi = arccosleft(cos(alpha) textsign(I_dc) - fracx I_dcsqrt2 t Vright)\n\nIn the equation above, the variable alpha represents the thyristor angle. The active and reactive powers for a converter station are \n\nbeginaligned\nP = V t fracsqrt6pi I_dc cos(phi) = V t fracsqrt6pi I_dc cos(alpha) - fracsqrt6pi x I_dc^2 \nQ = V t fracsqrt6pi I_dc sin(phi) = V t fracsqrt6pi I_dc sinleft(arccosleft(cos(alpha) textsign(I_dc) - fracx I_dcsqrt2 t Vright)right)\nendaligned\n\nThe relevant non-zero entries in the Jacobian matrix for the rectifier (r) and inverter (i) sides are:\n\nbeginaligned\nfracpartial P_rpartial V_r = t_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial Q_rpartial V_r = V_r t_r fracsqrt6pi I_dc left(sin(phi_r) - cos(phi_r) fracx_r I_dcsqrt2 V_r t_r sin^2(phi_r)right) \nfracpartial Q_rpartial t_r = V_r t_r fracsqrt6pi I_dc left(fracsin(phi_r)t_r - cos(phi_r) fracx_r I_dcsqrt2 V_r t_r^2 sin^2(phi_r)right) \nfracpartial Q_rpartial alpha_r = V_r t_r fracsqrt6pi I_dc fraccos(phi_r) sin(alpha_r)sin(phi_r) \nfracpartial P_rpartial t_r = V_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial P_rpartial alpha_r = -V_r fracsqrt6pi I_dc t_r sin(alpha_r) \nfracpartial F_t_ipartial V_i = t_i fracsqrt6pi (-I_dc) cos(alpha_i) \nfracpartial F_t_rpartial t_r = V_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial F_t_rpartial alpha_r = -V_r fracsqrt6pi I_dc t_r sin(alpha_r) \nfracpartial F_t_ipartial t_i = V_i fracsqrt6pi (-I_dc) cos(alpha_i) \nfracpartial F_t_rpartial V_r = t_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial F_t_ipartial V_r = t_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial F_t_ipartial t_r = V_r fracsqrt6pi I_dc cos(alpha_r) \nfracpartial F_t_ipartial alpha_i = -V_i fracsqrt6pi (-I_dc) t_i sin(alpha_i) \nfracpartial F_t_ipartial alpha_r = -V_r fracsqrt6pi I_dc t_r sin(alpha_r) \nfracpartial F_alpha_rpartial alpha_r = 1 \nfracpartial F_alpha_ipartial alpha_i = 1\nendaligned\n\nThe residuals are defined as follows:\n\nbeginaligned\nF_t_r = P_r - P_textset r \nF_t_i = P_r + P_i - I_dc R_dc^2 \nF_alpha_r = alpha_r - alpha_r min \nF_alpha_i = alpha_i - alpha_i min\nendaligned","category":"section"},{"location":"how-tos/stub/#How-to-Guides","page":"How-to-Guides","title":"How-to Guides","text":"How-to's can be be referenced when looking for guidance for specific scenarios and issues in PowerAnalytics.  ","category":"section"},{"location":"reference/api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"reference/api/internal/#Power-Flow-Types","page":"Internal API Reference","title":"Power Flow Types","text":"","category":"section"},{"location":"reference/api/internal/#PowerFlowData","page":"Internal API Reference","title":"PowerFlowData","text":"","category":"section"},{"location":"reference/api/internal/#Struct-and-Type-Definitions","page":"Internal API Reference","title":"Struct and Type Definitions","text":"","category":"section"},{"location":"reference/api/internal/#Solving-a-PowerFlowData-instance","page":"Internal API Reference","title":"Solving a PowerFlowData instance","text":"","category":"section"},{"location":"reference/api/internal/#Manipulating-a-PowerFlowData-instance","page":"Internal API Reference","title":"Manipulating a PowerFlowData instance","text":"","category":"section"},{"location":"reference/api/internal/#LCC-HVDC-Parameters-and-Utilities","page":"Internal API Reference","title":"LCC HVDC Parameters and Utilities","text":"","category":"section"},{"location":"reference/api/internal/#AC-Power-Flow","page":"Internal API Reference","title":"AC Power Flow","text":"","category":"section"},{"location":"reference/api/internal/#Residuals","page":"Internal API Reference","title":"Residuals","text":"","category":"section"},{"location":"reference/api/internal/#Jacobian","page":"Internal API Reference","title":"Jacobian","text":"","category":"section"},{"location":"reference/api/internal/#Iterative-Methods","page":"Internal API Reference","title":"Iterative Methods","text":"","category":"section"},{"location":"reference/api/internal/#Robust-Homotopy-Method","page":"Internal API Reference","title":"Robust Homotopy Method","text":"","category":"section"},{"location":"reference/api/internal/#Levenberg-Marquardt-Method","page":"Internal API Reference","title":"Levenberg-Marquardt Method","text":"","category":"section"},{"location":"reference/api/internal/#Linear-Algebra-Backends","page":"Internal API Reference","title":"Linear Algebra Backends","text":"","category":"section"},{"location":"reference/api/internal/#Robust-Homotopy","page":"Internal API Reference","title":"Robust Homotopy","text":"","category":"section"},{"location":"reference/api/internal/#Newton-Raphson","page":"Internal API Reference","title":"Newton-Raphson","text":"","category":"section"},{"location":"reference/api/internal/#Misc.","page":"Internal API Reference","title":"Misc.","text":"","category":"section"},{"location":"reference/api/internal/#PSSE-Export","page":"Internal API Reference","title":"PSSE Export","text":"","category":"section"},{"location":"reference/api/internal/#Post-Processing","page":"Internal API Reference","title":"Post-Processing","text":"","category":"section"},{"location":"reference/api/internal/#Power-Systems-Utilities","page":"Internal API Reference","title":"Power Systems Utilities","text":"","category":"section"},{"location":"reference/api/internal/#Common-Utilities-and-Definitions","page":"Internal API Reference","title":"Common Utilities and Definitions","text":"","category":"section"},{"location":"reference/api/internal/#PowerFlows.ABAPowerFlowData","page":"Internal API Reference","title":"PowerFlows.ABAPowerFlowData","text":"A type alias for a PowerFlowData struct whose type parameters are configured for the DCPowerFlow method.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowData","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowData","text":"A type alias for a PowerFlowData struct whose type parameters are configured for the ACPowerFlow method.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.PTDFPowerFlowData","page":"Internal API Reference","title":"PowerFlows.PTDFPowerFlowData","text":"A type alias for a PowerFlowData struct whose type parameters are configured for the PTDFDCPowerFlow method .\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"PowerFlowData{M <: PNM.PowerNetworkMatrix, N <: Union{PNM.PowerNetworkMatrix, Nothing}}\n\nStructure containing all the data required for the evaluation of the power flows and angles, as well as these ones.\n\nAll fields starting with bus_ are ordered according to bus_lookup, and all fields  starting with arc_ are ordered according to arc_lookup: one row per bus/arc,  one column per time period. Here, buses should be understood as \"buses remaining, after  the network reduction.\" Similarly, we use \"arcs\" instead of \"branches\" to distinguish  between network elements (post-reduction) and system objects (pre-reduction).\n\nGenerally, do not construct this directly. Instead, use one of the later constructors to  pass in a PowerFlowEvaluationModel and a PowerSystems.System.  aux\\_network\\_matrix and power\\_network\\_matrix will then be set to the appropriate  matrices that are needed for computing that type of power flow. See also ACPowerFlowData, ABAPowerFlowData, PTDFPowerFlowData, and vPTDFPowerFlowData:  these are all aliases for PowerFlowData{N, M} with specific N,M, that are used for  the respective type of power flow evaluations.\n\nFields:\n\nbus_active_power_injections::Matrix{Float64}:       matrix containing the bus active power injections.\nbus_reactive_power_injections::Matrix{Float64}:       matrix containing the bus reactive power injections.\nbus_active_power_withdrawals::Matrix{Float64}:       matrix containing the bus reactive power withdrawals.\nbus_reactive_power_withdrawals::Matrix{Float64}:       matrix containing the bus reactive power withdrawals.\nbus_active_power_constant_current_withdrawals::Matrix{Float64}:       matrix containing the bus active power constant current       withdrawals.\nbus_reactive_power_constant_current_withdrawals::Matrix{Float64}:       matrix containing the bus reactive power constant current       withdrawals.\nbus_active_power_constant_impedance_withdrawals::Matrix{Float64}:       matrix containing the bus active power constant impedance       withdrawals.\nbus_reactive_power_constant_impedance_withdrawals::Matrix{Float64}:         matrix containing the bus reactive power constant impedance       withdrawals.\nbus_reactive_power_bounds::Matrix{Float64}:       matrix containing upper and lower bounds for the reactive supply at each       bus at each time period.\nbus_type::Matrix{PSY.ACBusTypes}:       matrix containing type of buses present in the system.\nbus_magnitude::Matrix{Float64}:       matrix containing the bus voltage magnitudes.\nbus_angles::Matrix{Float64}:       matrix containing the bus voltage angles.\narc_active_power_flow_from_to::Matrix{Float64}:       matrix containing the active power flows measured at the from bus.\narc_reactive_power_flow_from_to::Matrix{Float64}:       matrix containing the reactive power flows measured at the from bus.\narc_active_power_flow_to_from::Matrix{Float64}:       matrix containing the active power flows measured at the to bus.\narc_reactive_power_flow_to_from::Matrix{Float64}:       matrix containing the reactive power flows measured at the to bus.\ngeneric_hvdc_flows::Dict{Tuple{Int, Int}, Tuple{Float64, Float64}}:       dictionary mapping each generic HVDC line (represented as a tuple of the from and to bus       numbers) to a tuple of (P_from_to, P_to_from) active power flows.\nbus_hvdc_net_power::Matrix{Float64}:       \"(b, t)\" matrix containing the net power injections from all HVDC lines at each bus.       b: number of buses, t: number of time period. Only contains HVDCs handled as       separate injection/withdrawal pairs: LCCs and generic for DC, or just generic for AC.\ntime_step_map::Dict{Int, S}:       dictionary mapping the number of the time periods (corresponding to the       column number of the previously mentioned matrices) and their names.\npower_network_matrix::M:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.\naux_network_matrix::N:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.\nneighbors::Vector{Set{Int}}: Vector with the sets of adjacent buses.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"PowerFlowData(\n    pf::ACPowerFlow{<:ACPowerFlowSolverType},\n    sys::PSY.System\n) -> ACPowerFlowData{<:ACPowerFlowSolverType}\n\nCreates the structure for an AC power flow calculation, given the System sys. Configuration options like time_steps, timestep_names, network_reductions, and correct_bustypes are taken from the ACPowerFlow object.\n\nCalling this function will not evaluate the power flows and angles. Note that first input is of type ACPowerFlow: this version is used to solve AC power flows, and returns an ACPowerFlowData object.\n\nArguments:\n\npf::ACPowerFlow:       the settings for the AC power flow solver, including time_steps, time_step_names,       network_reductions, and correct_bustypes.\nsys::PSY.System:       A System object that represents the power       grid under consideration.\n\nWARNING: functions for the evaluation of the multi-period AC PF still to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"PowerFlowData(\n    pf::DCPowerFlow,\n    sys::PSY.System\n) -> ABAPowerFlowData\n\nCreates a PowerFlowData structure configured for a standard DC power flow calculation, given the System sys. Configuration options like time_steps, time_step_names, network_reductions, and correct_bustypes are taken from the DCPowerFlow object.\n\nCalling this function will not evaluate the power flows and angles. Note that first input is of type DCPowerFlow: this version is used to solve DC power flows, and returns an ABAPowerFlowData object.\n\nArguments:\n\npf::DCPowerFlow:       Run a DC power flow: internally, store the ABA matrix as power_network_matrix and       the BA matrix as aux_network_matrix. Configuration options are taken from this object.\nsys::PSY.System:       A System object that represents the power       grid under consideration.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData-Tuple{PTDFDCPowerFlow, System}","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"PowerFlowData(\n    pf::PTDFDCPowerFlow,\n    sys::PSY.System\n) -> PTDFPowerFlowData\n\nCreates a PowerFlowData structure configured for a Partial Transfer Distribution Factor Matrix DC power flow calculation, given the System sys. Configuration options like time_steps, time_step_names, network_reductions, and correct_bustypes are taken from the PTDFDCPowerFlow object.\n\nCalling this function will not evaluate the power flows and angles. Note that first input is of type PTDFDCPowerFlow: this version is used to solve DC power flows via the Power Transfer Distribution Factor (PTDF) matrix. This function returns a PTDFPowerFlowData object.\n\nArguments:\n\npf::PTDFDCPowerFlow:       Run a DC power flow with PTDF matrix: internally, store the PTDF matrix       as power_network_matrix and the ABA matrix as aux_network_matrix.       Configuration options are taken from this object.\nsys::PSY.System:       A System object that represents the power       grid under consideration.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"PowerFlowData(\n    pf::vPTDFDCPowerFlow,\n    sys::PSY.System\n) -> vPTDFPowerFlowData\n\nCreates a PowerFlowData structure configured for a virtual Partial Transfer Distribution Factor Matrix DC power flow calculation, given the System sys. Configuration options like time_steps, time_step_names, network_reductions, and correct_bustypes are taken from the vPTDFDCPowerFlow object.\n\nCalling this function will not evaluate the power flows and angles. Note that first input is of type vPTDFDCPowerFlow: this version is used to solve DC power flows using a virtual Power Transfer Distribution Factor (PTDF) matrix. This function returns a vPTDFPowerFlowData object.\n\nArguments:\n\npf::vPTDFDCPowerFlow:       Run a virtual PTDF power flow: internally, store the virtual PTDF matrix as       power_network_matrix and the ABA matrix as aux_network_matrix.       Configuration options are taken from this object.\nsys::PSY.System:       A System object that represents the power       grid under consideration.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64}} where {T<:PowerFlowEvaluationModel, M<:PowerNetworkMatrices.PowerNetworkMatrix, N<:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}","page":"Internal API Reference","title":"PowerFlows.PowerFlowData","text":"Sets the two PowerNetworkMatrix fields and a few others (time_steps, time_step_map),  then creates arrays of default values (usually zeros) for the rest.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.SystemPowerFlowContainer","page":"Internal API Reference","title":"PowerFlows.SystemPowerFlowContainer","text":"A PowerFlowContainer that represents its data as a PSY.System.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.vPTDFPowerFlowData","page":"Internal API Reference","title":"PowerFlows.vPTDFPowerFlowData","text":"A type alias for a PowerFlowData struct whose type parameters are configured for the vPTDFDCPowerFlow method.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.make_power_flow_container","page":"Internal API Reference","title":"PowerFlows.make_power_flow_container","text":"Create an appropriate PowerFlowContainer for the given PowerFlowEvaluationModel and initialize it from the given PSY.System.\n\nConfiguration options like time_steps, time_step_names, network_reductions, and correct_bustypes are taken from the PowerFlowEvaluationModel object.\n\nArguments:\n\npfem::PowerFlowEvaluationModel: power flow model to construct a container for (e.g., DCPowerFlow())\nsys::PSY.System: the System from which to initialize the   power flow container\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}","page":"Internal API Reference","title":"PowerFlows.supports_multi_period","text":"Trait signifying whether the PowerFlowContainer can represent multi-period data. Must be implemented for all concrete subtypes.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}}","page":"Internal API Reference","title":"PowerFlows.solve_power_flow!","text":"solve_power_flow!(data::ACPowerFlowData; kwargs...)\n\nSolve the multiperiod AC power flow problem for the given power flow data.\n\nThe bus types can be changed from PV to PQ if the reactive power limits are violated. The power flow solver settings are taken from the ACPowerFlow object stored in data.\n\nArguments\n\ndata::ACPowerFlowData: The power flow data containing the grid information and initial conditions.\nkwargs...: Additional keyword arguments. If these overlap with those in the    solver_settings of the ACPowerFlow object, the values in kwargs take precedence.\n\nKeyword Arguments\n\ntime_steps: Specifies the time steps to solve. Defaults to sorting and collecting the keys of get_time_step_map(data).\n\nDescription\n\nThis function solves the AC power flow problem for each time step specified in data. It preallocates memory for the results and iterates over the sorted time steps.     For each time step, it calls the _ac_power_flow function to solve the power flow equations and updates the data object with the results.     If the power flow converges, it updates the active and reactive power injections, as well as the voltage magnitudes and angles for different bus types (REF, PV, PQ).     If the power flow does not converge, it sets the corresponding entries in data to NaN.     Finally, it calculates the branch power flows and updates the data object.\n\nNotes\n\nIf the grid topology changes (e.g., tap positions of transformers or in-service status of branches), the admittance matrices Yft and Ytf must be updated.\nIf Yft and Ytf change between time steps, the branch flow calculations must be moved inside the loop.\n\nExamples\n\nsolve_power_flow!(data)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.adjust_power_injections_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}","page":"Internal API Reference","title":"PowerFlows.adjust_power_injections_for_lccs!","text":"Adjust the power injections vector to account for the power flows through LCCs.\n\nRelies on the fact that we calculate those flows during initialization and save them to the active_power_flow_from_to and active_power_flow_to_from fields of the LCCParameters struct.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}","page":"Internal API Reference","title":"PowerFlows.solve_power_flow!","text":"solve_power_flow!(data::PTDFPowerFlowData)\n\nEvaluates the PTDF power flow and writes the result to the fields of the  PTDFPowerFlowData structure.\n\nThis function modifies the following fields of data, setting them to the computed values:\n\ndata.bus_angles: the bus angles for each bus in the system.\ndata.branch_active_power_flow_from_to: the active power flow from the \"from\" bus to the \"to\" bus of each branch\ndata.branch_active_power_flow_to_from: the active power flow from the \"to\" bus to the \"from\" bus of each branch\n\nAdditionally, it sets data.converged to true, indicating that the power flow calculation was successful.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{vPTDFDCPowerFlow, <:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}","page":"Internal API Reference","title":"PowerFlows.solve_power_flow!","text":"solve_power_flow!(data::vPTDFPowerFlowData)\n\nEvaluates the virtual PTDF power flow and writes the results to the fields  of the vPTDFPowerFlowData structure.\n\nThis function modifies the following fields of data, setting them to the computed values:\n\ndata.bus_angles: the bus angles for each bus in the system.\ndata.branch_active_power_flow_from_to: the active power flow from the \"from\" bus to the \"to\" bus of each branch\ndata.branch_active_power_flow_to_from: the active power flow from the \"to\" bus to the \"from\" bus of each branch\n\nAdditionally, it sets data.converged to true, indicating that the power flow calculation was successful.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.partition_state-Tuple{Vector{Float64}, AbstractVector{ACBusTypes}}","page":"Internal API Reference","title":"PowerFlows.partition_state","text":"Partitions the state vector's variables based on what physical quantity each represents.  Returns a NamedTuple, with the 4 keys Va, Vm, P, and Q. The 4 values are vectors  of length equal to the number of buses, with NaNs in the positions where that physical  quantity is not part of the state vector for that bus. (Currently not intended for use in  spots where performance is critical.)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.update_data!-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows.update_data!","text":"Update the fields of data based on the values of the state vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.update_net_power!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, AbstractVector{ACBusTypes}}","page":"Internal API Reference","title":"PowerFlows.update_net_power!","text":"Update P_net and Q_net based on the values of the state vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.update_state!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.update_state!","text":"Update state vector based on values of fields of data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.initialize_power_flow_data!-Tuple{PowerFlows.PowerFlowData, PowerFlowEvaluationModel, System}","page":"Internal API Reference","title":"PowerFlows.initialize_power_flow_data!","text":"Sets the fields of a PowerFlowData struct to match the given System.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._dc_power_flow_fallback!-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows._dc_power_flow_fallback!","text":"When solving AC power flows, if the initial guess has large residual, we run a DC power  flow as a fallback. This runs a DC power flow on data::ACPowerFlowData for the given time_step, and writes the solution to data.bus_angles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.calculate_x0-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.calculate_x0","text":"Calculate x0 from data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.dc_power_flow_start!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, PowerFlows.ACPowerFlowResidual}","page":"Internal API Reference","title":"PowerFlows.dc_power_flow_start!","text":"If initial residual is large, run a DC power flow and see if that gives a better starting point for angles. If so, then overwrite x0 with the result of the DC power flow. If not, keep the original x0.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}","page":"Internal API Reference","title":"PowerFlows._calculate_dQ_dV_lcc","text":"_calculate_dQ_dV_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -> Float64\n\nCompute the derivative of reactive power Q with respect to voltage magnitude Vm for LCC converter calculations.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}","page":"Internal API Reference","title":"PowerFlows._calculate_dQ_dt_lcc","text":"_calculate_dQ_dt_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -> Float64\n\nCompute the derivative of reactive power Q with respect to transformer tap t for LCC converter calculations.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}","page":"Internal API Reference","title":"PowerFlows._calculate_dQ_dα_lcc","text":"_calculate_dQ_dα_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64, α::Float64) -> Float64\n\nCompute the derivative of reactive power Q with respect to firing/extinction angle α for LCC converter calculations.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_y_lcc-NTuple{4, Float64}","page":"Internal API Reference","title":"PowerFlows._calculate_y_lcc","text":"_calculate_y_lcc(t::Float64, I_dc::Float64, Vm::Float64, ϕ::Float64) -> ComplexF64\n\nCompute the admittance value Y for LCC converter calculations.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}","page":"Internal API Reference","title":"PowerFlows._calculate_ϕ_lcc","text":"_calculate_ϕ_lcc(α::Float64, I_dc::Float64, x_t::Float64, Vm::Float64) -> Float64\n\nCompute the phase angle ϕ for LCC converter calculations.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.hvdc_fixed_injections!-Tuple{PowerFlows.PowerFlowData, Type{<:TwoTerminalHVDC}, System, Dict{Int64, Int64}, Dict{Int64, Int64}}","page":"Internal API Reference","title":"PowerFlows.hvdc_fixed_injections!","text":"Adjust the power injections/withdrawal vectors to account for all HVDC lines of a given type, modeling those HVDC lines as a simple fixed injection/withdrawal at each terminal.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlows.PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}","page":"Internal API Reference","title":"PowerFlows.initialize_LCC_arcs_and_buses!","text":"Initialize the arcs and bus_indices fields of the LCCParameters structure in the PowerFlowData.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"struct ACPowerFlowResidual\n\nA struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.\n\nFields\n\ndata::ACPowerFlowData: The grid model data.\nRf!::Function: A function that updates the residuals based on the latest values stored in the grid at the given iteration.\nRv::Vector{Float64}: A vector of the values of the residuals.\nP_net::Vector{Float64}: A vector of net active power injections.\nQ_net::Vector{Float64}: A vector of net reactive power injections.\nP_net_set::Vector{Float64}: A vector of the set-points for active power injections (their initial values before power flow calculation).\nbus_slack_participation_factors::SparseVector{Float64, Int}: A sparse vector of the slack participation factors aggregated at the bus level.\nsubnetworks::Dict{Int64, Vector{Int64}}: The dictionary that identifies subnetworks (connected components), with the key defining the REF bus, values defining the corresponding buses in the subnetwork.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)\n\nCreate an instance of ACPowerFlowResidual for a given time step.\n\nArguments\n\ndata::ACPowerFlowData: The power flow data representing the power system model.\ntime_step::Int64: The time step for which the power flow calculation is executed.\n\nReturns\n\nACPowerFlowResidual: An instance containing the residual values, net bus active power injections,    and net bus reactive power injections.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)\n\nUpdate the AC power flow residuals inplace and store the result in the attribute Rv of the struct. The inputs are the values of state vector x and the current time step time_step. This function implements the functor approach for the ACPowerFlowResidual struct. This makes the struct callable. Calling the ACPowerFlowResidual will also update the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nx::Vector{Float64}: The state vector values.\ntime_step::Int64: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)\n\nEvaluate the AC power flow residuals and store the result in Rv using the provided state vector x and the current time step time_step. The residuals are updated inplace in the struct and additionally copied to the provided array. This function implements the functor approach for the ACPowerFlowResidual struct. This makes the struct callable. Calling the ACPowerFlowResidual will also update the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nRv::Vector{Float64}: The vector to store the calculated residuals.\nx::Vector{Float64}: The state vector.\ntime_step::Int64: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows._update_residual_values!","text":"_update_residual_values!(\n    F::Vector{Float64},\n    x::Vector{Float64},\n    P_net::Vector{Float64},\n    Q_net::Vector{Float64},\n    data::ACPowerFlowData,\n    time_step::Int64,\n)\n\nUpdate the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the ACPowerFlowResidual struct. This function also updates the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nF::Vector{Float64}: Vector of the values of the residuals.\nx::Vector{Float64}: State vector values.\nP_net::Vector{Float64}: Vector of net active power injections at each bus.\nQ_net::Vector{Float64}: Vector of net reactive power injections at each bus.\nP_net_set::Vector{Float64}: Vector of the set-points for active power injections (their initial values before power flow calculation).\nbus_slack_participation_factors::SparseVector{Float64, Int}: Sparse vector of the slack participation factors aggregated at the bus level.\nref_bus::Int: The index of the reference bus to be used for the total slack power.\ndata::ACPowerFlowData: Data structure representing the grid model for the AC power flow calculation.\ntime_step::Int64: The current time step for which the residual values are being updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"struct ACPowerFlowJacobian\n\nA struct that represents the Jacobian matrix for AC power flow calculations.\n\nThis struct uses the functor pattern, meaning instances of ACPowerFlowJacobian store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.\n\nFields\n\ndata::ACPowerFlowData: The grid model data used for power flow calculations.\nJf!::Function: A function that calculates the Jacobian matrix inplace.\nJv::SparseArrays.SparseMatrixCSC{Float64, Int32}: The Jacobian matrix, which is updated by the function Jf!.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"(J::ACPowerFlowJacobian)(time_step::Int64)\n\nUpdate the Jacobian matrix Jv using the function Jf! and the provided data and time step.\n\nDefining this method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.\n\nArguments\n\ntime_step::Int64: The time step for the calculations.\n\nExample\n\nJ = ACPowerFlowJacobian(data, time_step)\nJ(time_step)  # Updates the Jacobian matrix Jv\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -> ACPowerFlowJacobian\n\nThis is the constructor for ACPowerFlowJacobian. Create an ACPowerFlowJacobian instance. As soon as the instance is created, it already has  the Jacobian matrix structure initialized and its values updated, stored internally as Jv. The data instance is stored internally and used to update the Jacobian matrix because the  structure of the Jacobian matrix is tied to the data. Changing the data requires creating a  new instance of ACPowerFlowJacobian.\n\nArguments\n\ndata::ACPowerFlowData: The data used for power flow calculations.\ntime_step::Int64: The time step for the calculations.\n\nReturns\n\nACPowerFlowJacobian: An instance of ACPowerFlowJacobian.\n\nExample\n\nJ = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.\nJ(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.\nJ.Jv  # Access the Jacobian matrix stored internally in J.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)\n\nUse the ACPowerFlowJacobian to update the provided Jacobian matrix J inplace.\n\nUpdate the internally stored Jacobian matrix Jv using the function Jf! and the provided data and time step, and write the updated Jacobian values to J.\n\nThis method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.\n\nArguments\n\nJ::SparseArrays.SparseMatrixCSC{Float64, Int32}: A sparse matrix to be updated with new values of the Jacobian matrix.\ntime_step::Int64: The time step for the calculations.\n\nExample\n\nJ = ACPowerFlowJacobian(data, time_step)\nJv = SparseArrays.sparse(Float64[], J_INDEX_TYPE[], J_INDEX_TYPE[])\nJ(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._block_J_indices-Tuple{Vector{<:Integer}, Vector{<:Integer}}","page":"Internal API Reference","title":"PowerFlows._block_J_indices","text":"_block_J_indices(data::ACPowerFlowData, time_step::Int) -> (Vector{Int32}, Vector{Int32})\n\nGet the indices to reindex the Jacobian matrix from the interleaved form to the block form:\n\nbeginbmatrix\nfracpartial Ppartial theta  fracpartial Ppartial V \nfracpartial Qpartial theta  fracpartial Qpartial V\nendbmatrix\n\nArguments\n\npvpq::Vector{Int32}: Indices of the buses that are PV or PQ buses.\npq::Vector{Int32}: Indices of the buses that are PQ buses.\n\nReturns\n\nrows::Vector{Int32}: Row indices for the block Jacobian matrix.\ncols::Vector{Int32}: Column indices for the block Jacobian matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_loss_factors-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}","page":"Internal API Reference","title":"PowerFlows._calculate_loss_factors","text":"calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)\n\nCalculate and store the active power loss factors in the loss_factors matrix of the ACPowerFlowData structure for a given time step.\n\nThe loss factors are computed using the Jacobian matrix Jv and the vector dSbus_dV_ref, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injections as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.\n\nArguments\n\ndata::ACPowerFlowData: The data structure containing power flow information, including the loss_factors matrix.\nJv::SparseMatrixCSC{Float64, Int32}: The sparse Jacobian matrix of the power flow system.\ntime_step::Int: The time step index for which the loss factors are calculated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_voltage_stability_factors-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}","page":"Internal API Reference","title":"PowerFlows._calculate_voltage_stability_factors","text":"calculate_voltage_stability_factors(data::ACPowerFlowData, J::ACPowerFlowJacobian, time_step::Integer)\n\nCalculate and store the voltage stability factors in the voltage_stability_factors matrix of the ACPowerFlowData structure for a given time step. The voltage stability factors are computed using the Jacobian matrix J in block format after a converged power flow calculation.  The results are stored in the voltage_stability_factors matrix in the data instance. The factor for the grid as a whole (σ) is stored in the position of the REF bus. The values of the singular vector v indicate the sensitivity of the buses and are stored in the positions of the PQ buses. The values of v for PV buses are set to zero.  The function uses the method described in \"Fast calculation of a voltage stability index\" by PA Lof et. al.\n\nArguments\n\ndata::ACPowerFlowData: The instance containing the grid model data.\nJ::ACPowerFlowJacobian: The Jacobian matrix cache.\ntime_step::Integer: The calculated time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure","text":"_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -> SparseMatrixCSC{Float64, Int32}\n\nCreate the structure of the Jacobian matrix for an AC power flow problem.\n\nArguments\n\ndata::ACPowerFlowData: The power flow model.\ntime_step::Int64: The specific time step for which the Jacobian matrix structure is created.\n\nReturns\n\nSparseMatrixCSC{Float64, Int32}: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.\n\nDescription\n\nThis function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.\n\nUnlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus.\n\nThis approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.\n\nThe function initializes three arrays (rows, columns, and values) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.\n\nFor each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (REF, PV, or PQ).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.\n\nFor REF buses, entries are added for local active and reactive power.\nFor PV buses, entries are added for active and reactive power with respect to angle, and for local reactive power.\nFor PQ buses, entries are added for active and reactive power with respect to voltage magnitude and angle.\n\nExample Structure\n\nFor a system with 3 buses where bus 1 is REF, bus 2 is PV, and bus 3 is PQ:\n\nLet Delta P_j, Delta Q_j be the active, reactive power balance at the jth bus. Let P_j and Q_j be the active and reactive power generated at the jth bus (REF and PV only). The state vector is x = P_1 Q_1 Q_2 theta_2 V_3 theta_3, and the residual vector is F(x) = Delta P_1 Delta Q_1 Delta P_2 Delta Q_2 Delta P_3 Delta Q_3.\n\nThe Jacobian matrix J = nabla F(x) has the structure:\n\nJ = beginbmatrix\nfracpartial vecFpartial P_1  \nfracpartial vecFpartial Q_1  \nfracpartial vecFpartial Q_2  \nfracpartial vecFpartial theta_2  \nfracpartial vecFpartial V_3  \nfracpartial vecFpartial theta_3\nendbmatrix\n\nIn reality, for large networks, this matrix would be sparse, and each 2×2 block would only be nonzero when there's a line between the respective buses.\n\nFinally, the function constructs a sparse matrix from the collected indices and values and returns it.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a PV bus. Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a reference bus (REF). Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn't matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -> PQ transition and then we need to fill all four values\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_lcc","text":"_create_jacobian_matrix_structure_lcc(\n    data::ACPowerFlowData,\n    rows::Vector{Int32},\n    columns::Vector{Int32},\n    values::Vector{Float64},\n    num_buses::Int\n)\n\nCreate the Jacobian matrix structure for LCC HVDC systems.\n\nDescription\n\nThe function iterates over each LCC system and adds the non-zero entries to the Jacobian matrix structure. The state vector for every LCC contains 4 variables: tap position and thyristor angle for both the rectifier and inverter sides. The indices of non-zero entries correspond to the positions of these variables in the extended state vector.\n\nFor an LCC system connecting bus i (rectifier side) and bus j (inverter side), the state variables are:\n\nt_i: tap position at rectifier\nt_j: tap position at inverter  \nalpha_i: thyristor angle at rectifier\nalpha_j: thyristor angle at inverter\n\nThe residuals include:\n\nF_t_i: Active power balance at rectifier (controls P_i to match setpoint)\nF_t_j: Total active power balance across LCC system\nF_alpha_i: Rectifier thyristor angle constraint (maintains alpha_i at minimum)\nF_alpha_j: Inverter thyristor angle constraint (maintains alpha_j at minimum)\n\nExample Structure\n\nFor a system with 2 buses connected by one LCC where bus 1 is the rectifier side and bus 2 is the inverter side, the Jacobian matrix would have non-zero entries at positions like:\n\nbeginarrayccccccccc\n  V_1  delta_1  V_2  delta_2  t_1  t_2  alpha_1  alpha_2 \nhline\nP_1  fracpartial P_1partial V_1     fracpartial P_1partial t_1   fracpartial P_1partial alpha_1  \nQ_1  fracpartial Q_1partial V_1     fracpartial Q_1partial t_1   fracpartial Q_1partial alpha_1  \nP_2         \nQ_2         \nF_t_1  fracpartial F_t_1partial V_1     fracpartial F_t_1partial t_1   fracpartial F_t_1partial alpha_1  \nF_t_2  fracpartial F_t_2partial V_1   fracpartial F_t_2partial V_2   fracpartial F_t_2partial t_1  fracpartial F_t_2partial t_2  fracpartial F_t_2partial alpha_1  fracpartial F_t_2partial alpha_2 \nF_alpha_1        fracpartial F_alpha_1partial alpha_1  \nF_alpha_2         fracpartial F_alpha_2partial alpha_2\nendarray\n\nThis function sets up the indices of these non-zero entries in the sparse Jacobian matrix structure.\n\nArguments\n\ndata::ACPowerFlowData: The power flow data containing LCC system information.\nrows::Vector{Int32}: Vector to store row indices of non-zero Jacobian entries.\ncolumns::Vector{Int32}: Vector to store column indices of non-zero Jacobian entries.\nvalues::Vector{Float64}: Vector to store initial values of non-zero Jacobian entries.\nnum_buses::Int: Total number of buses in the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}","page":"Internal API Reference","title":"PowerFlows._singular_value_decomposition","text":"_singular_value_decomposition(J::SparseMatrixCSC{Float64, Int32}, npvpq::Integer; tol::Float64 = 1e-9, max_iter::Integer = 100,)\n\nEstimate the smallest singular value σ and corresponding left and right singular vectors u and v of a sparse matrix G_s (a sub-matrix of J). This function uses an iterative method involving LU factorization of the Jacobian matrix to estimate the smallest singular value of G_s.  The algorithm alternates between updating u and v, normalizing, and checking for convergence based on the change in the estimated singular value σ. The function uses the method described in Algorithm 3 of \"Fast calculation of a voltage stability index\" by PA Lof et. al.\n\nArguments\n\nJ::SparseMatrixCSC{Float64, Int32}: The sparse block-form Jacobian matrix.\nnpvpq::Integer: Number of PV and PQ buses in J.\n\nKeyword Arguments\n\ntol::Float64=1e-9: Convergence tolerance for the iterative algorithm.\nmax_iter::Integer=100: Maximum number of iterations.\n\nReturns\n\nσ::Float64: The estimated smallest singular value.\nleft::Vector{Float64}: The estimated left singular vector (referred to as u in the cited paper).\nright::Vector{Float64}: The estimated right singular vector (referred to as v in the cited paper).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, StaticArraysCore.MVector{4, Float64}}","page":"Internal API Reference","title":"PowerFlows._update_jacobian_matrix_values!","text":"Used to update Jv based on the bus voltages, angles, etc. in data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.StateVectorCache","page":"Internal API Reference","title":"PowerFlows.StateVectorCache","text":"Cache for non-linear methods.\n\nFields\n\nx::Vector{Float64}: the current state vector.\nr::Vector{Float64}: the current residual.\nΔx_nr::Vector{Float64}: the step under the Newton-Raphson method.\n\nThe remainder of the fields are only used in the TrustRegionACPowerFlow:\n\nr_predict::Vector{Float64}: the predicted residual at x+Δx_proposed,   under a linear approximation: i.e J_x⋅(x+Δx_proposed).\nΔx_proposed::Vector{Float64}: the suggested step Δx, selected among Δx_nr,    Δx_cauchy, and the dogleg interpolation between the two. The first is chosen when   x+Δx_nr is inside the trust region, the second when both x+Δx_cauchy   and x+Δx_nr are outside the trust region, and the third when x+Δx_cauchy   is inside and x+Δx_nr outside. The dogleg step selects the point where the line   from x+Δx_cauchy to x+Δx_nr crosses the boundary of the trust region.\nΔx_cauchy::Vector{Float64}: the step to the Cauchy point if the Cauchy point   lies within the trust region, otherwise a step in that direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}","page":"Internal API Reference","title":"PowerFlows._do_refinement!","text":"Check error and do refinement.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}","page":"Internal API Reference","title":"PowerFlows._dogleg!","text":"Sets Δx_proposed equal to the Δx by which we should update x. Decides between the Cauchy step Δx_cauchy, Newton-Raphson step Δx_nr, and the dogleg interpolation between the two, based on which fall within the trust region.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}","page":"Internal API Reference","title":"PowerFlows._run_power_flow_method","text":"Runs the full NewtonRaphsonACPowerFlow.\n\nKeyword arguments:\n\nmaxIterations::Int: maximum iterations. Default: 50.\ntol::Float64: tolerance. The iterative search ends when norm(abs.(residual)) < tol.   Default: 1.0e-9.\nrefinement_threshold::Float64: If the solution to J_x Δx = r satisfies   norm(J_x Δx - r, 1)/norm(r, 1) > refinement_threshold, do iterative refinement to   improve the accuracy. Default: 0.05.\nrefinement_eps::Float64: run iterative refinement on J_x Δx = r until   norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) < refinement_eps. Default:    1.0e-6 \n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}","page":"Internal API Reference","title":"PowerFlows._run_power_flow_method","text":"Runs the full TrustRegionNRMethod.\n\nKeyword arguments:\n\nmaxIterations::Int: maximum iterations. Default: 50.\ntol::Float64: tolerance. The iterative search ends when maximum(abs.(residual)) < tol.   Default: 1.0e-9.\nfactor::Float64: the trust region starts out with radius factor*norm(x_0, 1),   where x_0 is our initial guess, taken from data. Default: 1.0.\neta::Float64: improvement threshold. If the observed improvement in our residual   exceeds eta times the predicted improvement, we accept the new x_i.   Default: 0.0001.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}","page":"Internal API Reference","title":"PowerFlows._set_Δx_nr!","text":"Sets the Newton-Raphson step. Usually, this is just J.Jv \\ stateVector.r, but J.Jv might be singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._simple_step","page":"Internal API Reference","title":"PowerFlows._simple_step","text":"Does a single iteration of NewtonRaphsonACPowerFlow. Updates the r and x fields of the stateVector, and computes the Jacobian at the new x.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows._singular_J_fallback","text":"Returns a stand-in matrix for singular J's.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}","page":"Internal API Reference","title":"PowerFlows._solve_Δx_nr!","text":"Solve for the Newton-Raphson step, given the factorization object for J.Jv  (if non-singular) or its stand-in (if singular).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}","page":"Internal API Reference","title":"PowerFlows._trust_region_step","text":"Does a single iteration of the TrustRegionNRMethod: updates the x and r fields of the stateVector and computes the value of the Jacobian at the new x, if needed. Unlike  _simple_step, this has a return value, the updated value of delta`.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}","page":"Internal API Reference","title":"PowerFlows.HomotopyHessian","text":"Compute value of gradient and Hessian at x.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}","page":"Internal API Reference","title":"PowerFlows.A_plus_eq_BT_B!","text":"Does A += B' * B, in a way that preserves the sparse structure of A, if possible. A workaround for the fact that Julia seems to run dropzeros!(A) automatically if I just  do A .+= B' * B.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows._update_hessian_matrix_values!","text":"_update_hessian_matrix_values!(\n    Hv::SparseMatrixCSC{Float64, Int32},\n    F_value::Vector{Float64},\n    data::ACPowerFlowData,\n    time_step::Int64\n)\n\nUpdate the Hessian matrix values for the robust homotopy power flow solver.\n\nDescription\n\nThis function sets Hv equal to:\n\nsum_k=1^2n F_k(x) H_F_k(x)\n\nwhere F_k denotes the kth power balance equation and H_F_k denotes its Hessian matrix.\n\nThis computes only the terms in the Hessian that come from the second derivatives of the power balance equations.  The full Hessian of the objective function also includes a J^T J term, which is computed separately.\n\nSparse Structure\n\nThe Hessian is organized into 2×2 blocks, each corresponding to a pair of buses. For a pair of buses i and k  connected by a branch, the sparse structure of their block depends on the bus types:\n\nbeginarrayccccccc\n  textREF   textPV   textPQ  \n  P_i  Q_i  Q_i  V_i  V_i  theta_i \nhline\ntextREF  P_k       \nQ_k       \nhline\ntextPV  Q_k       \nV_k     bullet  bullet  bullet \nhline\ntextPQ  V_k     bullet  bullet  bullet \ntheta_k     bullet  bullet  bullet\nendarray\n\nwhere bullet represents a potentially non-zero entry.\n\nDiagonal blocks (where i = k) follow the same pattern as if each bus is its own neighbor. Off-diagonal blocks for pairs of buses not connected by a branch are structurally zero.\n\nArguments\n\nHv::SparseMatrixCSC{Float64, Int32}: The Hessian matrix to be updated (modified in-place).\nF_value::Vector{Float64}: Current values of the power balance residuals.\ndata::ACPowerFlowData: The power flow data containing bus and network information.\ntime_step::Int64: The time step for which to compute the Hessian.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._newton_power_flow-Tuple{ACPowerFlow{LevenbergMarquardtACPowerFlow}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows._newton_power_flow","text":"Driver for the LevenbergMarquardtACPowerFlow method: sets up the data  structures (e.g. residual), runs the power flow method via calling _run_power_flow_method  on them, then handles post-processing (e.g. loss factors).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.FixedStructureCHOLMOD","page":"Internal API Reference","title":"PowerFlows.FixedStructureCHOLMOD","text":"In order to in-place modify the numeric values of a CHOLMOD matrix, we need to  write our own wrapper around CHOLMOD.Sparse. \n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.set_values!-Union{Tuple{I}, Tuple{T}, Tuple{PowerFlows.FixedStructureCHOLMOD{T, I}, AbstractVector{T}}} where {T<:Union{Float32, Float64}, I<:Union{Int32, Int64}}","page":"Internal API Reference","title":"PowerFlows.set_values!","text":"set_values!(mat::FixedStructureCHOLMOD, new_vals::AbstractVector{Float64})\n\nIn-place update of the numeric values in the CHOLMOD matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.KLULinSolveCache","page":"Internal API Reference","title":"PowerFlows.KLULinSolveCache","text":"A cached linear solver using KLU. Carefully written so as to minimize allocations: solve! and numeric_refactor! are completely non-allocating.\n\nFields:\n\nK: the underlying KLU object.\nreuse_symbolic::Bool: reuse the symbolic factorization. Defaults to true.\ncheck_pattern::Bool: if true, numeric_refactor! verifies that the new   matrix has the same sparsity structure. Defaults to true.\nrf_common, rf_symbolic, rf_numeric: internal usage. Stored to avoid allocations.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.KLULinSolveCache","text":"Constructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.numeric_refactor!","text":"Frees numeric factorization stored by cache, if non-null. If cache.check_pattern  is true and the sparse matrix structure of A doesn't match the cached one,  throws an error. Finally, computes the numeric factorization of A and stores that to  cache.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.symbolic_factor!","text":"symbolic_factor!(cache::KLULinSolveCache{T},  A::SparseMatrixCSC{Float64, T})\n\nFrees up the current symbolic and numeric factorizations stored by cache, if non-null. Then computes the symbolic factorization of A and stores that to cache.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.symbolic_refactor!","text":"Symbolic refactor. Behavior depends on the values of cache.reuse_symbol and  cache.check_pattern. There are 3 cases:\n\n!reuse_symbol: always refactor. Just calls symbolic_factor(cache, A).\nreuse_symbol && check_pattern: checks if the symbolic structure of A matches the   cached one, and throws an error if it doesn't. This is to prevent bad input: we expected    the structure to be the same, but it isn't.\nreuse_symbol && !check pattern: do nothing. Assume the structure of A matches the cached    one.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.LinearSolverCache","page":"Internal API Reference","title":"PowerFlows.LinearSolverCache","text":"Abstract supertype for all cached linear solvers. Subtypes must implement: symbolic_factor!, symbolic_refactor!, numeric_refactor! (which doubles as numeric_factor!), and solve!.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows._build_transformer_2w_metadata!-Tuple{AbstractDict, Any, Any, Any}","page":"Internal API Reference","title":"PowerFlows._build_transformer_2w_metadata!","text":"Build metadata mappings for 2-winding transformers.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._build_transformer_3w_metadata!-Tuple{AbstractDict, Any, Any, Any}","page":"Internal API Reference","title":"PowerFlows._build_transformer_3w_metadata!","text":"Build metadata mappings for 3-winding transformers.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._first_choice_gen_id-Tuple{String}","page":"Internal API Reference","title":"PowerFlows._first_choice_gen_id","text":"Try to make an informative one or two character name for the load/generator/etc.\n\ngenerator-1234-AB -> AB\n123_CT_7 -> 7\nload1234 -> 34\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._fix_3w_transformer_rating-Tuple{Any}","page":"Internal API Reference","title":"PowerFlows._fix_3w_transformer_rating","text":"Setting a value of zero 0.0 when having a value greater than or equal to INFINITE_BOUND reverses the operation done in the PSY parsing side, according to PSSE Manual.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._load_transformer_components-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows._load_transformer_components","text":"Load transformer components (2W and 3W) and create circuit mappings.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._make_gens_from_hvdc-NTuple{8, Any}","page":"Internal API Reference","title":"PowerFlows._make_gens_from_hvdc","text":"Create a synthetic generator (PSY.ThermalStandard) representing one end of a TwoTerminalGenericHVDCLine for export purposes. The generator is initialized with parameters reflecting the HVDC line's state. \n\nNotes\n\n- The generator's name is constructed as \"<hvdc_line_name>_<suffix>\".\n- The `ext` field includes `\"HVDC_END\"` to indicate the end (\"FR\"/\"TO\").\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._map_psse_container_names-Tuple{Vector{String}}","page":"Internal API Reference","title":"PowerFlows._map_psse_container_names","text":"Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}","page":"Internal API Reference","title":"PowerFlows._psse_bus_names","text":"Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}","page":"Internal API Reference","title":"PowerFlows._psse_bus_numbers","text":"Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}","page":"Internal API Reference","title":"PowerFlows._psse_transformer_names","text":"Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.\n\nWRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}","page":"Internal API Reference","title":"PowerFlows._update_gens_from_hvdc!","text":"Update the parameters of synthetic generators created from HVDC lines, so they reflect the current setpoints and limits of the HVDC devices in the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._write_2w_transformer!-Tuple{IO, TwoWindingTransformer, Tuple{Int64, Int64}, PSSEExporter, AbstractDict{Int64, Int64}, AbstractDict{String, String}, AbstractDict{Tuple{Tuple{Int64, Int64}, String}, String}, Vararg{Any, 7}}","page":"Internal API Reference","title":"PowerFlows._write_2w_transformer!","text":"Write 2-winding transformer data to buffer.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._write_3w_transformer!-Tuple{IO, ThreeWindingTransformer, Tuple{Int64, Int64, Int64}, PSSEExporter, AbstractDict{Int64, Int64}, AbstractDict{String, String}, AbstractDict{Tuple{Tuple{Int64, Int64, Int64}, String}, String}, Vararg{Any, 7}}","page":"Internal API Reference","title":"PowerFlows._write_3w_transformer!","text":"Write 3-winding transformer data to buffer.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._write_transformer_headers!-Tuple{IO, Symbol}","page":"Internal API Reference","title":"PowerFlows._write_transformer_headers!","text":"Write header comments for transformer data (v35 only).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{<:Array{UInt8}}, Base.GenericIOBuffer{<:GenericMemory{:not_atomic, UInt8}}}, Float64}","page":"Internal API Reference","title":"PowerFlows.better_float_to_buf","text":"Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.check_supported_version-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows.check_supported_version","text":"Throw a NotImplementedError if the psse_version is not supported\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"PowerFlows.convert_empty","text":"If val is empty, returns T(); if not, asserts that val isa T and returns val. Has nice type checker semantics.\n\nExamples\n\nconvert_empty(Vector{String}, [])  # -> String[]\nconvert_empty(Vector{String}, [\"a\"])  # -> [\"a\"]\nconvert_empty(Vector{String}, [2])  # -> TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}\nBase.return_types(Base.Fix1(convert_empty, Vector{String}))  # -> [Vector{String}]\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{<:String}, Vector{T}}} where T","page":"Internal API Reference","title":"PowerFlows.create_component_ids","text":"Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The \"singlesto1\" flag detects components that are the only one on their bus and gives them the name \"1\".\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlowEvaluationModel}","page":"Internal API Reference","title":"PowerFlows.flatten_power_flow_evaluation_model","text":"Expand a single PowerFlowEvaluationModel into its possibly multiple parts for separate evaluation. Namely, if pfem contains a non-nothing exporter, return [pfem, exporter], else return [pfem].\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows.get_branches_with_numbers","text":"Collects all AC branches (Line, MonitoredLine, DiscreteControlledACBranch) from the system, sorts them by their bus numbers, and returns a vector of tuples (branch, bus_numbers).\n\nArguments\n\nexporter::PSSEExporter: The exporter containing the system.\n\nReturns\n\nVector{Tuple{<:PSY.Branch, Tuple}}: Each tuple contains a branch and its associated bus numbers.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.reset_caches-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows.reset_caches","text":"Force all cached information (serialized metadata, component lists, etc.) to be regenerated\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}","page":"Internal API Reference","title":"PowerFlows.serialize_component_ids","text":"Take the output of create_component_ids and make it more suitable for JSON serialization\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Bus Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Case Identification Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Case Identification Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"FACTS Device Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 FACTS Device Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Fixed Shunt Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Fixed Bus Shunt Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Generator Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Generator Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Load Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Load Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Non-Transformer Branch Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Non-Transformer Branch Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Q Record\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Switched Shunt Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Switched Shunt Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Switching Device Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 35.4 POM 5.2.1 System Switching Device Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Transformer Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Transformer Impedance Correction Tables\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Impedance Correction Tables\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Two-Terminal DC Transmission Line Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Two-Terminal DC Transmission Line Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Voltage Source Converter (VSC) DC Transmission Line Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Voltage Source Converter (VSC) DC Transmission Line Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Zone Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Zone Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlows.PowerFlowData, Int64}","page":"Internal API Reference","title":"PowerFlows._calculate_fixed_admittance_powers","text":"Returns a dictionary of bus index to power contribution at that bus from FixedAdmittance components, as a tuple of (active power, reactive power).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}","page":"Internal API Reference","title":"PowerFlows._set_series_voltages_and_flows!","text":"_set_series_voltages_and_flows!(\n    sys::PSY.System,\n    segment_sequence::PNM.BranchesSeries,\n    equivalent_arc::Tuple{Int, Int},\n    V_endpoints::Tuple{ComplexF64, ComplexF64},\n    temp_bus_map::Dict{Int, String},\n)\n\nCalculate series voltages at buses removed in degree 2 reduction.\n\nMethod\n\nNumber the nodes in the series segment 0, 1, ..., n. Number the segments by their concluding node: 1, 2, ... n. The currents in the segments are given by:\n\nbeginbmatrix y^i_ff  y^i_ft  y^i_tf  y^i_tt endbmatrix\nbeginbmatrix V_i-1  V_i endbmatrix =\nbeginbmatrix I_i-1 i  I_i i-1 endbmatrix\n\nwhere upper indices denote the segment number.\n\nThere are no loads or generators at the internal nodes, so I_i i+1 + I_i i-1 = 0. Substitute the above expressions for the currents and group by V_i:\n\ny^i_tf V_i-1 + (y_tt^i + y_ff^i+1) V_i + y_ft^i+1 V_i+1 = 0\n\nFor i = 1 and i = n-1, move the terms involving V_0 and V_n (known) to the other side. This gives a tridiagonal system for x = V_1 ldots V_n-1:\n\nA x = -y^1_tf V_0 0 ldots 0 -y^n_ft V_n\n\nwhere A has diagonal entries y_tt^i + y_ff^i+1, subdiagonal entries y_tf^i+1, and superdiagonal entries y_ft^i.\n\nIn the implementation, y_11 is used instead of y_ff, y_12 instead of y_ft, etc.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_arc_names-Tuple{PowerFlows.PowerFlowData}","page":"Internal API Reference","title":"PowerFlows.get_arc_names","text":"Return the names of the arcs in the power flow data: those that correspond to branches in the system will get the branch names, others will get a placeholder name of the form from-to.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.set_branch_flows_for_dict!","text":"Set the power flow in the arcs that remain after network reduction. Called on the direct_branch_map and transformer3W_map dictionaries.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.update_system!-Tuple{System, PowerFlows.PowerFlowData}","page":"Internal API Reference","title":"PowerFlows.update_system!","text":" update_system!(sys::PSY.System, data::PowerFlowData; time_step = 1)\n\nModify the values in the given System to correspond to the given PowerFlowData such that if a new PowerFlowData is constructed from the resulting system it is the same as data. See also write_power_flow_solution!. NOTE this assumes that data was initialized from sys and then solved with no further modifications.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_power_flow_solution!","page":"Internal API Reference","title":"PowerFlows.write_power_flow_solution!","text":"Updates system voltages and powers with power flow results\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlows.PowerFlowData{<:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, <:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}","page":"Internal API Reference","title":"PowerFlows.write_results","text":"write_results(\n    ::ACPowerFlow{<:ACPowerFlowSolverType},\n    sys::PSY.System,\n    data::ACPowerFlowData,\n    time_step::Int64,\n) -> Dict{String, DataFrames.DataFrame}\n\nReturns a dictionary containing the AC power flow results.\n\nOnly single-period evaluation is supported at the moment for AC Power flows. The resulting dictionary will therefore feature just one key linked to one DataFrame.\n\nArguments:\n\n::ACPowerFlow:       use ACPowerFlow() storing AC power flow results.\nsys::PSY.System:       container storing the system information.\nresult::Vector{Float64}:       vector containing the results for one single time-period.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_results-Tuple{Union{PowerFlows.PowerFlowData{DCPowerFlow, PowerNetworkMatrices.DC_ABA_Matrix_Factorized, PowerNetworkMatrices.DC_BA_Matrix}, PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlows.PowerFlowData{vPTDFDCPowerFlow, <:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, System, FlowReporting}","page":"Internal API Reference","title":"PowerFlows.write_results","text":"write_results(\n    data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData},\n    sys::PSY.System,\n)\n\nReturns a dictionary containing the DC power flow results. Each key corresponds to the name of the considered time periods, storing a DataFrame with the power flow results.\n\nArguments:\n\ndata::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}:       PowerFlowData structure containing power flows and bus angles.\nsys::PSY.System:       A PowerSystems.System object storing the system information.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.can_be_PV-Tuple{System}","page":"Internal API Reference","title":"PowerFlows.can_be_PV","text":"Return set of all bus numbers that can be PV: i.e. have an available generator, or certain voltage regulation devices.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}","page":"Internal API Reference","title":"PowerFlows.get_active_and_reactive_power_from_generator","text":"Return the active and reactive power generation from a generator component. It's pg=0 as default for synchronous condensers since there's no field in the component for active power.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}","page":"Internal API Reference","title":"PowerFlows.get_active_power_limits_for_power_flow","text":"Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to PSY.get_active_power_limits in all but special cases.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}","page":"Internal API Reference","title":"PowerFlows.get_reactive_power_limits_for_power_flow","text":"Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to PSY.get_reactive_power_limits in all but special cases.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.must_be_PV-Tuple{System}","page":"Internal API Reference","title":"PowerFlows.must_be_PV","text":"Return set of all bus numbers that must be PV: i.e. have an available generator.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}","page":"Internal API Reference","title":"PowerFlows.my_mul_mt","text":"Similar to above: A*X where X is a matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows.my_mul_mt","text":"Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.siground-Tuple{Float64}","page":"Internal API Reference","title":"PowerFlows.siground","text":"For pretty printing floats in debugging messages.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.wdot-NTuple{4, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows.wdot","text":"Weighted dot product of two vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows.wnorm","text":"Weighted norm of two vectors.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.contributes_active_power-Tuple{T} where T<:Device","page":"Internal API Reference","title":"PowerFlows.contributes_active_power","text":"Check if a device has attribute 'active_power' for active power consumption or generation.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows","page":"Public API Reference","title":"PowerFlows","text":"","category":"section"},{"location":"reference/api/public/#Power-Flow-Evaluation-Models-and-AC-Solvers","page":"Public API Reference","title":"Power Flow Evaluation Models and AC Solvers","text":"","category":"section"},{"location":"reference/api/public/#Solving-Power-Flows","page":"Public API Reference","title":"Solving Power Flows","text":"","category":"section"},{"location":"reference/api/public/#PSSE-Export","page":"Public API Reference","title":"PSSE Export","text":"","category":"section"},{"location":"reference/api/public/#PowerFlows.ACPowerFlow","page":"Public API Reference","title":"PowerFlows.ACPowerFlow","text":"ACPowerFlow{ACSolver}(; kwargs...) where {ACSolver <: ACPowerFlowSolverType}\nACPowerFlow(; kwargs...)\n\nAn evaluation model for a standard AC power flow with the specified solver type.\n\nArguments\n\nACSolver: The type of AC power flow solver to use, which must be a subtype of ACPowerFlowSolverType.   If not specified, defaults to NewtonRaphsonACPowerFlow.\ncheck_reactive_power_limits::Bool: Whether to check reactive power limits during the power flow solution.   Default is false.\nexporter::Union{Nothing, PowerFlowEvaluationModel}: An optional exporter for the power flow results.   If not nothing, it should be a PSSEExportPowerFlow. Default is nothing.\ncalculate_loss_factors::Bool: Whether to calculate loss factors during the power flow solution.   Default is false.\ncalculate_voltage_stability_factors::Bool: Whether to calculate voltage stability factors.   Default is false.\ngenerator_slack_participation_factors: An optional parameter that specifies the participation   factors for generator slack in the power flow solution. If nothing, all slack is picked up by   the reference bus. If a Dict{Tuple{DataType, String}, Float64}, it should map   (component_type, component_name) tuples to participation factors. If a Vector of such   dictionaries, different participation factors can be used for different time steps. Default is nothing.\nenhanced_flat_start::Bool: Whether to use enhanced flat start initialization. Default is true.\nrobust_power_flow::Bool: Whether to use run a DC power flow as a fallback if the initial residual is large.   Default is false.\nskip_redistribution::Bool: Whether to skip slack redistribution. Default is false.\nnetwork_reductions::Vector{PNM.NetworkReduction}: Network reductions to apply.   Default is an empty vector.\ntime_steps::Int: Number of time steps to solve. Default is 1.\ntime_step_names::Vector{String}: Names for each time step. Default is an empty vector.\ncorrect_bustypes::Bool: Whether to automatically correct bus types based on available generation.   Default is false.\nsolver_settings::Dict{Symbol, Any}: Additional keyword arguments to pass to the solver.   Default is an empty dictionary.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.ACPowerFlow-Union{Tuple{}, Tuple{ACSolver}} where ACSolver<:ACPowerFlowSolverType","page":"Public API Reference","title":"PowerFlows.ACPowerFlow","text":"ACPowerFlow{ACSolver}(\n    check_reactive_power_limits::Bool = false,\n    exporter::Union{Nothing, PowerFlowEvaluationModel} = nothing,\n    calculate_loss_factors::Bool = false,\n    generator_slack_participation_factors::Union{\n        Nothing,\n        Dict{Tuple{DataType, String}, Float64},\n        Vector{Dict{Tuple{DataType, String}, Float64}},\n    } = nothing,\n) where {ACSolver <: ACPowerFlowSolverType}\n\nAn evaluation model for a standard  AC power flow  with the specified solver type.\n\nArguments\n\nACSolver: The type of AC power flow solver to use, which must be a subtype of ACPowerFlowSolverType.   Default is NewtonRaphsonACPowerFlow.\ncheck_reactive_power_limits::Bool: Whether to check reactive power limits during the power flow solution.   Default is false.\nexporter::Union{Nothing, PowerFlowEvaluationModel}: An optional exporter for the power flow results.    If not nothing, it should be a PSSEExportPowerFlow.\ncalculate_loss_factors::Bool: Whether to calculate loss factors during the power flow solution.   Default is false.\ngenerator_slack_participation_factors::Union{Nothing, Dict{Tuple{DataType, String}, Float64}, Vector{Dict{Tuple{DataType, String}, Float64}}}:   An optional parameter that specifies the participation factors for generator slack in the power flow solution.   If nothing, all slack is picked up by the reference bus. If a Dict, it should map (component_type, component_name)   tuples to participation factors. If a Vector, it should contain multiple such dictionaries,    allowing for different participation factors for different time steps.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.ACPowerFlowSolverType","page":"Public API Reference","title":"PowerFlows.ACPowerFlowSolverType","text":"An abstract supertype for all iterative methods. Subtypes: NewtonRaphsonACPowerFlow, TrustRegionACPowerFlow,  LevenbergMarquardtACPowerFlow, and RobustHomotopyPowerFlow.\n\nSee also: ACPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.AbstractDCPowerFlow","page":"Public API Reference","title":"PowerFlows.AbstractDCPowerFlow","text":"An abstract supertype for all DC power flow evaluation models. Subtypes: DCPowerFlow, PTDFDCPowerFlow, and vPTDFDCPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.DCPowerFlow","page":"Public API Reference","title":"PowerFlows.DCPowerFlow","text":"DCPowerFlow(; kwargs...)\n\nAn evaluation model for a standard DC power flow.\n\nThis provides a fast approximate solution to the AC power flow problem, by solving for the  bus voltage angles under some simplifying assumptions (lossless lines, constant voltage  magnitudes, etc.). Branch flows are then calculated from the voltage angles. For details, see  Wikipedia or section 4 of the MATPOWER docs.\n\nArguments\n\nexporter::Union{Nothing, PowerFlowEvaluationModel}: An optional exporter for the power flow results.   If not nothing, it should be a PSSEExportPowerFlow. Default is nothing.\nnetwork_reductions::Vector{PNM.NetworkReduction}: Network reductions to apply.   Default is an empty vector.\ntime_steps::Int: Number of time steps to solve. Default is 1.\ntime_step_names::Vector{String}: Names for each time step. Default is an empty vector.\ncorrect_bustypes::Bool: Whether to automatically correct bus types based on available generation.   Default is false.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.LevenbergMarquardtACPowerFlow","page":"Public API Reference","title":"PowerFlows.LevenbergMarquardtACPowerFlow","text":"LevenbergMarquardtACPowerFlow <: ACPowerFlowSolverType\n\nAn ACPowerFlowSolverType corresponding to the Levenberg-Marquardt iterative method. This is more robust than the basic Newton-Raphson method, but also more computationally intensive. Due to the difficulty of tuning meta parameters, this method may occasionally  fail to converge where other methods would succeed.\n\nSee also: ACPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.NewtonRaphsonACPowerFlow","page":"Public API Reference","title":"PowerFlows.NewtonRaphsonACPowerFlow","text":"NewtonRaphsonACPowerFlow <: ACPowerFlowSolverType\n\nAn ACPowerFlowSolverType corresponding to a basic Newton-Raphson iterative method.  The Newton step is taken verbatim at each iteration: no line search is performed.\n\nSee also: ACPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.PTDFDCPowerFlow","page":"Public API Reference","title":"PowerFlows.PTDFDCPowerFlow","text":"PTDFDCPowerFlow(; kwargs...)\n\nAn evaluation model that calculates line flows using the Power Transfer Distribution Factor Matrix.\n\nThis approximates the branch flows in the power grid, under some simplifying assumptions (lossless lines, constant voltage magnitudes, etc.). In contrast to DCPowerFlow,  branch flows are computed directly from bus power injections, without use of the voltage  angles. See section 4 of the MATPOWER docs  for details.\n\nArguments\n\nexporter::Union{Nothing, PowerFlowEvaluationModel}: An optional exporter for the power flow results.   If not nothing, it should be a PSSEExportPowerFlow. Default is nothing.\nnetwork_reductions::Vector{PNM.NetworkReduction}: Network reductions to apply.   Default is an empty vector.\ntime_steps::Int: Number of time steps to solve. Default is 1.\ntime_step_names::Vector{String}: Names for each time step. Default is an empty vector.\ncorrect_bustypes::Bool: Whether to automatically correct bus types based on available generation.   Default is false.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.PowerFlowEvaluationModel","page":"Public API Reference","title":"PowerFlows.PowerFlowEvaluationModel","text":"An abstract supertype for all types of power flows. Subtypes: ACPowerFlow, AbstractDCPowerFlow, and  PSSEExportPowerFlow. The last isn't a power flow in the usual sense, but it is  implemented that way (with writing the export file as solving the power flow) for interface reasons.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.RobustHomotopyPowerFlow","page":"Public API Reference","title":"PowerFlows.RobustHomotopyPowerFlow","text":"RobustHomotopyPowerFlow <: ACPowerFlowSolverType\n\nAn ACPowerFlowSolverType corresponding to a homotopy iterative method, based on the paper \"Improving the robustness of Newton-based power flow methods to cope with poor  initial points\". This is significantly more  robust than Newton-Raphson, but also slower by an order of magnitude or two.\n\nSee also: ACPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.TrustRegionACPowerFlow","page":"Public API Reference","title":"PowerFlows.TrustRegionACPowerFlow","text":"TrustRegionACPowerFlow <: ACPowerFlowSolverType\n\nAn ACPowerFlowSolverType corresponding to the Powell dogleg iterative method.  This is a bit more robust than the basic Newton-Raphson method and comparably lightweight.\n\nSee also: ACPowerFlow.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.vPTDFDCPowerFlow","page":"Public API Reference","title":"PowerFlows.vPTDFDCPowerFlow","text":"vPTDFDCPowerFlow(; kwargs...)\n\nAn evaluation model that calculates line flows using a virtual Power Transfer Distribution Factor Matrix.\n\nThis is a replacement for the PTDFDCPowerFlow for large grids, where creating and storing the full PTDF matrix would be infeasible or slow. See the PowerNetworkMatrices.jl docs for details.\n\nArguments\n\nexporter::Union{Nothing, PowerFlowEvaluationModel}: An optional exporter for the power flow results.   If not nothing, it should be a PSSEExportPowerFlow. Default is nothing.\nnetwork_reductions::Vector{PNM.NetworkReduction}: Network reductions to apply.   Default is an empty vector.\ntime_steps::Int: Number of time steps to solve. Default is 1.\ntime_step_names::Vector{String}: Names for each time step. Default is an empty vector.\ncorrect_bustypes::Bool: Whether to automatically correct bus types based on available generation.   Default is false.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.FlowReportingModule.FlowReporting","page":"Public API Reference","title":"PowerFlows.FlowReportingModule.FlowReporting","text":"FlowReporting\n\nEnumeration describing the type of flows reported in power flow results.\n\nValues\n\nARC_FLOWS = 0: Report total flows corresponding to arcs.\nBRANCH_FLOWS = 1: Report flows for individual branches.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.solve_power_flow-Tuple{Union{PowerFlows.PowerFlowData{DCPowerFlow, PowerNetworkMatrices.DC_ABA_Matrix_Factorized, PowerNetworkMatrices.DC_BA_Matrix}, PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlows.PowerFlowData{vPTDFDCPowerFlow, <:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, System, FlowReporting}","page":"Public API Reference","title":"PowerFlows.solve_power_flow","text":"Evaluates the power flows on the system's branches by means of the method associated with the PowerFlowData structure data, which can be one of PTDFPowerFlowData, vPTDFPowerFlowData, or ABAPowerFlowData. Returns a dictionary of DataFrames, each containing the flows and bus voltages for the input PSY.System at that timestep. The flowreporting input determines if flows are reported for arcs (FlowReporting.ARCFLOWS) or for branches (FlowReporting.BRANCHFLOWS)\n\nArguments:\n\ndata::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}:       PowerFlowData structure containing the system's data per each time_step       considered, as well as the associated matrix for the power flow.\nsys::PSY.System:       container gathering the system data.\nflow_reporting::FlowReporting:       Format for reporting flows\n\nNote that data must have been created from the System  sys using one of the PowerFlowData constructors.\n\nExample\n\nusing PowerFlows, PowerSystemCaseBuilder\nsys = build_system(PSITestSystems, \"c_sys14\")\ndata = PowerFlowData(PTDFDCPowerFlow(; time_steps = 2), sys)\nd = solve_power_flow(data, sys)\ndisplay(d[\"2\"][\"flow_results\"])\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_power_flow-Union{Tuple{T}, Tuple{T, System, FlowReporting}} where T<:AbstractDCPowerFlow","page":"Public API Reference","title":"PowerFlows.solve_power_flow","text":"solve_power_flow(\n    pf::T,\n    sys::PSY.System,\n    flow_reporting::FlowReporting\n) where T <: AbstractDCPowerFlow\n\nEvaluates the provided DC power flow method pf on the PowerSystems.System sys, returning a dictionary of DataFrames containing the calculated flows and bus angles. The flowreporting input determines if flows are reported for arcs (FlowReporting.ARCFLOWS) or for branches (FlowReporting.BRANCH_FLOWS)\n\nConfiguration options like time_steps, time_step_names, network_reductions, and correct_bustypes should be set on the power flow object (e.g., DCPowerFlow(; time_steps=2)).\n\nProvided for convenience: this interface bypasses the need to create a PowerFlowData struct, but that's still what's happening under the hood.\n\nExample\n\nusing PowerFlows, PowerSystemCaseBuilder\nsys = build_system(PSITestSystems, \"c_sys5\")\nd = solve_power_flow(DCPowerFlow(), sys)\ndisplay(d[\"1\"][\"flow_results\"])\ndisplay(d[\"1\"][\"bus_results\"])\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_and_store_power_flow!-Tuple{ACPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_and_store_power_flow!","text":"solve_and_store_power_flow!(pf::ACPowerFlow{<:ACPowerFlowSolverType}, system::PSY.System; kwargs...)\n\nSolves the power flow in the system and writes the solution into the relevant structs. Updates active and reactive power setpoints for generators and active and reactive power flows for branches (calculated in the From - To direction and in the To - From direction).\n\nConfiguration options like time_steps, time_step_names, network_reductions, and correct_bustypes should be set on the ACPowerFlow object.\n\nThe bus types can be changed from PV to PQ if the reactive power limits are violated.\n\nArguments\n\npf::ACPowerFlow{<:ACPowerFlowSolverType}: the power flow struct,   which contains configuration options.\nsystem::PSY.System: The power system model, a PowerSystems.System struct.\nkwargs...: Additional keyword arguments passed to the solver.\n\nKeyword Arguments\n\ntol: Infinite norm of residuals under which convergence is declared. Default is 1e-9.\nmaxIterations: Maximum number of Newton-Raphson iterations. Default is 30.\n\nReturns\n\nconverged::Bool: Indicates whether the power flow solution converged.\nThe power flow results are written into the system struct.\n\nExamples\n\nsolve_and_store_power_flow!(pf, sys)\n\n# With correct_bustypes enabled\npf = ACPowerFlow(; correct_bustypes = true)\nsolve_and_store_power_flow!(pf, sys)\n\n# Passing solver keyword arguments\nsolve_and_store_power_flow!(pf, sys; maxIterations=100)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_power_flow-Tuple{ACPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_power_flow","text":"Similar to solve_and_store_power_flow! but does not update the system struct with results. Returns the results in a dictionary of dataframes.\n\nExamples\n\nres = solve_power_flow(pf, sys)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}","page":"Public API Reference","title":"PowerFlows.PSSEExportPowerFlow","text":"PSSEExportPowerFlow(psse_version::Symbol, export_dir::AbstractString; kwargs...)\n\nAn evaluation model for exporting power flow results to PSSE format.\n\nArguments:\n\npsse_version::Symbol: The version of PSSE to export to. Must be among [:v33, :v35].\nexport_dir::AbstractString: The directory where the PSSE files will be exported.\n\nOptional keyword arguments:\n\nname::AbstractString: The base name for the exported files. Defaults to \"export\".\nwrite_comments::Bool: Whether to write comments in the exported files. Defaults to false.\noverwrite::Bool: Whether to overwrite the file if it exists already. Defaults to false.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.PSSEExporter","page":"Public API Reference","title":"PowerFlows.PSSEExporter","text":"Structure to perform an export from a Sienna System, plus optional updates from PowerFlowData, to the PSS/E format.\n\nConstruct this object from a System and a PSS/E version,  update using update_exporter with any new data as relevant, and perform the export with write_export. Writes a <name>.raw file and a <name>_export_metadata.json file with transformations that had to be made to conform to PSS/E naming rules, which can be parsed by PowerSystems.jl to perform a round trip with the names restored.\n\nArguments:\n\nbase_system::PSY.System: the system to be exported. Later updates may change power flow-related values but may not fundamentally alter the system\npsse_version::Symbol: the version of PSS/E to target, must be one of [:v33, :v35]\nwrite_comments::Bool = false: whether to add the customary-but-not-in-spec-annotations after a slash on the first line and at group boundaries\nname::AbstractString = \"export\": the base name of the export\nstep::Any = nothing: optional step data to append to the base export name. User is responsible for updating the step data. If the step data is nothing, it is not used; if it is a tuple or vector, it is joined with _ and concatted; else it is concatted after _.\noverwrite::Bool = false: true to silently overwrite existing exports, false to throw an error if existing results are encountered\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.get_psse_export_paths-Tuple{AbstractString}","page":"Public API Reference","title":"PowerFlows.get_psse_export_paths","text":"Calculate the paths of the (raw, metadata) files that would be written by a certain call to write_export\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlows.PowerFlowData}","page":"Public API Reference","title":"PowerFlows.update_exporter!","text":"Update the PSSEExporter with new data.\n\nArguments:\n\nexporter::PSSEExporter: the exporter to update\ndata::PSY.PowerFlowData: the new data. Must correspond to the  System with which the exporter was constructed.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.update_exporter!-Tuple{PSSEExporter, System}","page":"Public API Reference","title":"PowerFlows.update_exporter!","text":"Update the PSSEExporter with new data.\n\nArguments:\n\nexporter::PSSEExporter: the exporter to update\ndata::PSY.System: system containing the new data. Must be fundamentally the same System as the one with which the exporter was  constructed, just with different values — this is the user's responsibility, we do not  exhaustively verify it.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}","page":"Public API Reference","title":"PowerFlows.write_export","text":"Perform an export from the data contained in a PSSEExporter to the PSS/E file format.\n\n\n\n\n\n","category":"method"},{"location":"explanation/stub/#Explanation","page":"Explanation","title":"Explanation","text":"Refer here to find context and further explanation of the workings of PowerAnalytics. ","category":"section"},{"location":"reference/developers/developer/#Guidelines-for-Developers","page":"Code Base Developer Guide","title":"Guidelines for Developers","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:\n\nStyle Guide\nContributing Guidelines\n\nPull requests are always welcome to fix bugs or add additional modeling capabilities.\n\nAll the code contributions need to include tests with a minimum coverage of 70%","category":"section"},{"location":"tutorials/solving-a-power-flow/#Solving-a-Power-Flow","page":"Solving a Power Flow","title":"Solving a Power Flow","text":"In this tutorial, you'll solve power flows on a 5-bus test system using three different solvers and compare their results.","category":"section"},{"location":"tutorials/solving-a-power-flow/#Building-a-System","page":"Solving a Power Flow","title":"Building a System","text":"To get started, load the needed packages. We're using a standard test system and want to  keep output clean, so we adjust the logging settings to filter out a few precautionary warnings.\n\nusing PowerSystemCaseBuilder\nusing PowerFlows\nusing PowerSystems\nusing Logging\ndisable_logging(Logging.Warn)\n\nCreate a System from PowerSystemCaseBuilder.jl:\n\nsys = build_system(MatpowerTestSystems, \"matpower_case5_sys\")","category":"section"},{"location":"tutorials/solving-a-power-flow/#DC-Power-Flow","page":"Solving a Power Flow","title":"DC Power Flow","text":"DCPowerFlow solves for bus voltage angles using the bus admittance matrix,  then computes branch flows from the angle differences. Create a DCPowerFlow solver:\n\npf_dc = DCPowerFlow()\n\nSolve the power flow with solve_power_flow:\n\ndc_results = solve_power_flow(pf_dc, sys)\n\nThe result is a Dict{String, Dict{String, DataFrame}}. The outer key is the time step name: \"1\". The inner dictionary stores the power flow results at that time step: \"bus_results\" for bus data and \"flow_results\" key for AC line data. (There's also 3rd key, \"lcc_results\", for HVDC lines, but this sytem  contains no such components, so the matching dataframe will be emtpy.) Inspect \"bus_results\":\n\ndc_results[\"1\"][\"bus_results\"]\n\nNotice that Vm (voltage magnitude) is 1.0 for all buses, and Q_gen and Q_load are 0. This is expected for DC power flow, which assumes flat voltage magnitudes and ignores reactive power.\n\ndc_results[\"1\"][\"flow_results\"]\n\nLikewise, Q_from_to and Q_to_from (reactive power flow on the line) are zero, for all lines.","category":"section"},{"location":"tutorials/solving-a-power-flow/#PTDF-DC-Power-Flow","page":"Solving a Power Flow","title":"PTDF DC Power Flow","text":"PTDFDCPowerFlow computes branch flows directly from bus power injections using the Power Transfer Distribution Factor matrix, without solving for voltage angles as an intermediate step. (This means we can omit the angle computation in contexts where we only  care about line flows, though we don't have that option implemented here.) Create a PTDFDCPowerFlow solver:\n\npf_ptdf = PTDFPowerFlow()\n\nAs before, solve the power flow with solve_power_flow:\n\ndc_results = solve_power_flow(pf_ptdf, sys)\n\nLook at the bus results:\n\nptdf_results[\"1\"][\"bus_results\"]\n\nThe results match DCPowerFlow, as they should: the two are mathematically equivalent.  For very large systems where forming the full PTDF matrix would be too expensive,  consider vPTDFDCPowerFlow, which computes the same results without  storing the dense matrix.","category":"section"},{"location":"tutorials/solving-a-power-flow/#AC-Power-Flow","page":"Solving a Power Flow","title":"AC Power Flow","text":"Create an ACPowerFlow solver:\n\npf_ac = ACPowerFlow()\n\nSolve the power flow:\n\nsolve_power_flow(pf_ac, sys)\n\nAC results are returned as a flat Dict{String, DataFrame}, with the same keys as  before: \"bus_results\", \"flow_results\" (AC lines), and \"lcc_results\" (HVDC lines).  (We don't support multi-period AC power flows yet.) Look at the bus results:\n\nac_results[\"bus_results\"]\n\nNotice that Vm now varies across buses (not all 1.0), and Q_gen has non-zero values.\n\nLook at the line flows:\n\nac_results[\"flow_results\"]\n\nQ_from_to and Q_to_from now show reactive power flows, and P_from_to differs from P_to_from due to losses.","category":"section"},{"location":"tutorials/solving-a-power-flow/#When-AC-Power-Flow-Fails","page":"Solving a Power Flow","title":"When AC Power Flow Fails","text":"Unlike DC power flow, AC power flow is iterative and not guaranteed to converge. Systems with high impedance lines, poor initial voltage profiles, or insufficient reactive power support can cause the solver to fail. When this happens, solve_power_flow returns missing: you'll also see a logged error. If you encounter convergence failures, consider  using a more robust solver such as TrustRegionACPowerFlow or RobustHomotopyPowerFlow.","category":"section"},{"location":"reference/developers/power_flow/#Power-Flow","page":"Power Flow","title":"Power Flow","text":"PowerFlows.jl provides the capability to run a power flow using the Newton-Raphson method, optionally enforcing reactive power constraints of generators. This power flow routine can be used to check for AC feasibility of results of DC optimal power flow.\n\nThe power flow solver uses KLU.jl for Jacobian matrix factorization. The solver uses the current operating point in the buses to provide the initial guess. The initial guess is then adjusted to contain voltage magnitudes within a feasible range of 0.8 p.u. - 1.2 p.u.\n\nLimitations: The PowerFlow solver doesn't support systems with HVDC lines or Phase Shifting transformers yet. The power flow solver can't handle systems with islands.\n\nusing PowerFlows\nusing PowerSystems\nusing PowerSystemCaseBuilder\n\nsystem_data = build_system(PSITestSystems, \"c_sys14\")\n\nPowerFlows.jl has two modes of using the power flow solver.\n\nSolving the power flow for the current operating point in the system. Takes the data in the buses, the active_power and reactive_power fields in the static injection devices. Returns a dictionary with results in a DataFrame that can be exported or manipulated as needed.\nSolves the power flow and updated the devices in the system to the operating condition. This model will update the values of magnitudes and angles in the system's buses. It also updates the active and reactive power flows in the branches and devices connected to PV buses. It also updates the active and reactive power of the injection devices connected to the Slack bus, and updates only the reactive power of the injection devices connected to PV buses. If multiple devices are connected to the same bus, the power is divided proportional to the base power. This utility is useful to initialize systems before serializing or checking the addition of new devices is still AC feasible.\n\nSolving the power flow with mode 1:\n\npf = ACPowerFlow()\nresults = solve_power_flow(pf, system_data)\nresults[\"bus_results\"]\n\nSolving the power flow with mode 2:\n\nBefore running the power flow command these are the values of the voltages:\n\nfor b in get_components(Bus, system_data)\n    println(\"$(get_name(b)) - Magnitude $(get_magnitude(b)) - Angle (rad) $(get_angle(b))\")\nend\n\nsolve_and_store_power_flow! return true or false to signal the successful result of the power flow. This enables the integration of a power flow into functions and use the return as check.\n\nsolve_and_store_power_flow!(pf, system_data; method = :newton)\n\nAfter running the power flow command this are the values of the voltages:\n\nfor b in get_components(Bus, system_data)\n    println(\"$(get_name(b)) - Magnitude $(get_magnitude(b)) - Angle (rad) $(get_angle(b))\")\nend","category":"section"},{"location":"#PowerFlows.jl","page":"Welcome Page","title":"PowerFlows.jl","text":"","category":"section"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"PowerFlows.jl is part of the National Laboratory of the Rockies' Sienna platform, an open source framework for scheduling problems and dynamic simulations for power systems. The Sienna platform can be found on github. The documentation is still in progress.","category":"section"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"The latest stable release of PowerFlows can be installed using the Julia package manager with\n\n] add PowerFlows\n\nFor the current development version, \"checkout\" this package with\n\n] add PowerFlows#main","category":"section"}]
}
