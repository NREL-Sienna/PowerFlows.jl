<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · PowerFlows.jl</title><meta name="title" content="Public API Reference · PowerFlows.jl"/><meta property="og:title" content="Public API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Public API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><a class="tocitem" href="../../../tutorials/stub/">Tutorials</a></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li class="is-active"><a class="tocitem" href>Public API Reference</a></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlows"><a class="docs-heading-anchor" href="#PowerFlows">PowerFlows</a><a id="PowerFlows-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlows" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.InertiaResult" href="#PowerFlows.InertiaResult"><code>PowerFlows.InertiaResult</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">InertiaResult</code></pre><p>Result of inertia computation containing eigenvalue signature.</p><p>Fields:</p><ul><li><code>n_positive::Int</code>: Number of positive eigenvalues</li><li><code>n_negative::Int</code>: Number of negative eigenvalues</li><li><code>n_zero::Int</code>: Number of zero eigenvalues (within tolerance)</li><li><code>is_indefinite::Bool</code>: True if both positive and negative eigenvalues exist</li><li><code>is_positive_definite::Bool</code>: True if all eigenvalues are positive</li><li><code>is_negative_definite::Bool</code>: True if all eigenvalues are negative</li><li><code>tolerance::Float64</code>: Tolerance used for zero eigenvalue detection</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L14-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PSSEExporter" href="#PowerFlows.PSSEExporter"><code>PowerFlows.PSSEExporter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structure to perform an export from a Sienna System, plus optional updates from <code>PowerFlowData</code>, to the PSS/E format. Construct from a <code>System</code> and a PSS/E version, update using <code>update_exporter</code> with any new data as relevant, and perform the export with <code>write_export</code>. Writes a <code>&lt;name&gt;.raw</code> file and a <code>&lt;name&gt;_export_metadata.json</code> file with transformations that had to be made to conform to PSS/E naming rules, which can be parsed by PowerSystems.jl to perform a round trip with the names restored.</p><p><strong>Arguments:</strong></p><ul><li><code>base_system::PSY.System</code>: the system to be exported. Later updates may change power flow-related values but may not fundamentally alter the system</li><li><code>psse_version::Symbol</code>: the version of PSS/E to target, must be one of <code>PSSE_EXPORT_SUPPORTED_VERSIONS</code></li><li><code>write_comments::Bool</code> = false: whether to add the customary-but-not-in-spec-annotations after a slash on the first line and at group boundaries</li><li><code>name::AbstractString = &quot;export&quot;</code>: the base name of the export</li><li><code>step::Any = nothing</code>: optional step data to append to the base export name. User is responsible for updating the step data. If the step data is <code>nothing</code>, it is not used; if it is a tuple or vector, it is joined with &#39;<em>&#39; and concatted; else it is concatted after &#39;</em>&#39;.</li><li><code>overwrite::Bool = false</code>: <code>true</code> to silently overwrite existing exports, <code>false</code> to throw an error if existing results are encountered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/psse_export.jl#L94-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PowerFlowData" href="#PowerFlows.PowerFlowData"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Structure containing all the data required for the evaluation of the power flows and angles, as well as these ones.</p><p>In the below descriptions, &quot;number of buses&quot; should be understood as &quot;number of buses remaining, after the network reduction.&quot; Similarly, we use &quot;arcs&quot; instead of &quot;branches&quot; to distinguish  between network elements (post-reduction) and system objects (pre-reduction).</p><p><strong>Arguments:</strong></p><ul><li><code>bus_activepower_injection::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus active power injection. b: number of       buses, t: number of time period.</li><li><code>bus_reactivepower_injection::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus reactive power injection. b: number       of buses, t: number of time period.</li><li><code>bus_activepower_withdrawals::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus reactive power withdrawals. b:       number of buses, t: number of time period.</li><li><code>bus_reactivepower_withdrawals::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus reactive power withdrawals. b:       number of buses, t: number of time period.</li><li><code>bus_activepower_constant_current_withdrawals::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus active power constant current       withdrawals. b: number of buses, t: number of time period.</li><li><code>bus_reactivepower_constant_current_withdrawals::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus reactive power constant current       withdrawals. b: number of buses, t: number of time period.</li><li><code>bus_activepower_constant_impedance_withdrawals::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus active power constant impedance       withdrawals. b: number of buses, t: number of time period.</li><li><code>bus_reactivepower_constant_impedance_withdrawals::Matrix{Float64}</code>:         &quot;(b, t)&quot; matrix containing the bus reactive power constant impedance       withdrawals. b: number of buses, t: number of time period.</li><li><code>bus_reactivepower_bounds::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing upper and lower bounds for the reactive supply at each       bus at each time period.</li><li><code>bus_type::Matrix{PSY.ACBusTypes}</code>:       &quot;(b, t)&quot; matrix containing type of buses present in the system, ordered       according to &quot;bus_lookup,&quot; at each time period.</li><li><code>bus_magnitude::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus magnitudes, ordered according to       &quot;bus_lookup&quot;. b: number of buses, t: number of time period.</li><li><code>bus_angles::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the bus angles, ordered according to       &quot;bus_lookup&quot;. b: number of buses, t: number of time period.</li><li><code>arc_activepower_flow_from_to::Matrix{Float64}</code>:       &quot;(br, t)&quot; matrix containing the active power flows measured at the <code>from</code> bus,       ordered according to &quot;arc_lookup&quot;. br: number of arcs, t: number of time       period.</li><li><code>arc_reactivepower_flow_from_to::Matrix{Float64}</code>:       &quot;(br, t)&quot; matrix containing the reactive power flows measured at the <code>from</code> bus,       ordered according to &quot;arc_lookup&quot;. br: number of arcs, t: number of time       period.</li><li><code>arc_activepower_flow_to_from::Matrix{Float64}</code>:       &quot;(br, t)&quot; matrix containing the active power flows measured at the <code>to</code> bus, ordered       according to &quot;arc_lookup&quot;. br: number of arcs, t: number of time period.</li><li><code>arc_reactivepower_flow_to_from::Matrix{Float64}</code>:       &quot;(br, t)&quot; matrix containing the reactive power flows measured at the <code>to</code> bus,       ordered according to &quot;arc_lookup&quot;. br: number of arcs, t: number of time       period.</li><li><code>timestep_map::Dict{Int, S}</code>:       dictionary mapping the number of the time periods (corresponding to the       column number of the previously mentioned matrices) and their names.</li><li><code>power_network_matrix::M</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>aux_network_matrix::N</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>neighbors::Vector{Set{Int}}</code>: Vector with the sets of adjacent buses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/PowerFlowData.jl#L18-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}" href="#PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Function for the definition of the PowerFlowData structure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for AC power flow computations.</p><p><strong>Arguments:</strong></p><ul><li><code>::ACPowerFlow</code>:       use ACPowerFlow() to evaluate the AC PF.</li><li><code>sys::PSY.System</code>:       container storing the system data to consider in the PowerFlowData       structure.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defines by the argument &quot;time_steps&quot;. Default       value = String[].</li></ul><p>WARNING: functions for the evaluation of the multi-period AC PF still to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/PowerFlowData.jl#L414-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}" href="#PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Function for the definition of the PowerFlowData structure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for DC power flow computations.</p><p><strong>Arguments:</strong></p><ul><li><code>::DCPowerFlow</code>:       use DCPowerFlow() to store the ABA matrix as power<em>network</em>matrix and       the BA matrix as aux<em>network</em>matrix.</li><li><code>sys::PSY.System</code>:       container storing the system data to consider in the PowerFlowData       structure.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defines by the argument &quot;time_steps&quot;. Default       value = String[].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/PowerFlowData.jl#L472-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}" href="#PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Function for the definition of the PowerFlowData structure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for DC power flow computations.</p><p><strong>Arguments:</strong></p><ul><li><code>::PTDFDCPowerFlow</code>:       use vPTDFDCPowerFlow() to store the Virtual PTDF matrix as       power<em>network</em>matrix and the ABA matrix as aux<em>network</em>matrix.</li><li><code>sys::PSY.System</code>:       container storing the system data to consider in the PowerFlowData       structure.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defines by the argument &quot;time_steps&quot;. Default       value = String[].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/PowerFlowData.jl#L565-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64}} where {T&lt;:PowerFlows.PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}" href="#PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64}} where {T&lt;:PowerFlows.PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sets the two <code>PowerNetworkMatrix</code> fields and a few others (<code>timesteps</code>, <code>timestep_map</code>),  then creates arrays of default values (usually zeros) for the rest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/PowerFlowData.jl#L262-L265">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.check_jacobian_symmetric_part-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.check_jacobian_symmetric_part-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.check_jacobian_symmetric_part</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_jacobian_symmetric_part(J::SparseMatrixCSC{Float64,Int32};
                              tolerance::Float64=1e-14) -&gt; InertiaResult</code></pre><p>Analyze the symmetric part of a non-symmetric Jacobian matrix.</p><p>For a non-symmetric Jacobian J, this function computes the inertia of the symmetric part: (J + J^T) / 2. This provides insight into the &quot;symmetrized&quot; eigenvalue spectrum, which can be useful for understanding the local behavior near the solution.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse Jacobian matrix</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>InertiaResult</code>: Inertia of the symmetric part</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L181-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.compute_inertia_via_sparse_lu-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.compute_inertia_via_sparse_lu-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.compute_inertia_via_sparse_lu</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_inertia_via_sparse_lu(J::SparseMatrixCSC{Float64,Int32};
                               tolerance::Float64=1e-14) -&gt; InertiaResult</code></pre><p>Compute the inertia (eigenvalue signature) of a sparse matrix using sparse LU factorization.</p><p>This method exploits sparsity by leveraging the KLU sparse factorization. The inertia is estimated from the signs of pivot elements in the LU decomposition. This approach is much faster than dense eigenvalue computation, especially for large sparse matrices.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse Jacobian matrix</li><li><code>tolerance::Float64</code>: Tolerance for determining zero eigenvalues (default: 1e-14)</li></ul><p><strong>Returns</strong></p><ul><li><code>InertiaResult</code>: Structure containing inertia information and definiteness status</li></ul><p><strong>Theoretical Background</strong></p><p>The Sylvester&#39;s law of inertia states that the inertia of a matrix is preserved under congruence transformations. The LU factorization provides an approximate inertia by:</p><ol><li>Counting positive pivots (relate to positive eigenvalues)</li><li>Counting negative pivots (relate to negative eigenvalues)</li><li>Detecting small/zero pivots (relate to near-zero eigenvalues)</li></ol><p>Note: This is an approximation for non-symmetric matrices. For the power flow Jacobian (non-symmetric), we examine both the pure factorization and the symmetric part.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">inertia = compute_inertia_via_sparse_lu(J)
if inertia.is_indefinite
    @warn &quot;Jacobian is indefinite - Newton-Raphson may have convergence issues&quot;
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L48-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.get_inertia_report-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.get_inertia_report-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.get_inertia_report</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_inertia_report(J::SparseMatrixCSC{Float64,Int32};
                  tolerance::Float64=1e-14) -&gt; String</code></pre><p>Generate a detailed text report of matrix inertia properties.</p><p>Useful for debugging and understanding Jacobian behavior during solver iterations.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse matrix</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: Formatted report of inertia properties</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L237-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.get_psse_export_paths-Tuple{AbstractString}" href="#PowerFlows.get_psse_export_paths-Tuple{AbstractString}"><code>PowerFlows.get_psse_export_paths</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculate the paths of the (raw, metadata) files that would be written by a certain call to <code>write_export</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/psse_export.jl#L2799">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.is_jacobian_indefinite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.is_jacobian_indefinite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.is_jacobian_indefinite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_jacobian_indefinite(J::SparseMatrixCSC{Float64,Int32};
                      tolerance::Float64=1e-14) -&gt; Bool</code></pre><p>Quick check to determine if a Jacobian matrix is indefinite.</p><p>Returns <code>true</code> if the matrix has both positive and negative eigenvalues, indicating indefiniteness. This is a fast check that exploits sparsity via LU factorization.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse Jacobian matrix</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if indefinite, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L117-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.is_negative_definite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.is_negative_definite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.is_negative_definite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_negative_definite(J::SparseMatrixCSC{Float64,Int32};
                    tolerance::Float64=1e-14) -&gt; Bool</code></pre><p>Check if a sparse matrix is negative definite.</p><p>A matrix is negative definite if all its eigenvalues are negative.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse matrix</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if negative definite, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L160-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.is_positive_definite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}" href="#PowerFlows.is_positive_definite-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}}"><code>PowerFlows.is_positive_definite</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_positive_definite(J::SparseMatrixCSC{Float64,Int32};
                    tolerance::Float64=1e-14) -&gt; Bool</code></pre><p>Check if a sparse matrix is positive definite.</p><p>A matrix is positive definite if all its eigenvalues are positive.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64,Int32}</code>: Sparse matrix</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if positive definite, <code>false</code> otherwise</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L139-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.monitor_jacobian_definiteness-Tuple{PowerFlows.ACPowerFlowJacobian}" href="#PowerFlows.monitor_jacobian_definiteness-Tuple{PowerFlows.ACPowerFlowJacobian}"><code>PowerFlows.monitor_jacobian_definiteness</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">monitor_jacobian_definiteness(jacobian::ACPowerFlowJacobian;
                             verbose::Bool=true) -&gt; InertiaResult</code></pre><p>Monitor and report the definiteness properties of a Jacobian during solving.</p><p>This function provides detailed feedback useful during Newton-Raphson iterations for diagnosing convergence issues related to Jacobian conditioning.</p><p><strong>Arguments</strong></p><ul><li><code>jacobian::ACPowerFlowJacobian</code>: Power flow Jacobian object</li><li><code>verbose::Bool</code>: If true, print detailed report</li></ul><p><strong>Returns</strong></p><ul><li><code>InertiaResult</code>: Full inertia information</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L291-L306">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.quick_indefiniteness_check-Tuple{PowerFlows.ACPowerFlowJacobian}" href="#PowerFlows.quick_indefiniteness_check-Tuple{PowerFlows.ACPowerFlowJacobian}"><code>PowerFlows.quick_indefiniteness_check</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quick_indefiniteness_check(jacobian::ACPowerFlowJacobian;
                          tolerance::Float64=1e-14) -&gt; Bool</code></pre><p>Convenience function for quick indefiniteness check on ACPowerFlowJacobian objects.</p><p>This function provides a fast check directly on the ACPowerFlowJacobian structure used in PowerFlows.jl, extracting the sparse matrix and checking indefiniteness.</p><p><strong>Arguments</strong></p><ul><li><code>jacobian::ACPowerFlowJacobian</code>: Power flow Jacobian object</li><li><code>tolerance::Float64</code>: Tolerance for zero eigenvalue detection</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: <code>true</code> if indefinite, <code>false</code> otherwise</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">jacobian = ACPowerFlowJacobian(data, time_step)
if quick_indefiniteness_check(jacobian)
    @warn &quot;Jacobian is indefinite at this iteration&quot;
    # Consider alternative solver or regularization
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/jacobian_indefiniteness_detection.jl#L207-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow!-Tuple{ACPowerFlow, System}" href="#PowerFlows.solve_powerflow!-Tuple{ACPowerFlow, System}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_powerflow!(pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}, system::PSY.System; kwargs...)</code></pre><p>Solves the power flow in the system and writes the solution into the relevant structs. Updates active and reactive power setpoints for generators and active and reactive power flows for branches (calculated in the From - To direction and in the To - From direction).</p><p>Supports passing kwargs to the PF solver.</p><p>The bus types can be changed from PV to PQ if the reactive power limits are violated.</p><p><strong>Arguments</strong></p><ul><li><code>pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}</code>: The power flow solver instance, can be <code>NewtonRaphsonACPowerFlow</code> or <code>LUACPowerFlow</code> (to be used for testing only).</li><li><code>system::PSY.System</code>: The power system model.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>&#39;check<em>reactive</em>power_limits&#39;: if <code>true</code>, the reactive power limits are enforced by changing the respective bus types from PV to PQ. Default is <code>false</code>.</li><li><code>tol</code>: Infinite norm of residuals under which convergence is declared. Default is <code>1e-9</code>.</li><li><code>maxIterations</code>: Maximum number of Newton-Raphson iterations. Default is <code>30</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>converged::Bool</code>: Indicates whether the power flow solution converged.</li><li>The power flow results are written into the system struct.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">solve_powerflow!(pf, sys)

# Passing kwargs
solve_powerflow!(pf, sys; correct_bustypes = true)

# Passing keyword arguments
solve_powerflow!(pf, sys; maxIterations=100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_ac_powerflow.jl#L1-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}" href="#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluates the power flows on each system&#39;s branch and updates the PowerFlowData structure.</p><p><strong>Arguments:</strong></p><ul><li><code>data::PTDFPowerFlowData</code>:       PTDFPowerFlowData structure containing all the information related to the system&#39;s power flow.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_dc_powerflow.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}" href="#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluates the power flows on each system&#39;s branch and updates the PowerFlowData structure.</p><p><strong>Arguments:</strong></p><ul><li><code>data::vPTDFPowerFlowData</code>:       vPTDFPowerFlowData structure containing all the information related to the system&#39;s power flow.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_dc_powerflow.jl#L28-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, &lt;:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}}" href="#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, &lt;:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">solve_powerflow!(data::ACPowerFlowData; pf::ACPowerFlow{&lt;:ACPowerFlowSolverType} = ACPowerFlow(), kwargs...)</code></pre><p>Solve the multiperiod AC power flow problem for the given power flow data.</p><p>The bus types can be changed from PV to PQ if the reactive power limits are violated.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data containing the grid information and initial conditions.</li><li><code>pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}</code>: The power flow solver type. Defaults to <code>NewtonRaphsonACPowerFlow</code>.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li>&#39;check<em>reactive</em>power_limits&#39;: if <code>true</code>, the reactive power limits are enforced by changing the respective bus types from PV to PQ. Default is <code>false</code>.</li><li><code>time_steps</code>: Specifies the time steps to solve. Defaults to sorting and collecting the keys of <code>data.timestep_map</code>.</li></ul><p><strong>Description</strong></p><p>This function solves the AC power flow problem for each time step specified in <code>data</code>.  It preallocates memory for the results and iterates over the sorted time steps.      For each time step, it calls the <code>_ac_powerflow</code> function to solve the power flow equations and updates the <code>data</code> object with the results.      If the power flow converges, it updates the active and reactive power injections, as well as the voltage magnitudes and angles for different bus types (REF, PV, PQ).      If the power flow does not converge, it sets the corresponding entries in <code>data</code> to <code>NaN</code>.      Finally, it calculates the branch power flows and updates the <code>data</code> object.</p><p><strong>Notes</strong></p><ul><li>If the grid topology changes (e.g., tap positions of transformers or in-service status of branches), the admittance matrices <code>Yft</code> and <code>Ytf</code> must be updated.</li><li>If <code>Yft</code> and <code>Ytf</code> change between time steps, the branch flow calculations must be moved inside the loop.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">solve_powerflow!(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_ac_powerflow.jl#L112-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow-Tuple{ACPowerFlow, System}" href="#PowerFlows.solve_powerflow-Tuple{ACPowerFlow, System}"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Similar to solve_powerflow!(pf, sys) but does not update the system struct with results. Returns the results in a dictionary of dataframes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">res = solve_powerflow(pf, sys)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_ac_powerflow.jl#L71-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow-Tuple{Union{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}}}, PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}, System}" href="#PowerFlows.solve_powerflow-Tuple{Union{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}}}, PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}, System}"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluates the power flows on the system&#39;s branches by means of the method associated with the <code>PowerFlowData</code> structure <code>data</code>, which can be one of <code>PTDFPowerFlowData</code>, <code>vPTDFPowerFlowData</code>, or <code>ABAPowerFlowData</code>. Returns a dictionary of <code>DataFrame</code>s, each containing the branch flows and bus voltages for the input <code>PSY.System</code> at that timestep.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}</code>:       <code>PowerFlowData</code> structure containing the system&#39;s data per each timestep       considered, as well as the associated matrix for the power flow.</li><li><code>sys::PSY.System</code>:       container gathering the system data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_dc_powerflow.jl#L108-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_powerflow-Union{Tuple{T}, Tuple{T, System}} where T&lt;:PowerFlows.AbstractDCPowerFlow" href="#PowerFlows.solve_powerflow-Union{Tuple{T}, Tuple{T, System}} where T&lt;:PowerFlows.AbstractDCPowerFlow"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Evaluates the power flows on the system&#39;s branches by means of the PTDF, virtual PTDF, or DC power flow method: the type first parameter (a <code>PTDFDCPowerFlow</code>, <code>vPTDFDCPowerFlow</code>,  or <code>DCPowerFlow</code>) selects the method to be used. Returns a dictionary containing a  <code>DataFrame</code> for the single timestep considered, storing the branch flows and bus  voltages for the input <code>PSY.System</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>::Union{PTDFDCPowerFlow, vPTDFDCPowerFlow, DCPowerFlow}</code>:       the method of power flow evaluation to be used.</li><li><code>sys::PSY.System</code>:       container gathering the system data used for the evaluation of flows       and angles.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/solve_dc_powerflow.jl#L82-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlowData}" href="#PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlowData}"><code>PowerFlows.update_exporter!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the <code>PSSEExporter</code> with new <code>data</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>exporter::PSSEExporter</code>: the exporter to update</li><li><code>data::PSY.PowerFlowData</code>: the new data. Must correspond to the <code>System</code> with which the exporter was constructor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/psse_export.jl#L185-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.update_exporter!-Tuple{PSSEExporter, System}" href="#PowerFlows.update_exporter!-Tuple{PSSEExporter, System}"><code>PowerFlows.update_exporter!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Update the <code>PSSEExporter</code> with new <code>data</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>exporter::PSSEExporter</code>: the exporter to update</li><li><code>data::PSY.System</code>: system containing the new data. Must be fundamentally the same</li></ul><p><code>System</code> as the one with which the exporter was constructed, just with different values —   this is the user&#39;s responsibility, we do not exhaustively verify it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/psse_export.jl#L206-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}" href="#PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}"><code>PowerFlows.write_export</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Perform an export from the data contained in a <code>PSSEExporter</code> to the PSS/E file format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/psse_export.jl#L2710">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, &lt;:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}" href="#PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, &lt;:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns a dictionary containing the AC power flow results.</p><p>Only single-period evaluation is supported at the moment for AC Power flows. Resulting dictionary will therefore feature just one key linked to one DataFrame.</p><p><strong>Arguments:</strong></p><ul><li><code>::ACPowerFlow</code>:       use ACPowerFlow() storing AC power flow results.</li><li><code>sys::PSY.System</code>:       container storing the system information.</li><li><code>result::Vector{Float64}</code>:       vector containing the results for one single time-period.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/post_processing.jl#L731-L744">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_results-Tuple{Union{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}}}, PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}, System}" href="#PowerFlows.write_results-Tuple{Union{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}}}, PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{Tuple{Int64, Int64}}}, Tuple{Dict{Int64, Int64}, Dict{Tuple{Int64, Int64}, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{Tuple{Int64, Int64}}, Vector{Int64}}, Tuple{Dict{Tuple{Int64, Int64}, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}, System}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Returns a dictionary containing the DC power flow results. Each key corresponds to the name of the considered time periods, storing a DataFrame with the PF results.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}</code>:       PowerFlowData structure containing power flows and bus angles.</li><li><code>sys::PSY.System</code>:       container storing the system information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/1c1e0d53fd642406be0c5301667d359641b7d470/src/post_processing.jl#L674-L684">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../developers/developer/">« Code Base Developer Guide</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Sunday 9 November 2025 23:54">Sunday 9 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
