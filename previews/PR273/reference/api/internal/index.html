<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Reference · PowerFlows.jl</title><meta name="title" content="Internal API Reference · PowerFlows.jl"/><meta property="og:title" content="Internal API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Internal API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><a class="tocitem" href="../../../tutorials/stub/">Tutorials</a></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li><a class="tocitem" href="../public/">Public API Reference</a></li><li class="is-active"><a class="tocitem" href>Internal API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Internal API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowJacobian</code></pre><p>A struct that represents the Jacobian matrix for AC power flow calculations.</p><p>This struct uses the functor pattern, meaning instances of <code>ACPowerFlowJacobian</code> store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data used for power flow calculations.</li><li><code>Jf!::Function</code>: A function that calculates the Jacobian matrix inplace.</li><li><code>Jv::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix, which is updated by the function <code>Jf!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(time_step::Int64)</code></pre><p>Update the Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step.</p><p>Defining this method allows an instance of <code>ACPowerFlowJacobian</code> to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
J(time_step)  # Updates the Jacobian matrix Jv</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L22-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -&gt; ACPowerFlowJacobian</code></pre><p>This is the constructor for ACPowerFlowJacobian. Create an <code>ACPowerFlowJacobian</code> instance. As soon as the instance is created, it already has the Jacobian matrix structure initialized and its values updated, stored internally as Jv. The data instance is stored internally and used to update the Jacobian matrix because the structure of the Jacobian matrix is tied to the data. Changing the data requires creating a new instance of <code>ACPowerFlowJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data used for power flow calculations.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowJacobian</code>: An instance of <code>ACPowerFlowJacobian</code>.</li></ul><p>#Example</p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.
J(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.
J.Jv  # Access the Jacobian matrix stored internally in J.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L72-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)</code></pre><p>Use the <code>ACPowerFlowJacobian</code> to update the provided Jacobian matrix <code>J</code> inplace.</p><p>Update the internally stored Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step, and write the updated Jacobian values to <code>J</code>.</p><p>This method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>`: A sparse matrix to be updated with new values of the Jacobian matrix.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
Jv = SparseArrays.sparse(Float64[], Int32[], Int32[])
J(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L43-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowResidual</code></pre><p>A struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data.</li><li><code>Rf!::Function</code>: A function that updates the residuals based on the latest values stored in the grid at the given iteration.</li><li><code>Rv::Vector{Float64}</code>: A vector of the values of the residuals.</li><li><code>P_net::Vector{Float64}</code>: A vector of net active power injections.</li><li><code>Q_net::Vector{Float64}</code>: A vector of net reactive power injections.</li><li><code>P_net_set::Vector{Float64}</code>: A vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: A sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>subnetworks::Dict{Int64, Vector{Int64}}</code>: The dictionary that identifies subnetworks (connected components), with the key defining the REF bus, values defining the corresponding buses in the subnetwork.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_residual.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)</code></pre><p>Create an instance of <code>ACPowerFlowResidual</code> for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data representing the power system model.</li><li><code>time_step::Int64</code>: The time step for which the power flow calculation is executed.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowResidual</code>: An instance containing the residual values, net bus active power injections,</li></ul><p>and net bus reactive power injections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_residual.jl#L27-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)</code></pre><p>Update the AC power flow residuals inplace and store the result in the attribute <code>Rv</code> of the struct. The inputs are the values of state vector <code>x</code> and the current time step <code>time_step</code>. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The state vector values.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_residual.jl#L146-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)</code></pre><p>Evaluate the AC power flow residuals and store the result in <code>Rv</code> using the provided state vector <code>x</code> and the current time step <code>time_step</code>. The residuals are updated inplace in the struct and additionally copied to the provided array. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>Rv::Vector{Float64}</code>: The vector to store the calculated residuals.</li><li><code>x::Vector{Float64}</code>: The state vector.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_residual.jl#L111-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.FixedStructureCHOLMOD"><a class="docstring-binding" href="#PowerFlows.FixedStructureCHOLMOD"><code>PowerFlows.FixedStructureCHOLMOD</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>In order to in-place modify the numeric values of a CHOLMOD matrix, we need to  write our own wrapper around <code>CHOLMOD.Sparse</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/RobustHomotopy/HessianSolver/fixed_structure_CHOLMOD.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><a class="docstring-binding" href="#PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><code>PowerFlows.HomotopyHessian</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute value of gradient and Hessian at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/RobustHomotopy/homotopy_hessian.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.KLULinSolveCache"><a class="docstring-binding" href="#PowerFlows.KLULinSolveCache"><code>PowerFlows.KLULinSolveCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A cached linear solver using KLU. Carefully written so as to minimize allocations: solve! and numeric_refactor! are completely non-allocating.</p><p><strong>Fields:</strong></p><ul><li><code>K</code>: the underlying KLU object.</li><li><code>reuse_symbolic::Bool</code>: reuse the symbolic factorization. Defaults to true.</li><li><code>check_pattern::Bool</code>: if true, <code>numeric_refactor!</code> verifies that the new</li></ul><p>matrix has the same sparsity structure. Defaults to true. -<code>rf_common</code>, <code>rf_symbolic</code>, <code>rf_numeric</code>: internal usage. Stored to avoid allocations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/klu_linear_solver.jl#L25-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.KLULinSolveCache</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/klu_linear_solver.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.LinearSolverCache"><a class="docstring-binding" href="#PowerFlows.LinearSolverCache"><code>PowerFlows.LinearSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract supertype for all cached linear solvers. Subtypes must implement: <code>symbolic_factor!</code>, <code>symbolic_refactor!</code>, <code>numeric_refactor!</code> (which doubles as <code>numeric_factor!</code>), and <code>solve!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/linear_solver_cache.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.StateVectorCache"><a class="docstring-binding" href="#PowerFlows.StateVectorCache"><code>PowerFlows.StateVectorCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Cache for non-linear methods</p><p><strong>Fields</strong></p><p>-<code>x::Vector{Float64}</code>: the current state vector. -<code>r::Vector{Float64}</code>: the current residual. -<code>Δx_nr::Vector{Float64}</code>: the step under the Newton-Raphson method. The remainder of the fields are only used in the <code>TrustRegionACPowerFlow</code>: -<code>r_predict::Vector{Float64}</code>: the predicted residual at <code>x+Δx_proposed</code>,     under a linear approximation: i.e <code>J_x⋅(x+Δx_proposed)</code>. -<code>Δx_proposed::Vector{Float64}</code>: the suggested step <code>Δx</code>, selected among <code>Δx_nr</code>,      <code>Δx_cauchy</code>, and the dogleg interpolation between the two. The first is chosen when     <code>x+Δx_nr</code> is inside the trust region, the second when both <code>x+Δx_cauchy</code>     and <code>x+Δx_nr</code> are outside the trust region, and the third when <code>x+Δx_cauchy</code>     is inside and <code>x+Δx_nr</code> outside. The dogleg step selects the point where the line     from <code>x+Δx_cauchy</code> to <code>x+Δx_nr</code> crosses the boundary of the trust region. -<code>Δx_cauchy::Vector{Float64}</code>: the step to the Cauchy point if the Cauchy point     lies within the trust region, otherwise a step in that direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L1-L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.SystemPowerFlowContainer"><a class="docstring-binding" href="#PowerFlows.SystemPowerFlowContainer"><code>PowerFlows.SystemPowerFlowContainer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A <code>PowerFlowContainer</code> that represents its data as a <code>PSY.System</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/PowerFlowData.jl#L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>PowerFlows.A_plus_eq_BT_B!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does <code>A += B&#39; * B</code>, in a way that preserves the sparse structure of <code>A</code>, if possible. A workaround for the fact that Julia seems to run <code>dropzeros!(A)</code> automatically if I just  do <code>A .+= B&#39; * B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/RobustHomotopy/homotopy_hessian.jl#L11-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dV_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dV_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to voltage magnitude Vm for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dt_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dt_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to transformer tap t for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><code>PowerFlows._calculate_dQ_dα_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dα_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64, α::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to firing/extinction angle α for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L57-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlowData, Int64}"><code>PowerFlows._calculate_fixed_admittance_powers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a dictionary of bus index to power contribution at that bus from FixedAdmittance components, as a tuple of (active power, reactive power).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L7-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_loss_factors-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_loss_factors-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows._calculate_loss_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)</code></pre><p>Calculate and store the active power loss factors in the <code>loss_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step.</p><p>The loss factors are computed using the Jacobian matrix <code>Jv</code> and the vector <code>dSbus_dV_ref</code>, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injection as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data structure containing power flow information, including the <code>loss_factors</code> matrix.</li><li><code>Jv::SparseMatrixCSC{Float64, Int32}</code>: The sparse Jacobian matrix of the power flow system.</li><li><code>time_step::Int</code>: The time step index for which the loss factors are calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L621-L635">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_voltage_stability_factors-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._calculate_voltage_stability_factors-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._calculate_voltage_stability_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_voltage_stability_factors(data::ACPowerFlowData, J::ACPowerFlowJacobian, time_step::Integer)</code></pre><p>Calculate and store the voltage stability factors in the <code>voltage_stability_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step. The voltage stability factors are computed using the Jacobian matrix <code>J</code> in block format after a converged power flow calculation.  The results are stored in the <code>voltage_stability_factors</code> matrix in the <code>data</code> instance. The factor for the grid as a whole (σ) is stored in the position of the REF bus. The values of the singular vector <code>v</code> indicate the sensitivity of the buses and are stored in the positions of the PQ buses. The values of <code>v</code> for PV buses are set to zero.  The function uses the method described in the following publication:</p><pre><code class="language-julia hljs">P.-A. Lof, T. Smed, G. Andersson, and D. J. Hill, &quot;Fast calculation of a voltage stability index,&quot; in IEEE Transactions on Power Systems, vol. 7, no. 1, pp. 54-64, Feb. 1992, doi: 10.1109/59.141687.</code></pre><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The instance containing the grid model data.</li><li><code>J::ACPowerFlowJacobian</code>: The Jacobian matrix cache.</li><li><code>time_step::Integer</code>: The calculated time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L660-L677">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><code>PowerFlows._calculate_y_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_y_lcc(t::Float64, I_dc::Float64, Vm::Float64, ϕ::Float64) -&gt; ComplexF64</code></pre><p>Compute the admittance value Y for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_ϕ_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_ϕ_lcc(α::Float64, I_dc::Float64, x_t::Float64, Vm::Float64) -&gt; Float64</code></pre><p>Compute the phase angle ϕ for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -&gt; SparseMatrixCSC{Float64, Int32}</code></pre><p>Create the structure of the Jacobian matrix for an AC power flow problem. Inputs are the grid model as an instance of <code>ACPowerFlowData</code> at a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow model.</li><li><code>time_step::Int64</code>: The specific time step for which the Jacobian matrix structure is created.</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.</li></ul><p><strong>Description</strong></p><p>This function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.</p><p>Unlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus. See the example below for details.</p><p>This approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.</p><p>The function initializes three arrays (<code>rows</code>, <code>columns</code>, and <code>values</code>) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.</p><p>For each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (<code>REF</code>, <code>PV</code>, or <code>PQ</code>).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.</p><ul><li>For <code>REF</code> buses, entries are added for local active and reactive power.</li><li>For <code>PV</code> buses, entries are added for active and reactive power with respect to angle, and for local reactive power.</li><li>For <code>PQ</code> buses, entries are added for active and reactive power with respect to voltage magnitude and angle.</li></ul><p>For example, suppose we have a system with 3 buses: bus 1 is <code>REF</code>, bus 2 is <code>PV</code>, and bus 3 is <code>PQ</code>. Let ΔPⱼ, ΔQⱼ be the active, reactive power balance at the <code>j</code>th bus. Let Pⱼ and Qⱼ be the active and reactive power generated at the <code>j</code>th bus (<code>REF</code> and <code>PV</code> only). Then the state vector is [P₁, Q₁, Q₂, θ₂, V₃, θ₃], and the Jacobian matrix is</p><p>| ∂ΔP₁/∂P₁ | ∂ΔP₁/∂Q₁ | ∂ΔP₁/∂Q₂ | ∂ΔP₁/∂θ₂ | ∂ΔP₁/∂V₃ | ∂ΔP₁/∂θ₃ |   | ∂ΔQ₁/∂P₁ | ∂ΔQ₁/∂Q₁ | ∂ΔQ₁/∂Q₂ | ∂ΔQ₁/∂θ₂ | ∂ΔQ₁/∂V₃ | ∂ΔQ₁/∂θ₃ | | ∂ΔP₂/∂P₁ | ∂ΔP₂/∂Q₁ | ∂ΔP₂/∂Q₂ | ∂ΔP₂/∂θ₂ | ∂ΔP₂/∂V₃ | ∂ΔP₂/∂θ₃ | | ∂ΔQ₂/∂P₁ | ∂ΔQ₂/∂Q₁ | ∂ΔQ₂/∂Q₂ | ∂ΔQ₂/∂θ₂ | ∂ΔQ₂/∂V₃ | ∂ΔQ₂/∂θ₃ | | ∂ΔP₃/∂P₁ | ∂ΔP₃/∂Q₁ | ∂ΔP₃/∂Q₂ | ∂ΔP₃/∂θ₂ | ∂ΔP₃/∂V₃ | ∂ΔP₃/∂θ₃ | | ∂ΔQ₃/∂P₁ | ∂ΔQ₃/∂Q₁ | ∂ΔQ₃/∂Q₂ | ∂ΔQ₃/∂θ₂ | ∂ΔQ₃/∂V₃ | ∂ΔQ₃/∂θ₃ |</p><p>In reality, for large networks, this matrix would be sparse, and each 2x2 block would only be nonzero when there&#39;s a line between the respective buses.</p><p>Finally, the function constructs a sparse matrix from the collected indices and values and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L277-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PV bus. Ignoring this because we fill all four values even for PV buses with      structural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L135-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a reference bus (REF). Ignoring this because we fill all four values even for PV buses with      structural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L108-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn&#39;t matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -&gt; PQ transition and then we need to fill all four values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L166-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure_lcc(data::ACPowerFlowData, rows::Vector{Int32},
columns::Vector{Int32},
values::Vector{Float64},
num_buses::Int)

Create the Jacobian matrix structure for LCC HVDC.

The function iterates over each LCC and adds the non-zero entries to the Jacobian matrix structure.
The state vector for every LCC contains 4 variables (tap and angle for both rectifier and inverter).
The indices of non-zero entries correspond to the positions of these variables in the state vector.

For example, suppose we have a system with 2 buses connected by one LCC:
- Bus 1 is connected to the rectifier side,
- Bus 2 is connected to the inverter side.

The Jacobian matrix structure entries correspond to partial derivatives of the mismatch equations
with respect to these state variables.

The Jacobian matrix would have non-zero entries at positions like:

|           | V₁         | δ₁ | V₂         | δ₂ | t₁         | t₂         | a₁         | a₂         |
|-----------|------------|----|------------|----|------------|------------|------------|------------|
| P₁        | ∂P₁/∂V₁    |    |            |    | ∂P₁/∂t₁    |            | ∂P₁/∂a₁    |            |
| Q₁        | ∂Q₁/∂V₁    |    |            |    | ∂Q₁/∂t₁    |            | ∂Q₁/∂a₁    |            |
| P₂        |            |    |            |    |            |            |            |            |
| Q₂        |            |    |            |    |            |            |            |            |
| Fₜ₁       | ∂Fₜ₁/∂V₁    |    |            |    | ∂Fₜ₁/∂t₁    |            | ∂Fₜ₁/∂a₁   |            |
| Fₜ₂       | ∂Fₜ₂/∂V₁    |    | ∂Fₜ₂/∂V₂    |    | ∂Fₜ₂/∂t₁   | ∂Fₜ₂/∂t₂    | ∂Fₜ₂/∂a₁   | ∂Fₜ₂/∂a₂    |
| Fₐ₁       |            |    |            |    |            |            | ∂Fₐ₁/∂a₁   |            |
| Fₐ₂       |            |    |            |    |            |            |            | ∂Fₐ₂/∂a₂   |

This function sets up the indices of these non-zero entries in the sparse Jacobian matrix.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L201-L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._dc_powerflow_fallback!-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._dc_powerflow_fallback!-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows._dc_powerflow_fallback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>When solving AC power flows, if the initial guess has large residual, we run a DC power  flow as a fallback. This runs a DC powerflow on <code>data::ACPowerFlowData</code> for the given <code>time_step</code>, and writes the solution to <code>data.bus_angles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_setup.jl#L110-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><code>PowerFlows._do_refinement!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check error and do refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><a class="docstring-binding" href="#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><code>PowerFlows._dogleg!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets <code>Δx_proposed</code> equal to the <code>Δx</code> by which we should update <code>x</code>. Decides between the Cauchy step <code>Δx_cauchy</code>, Newton-Raphson step <code>Δx_nr</code>, and the dogleg interpolation between the two, based on which fall within the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L112-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._first_choice_gen_id-Tuple{String}"><a class="docstring-binding" href="#PowerFlows._first_choice_gen_id-Tuple{String}"><code>PowerFlows._first_choice_gen_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Try to make an informative one or two character name for the load/generator/etc.</p><ul><li>&quot;generator-1234-AB&quot; -&gt; &quot;AB&quot;</li><li>&quot;123<em>CT</em>7&quot; -&gt; &quot;7&quot;</li><li>&quot;load1234&quot; -&gt; &quot;34&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L636-L642">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><a class="docstring-binding" href="#PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><code>PowerFlows._fix_3w_transformer_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Setting a value of zero 0.0 when having a value greater than or equal to INFINITE_BOUND reverses the operation done in the PSY parsing side, according to PSSE Manual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L395-L398">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><a class="docstring-binding" href="#PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><code>PowerFlows._make_gens_from_hvdc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create a synthetic generator (<code>PSY.ThermalStandard</code>) representing one end of a TwoTerminalGenericHVDCLine for export purposes. The generator is initialized with parameters reflecting the HVDC line&#39;s state. </p><p><strong>Notes</strong></p><pre><code class="language-julia hljs">- The generator&#39;s name is constructed as &quot;&lt;hvdc_line_name&gt;_&lt;suffix&gt;&quot;.
- The `ext` field includes `&quot;HVDC_END&quot;` to indicate the end (&quot;FR&quot;/&quot;TO&quot;).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L853-L859">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><a class="docstring-binding" href="#PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><code>PowerFlows._map_psse_container_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L365">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._newton_powerflow-Tuple{ACPowerFlow{LevenbergMarquardtACPowerFlow}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._newton_powerflow-Tuple{ACPowerFlow{LevenbergMarquardtACPowerFlow}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows._newton_powerflow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Driver for the LevenbergMarquardtACPowerFlow method: sets up the data  structures (e.g. residual), runs the powerflow method via calling <code>_run_powerflow_method</code>  on them, then handles post-processing (e.g. loss factors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/levenberg-marquardt.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><code>PowerFlows._psse_bus_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L502-L507">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><code>PowerFlows._psse_bus_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L453-L461">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><a class="docstring-binding" href="#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><code>PowerFlows._psse_transformer_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1408-L1413">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>NewtonRaphsonACPowerFlow</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>norm(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>refinement_threshold::Float64</code>: If the solution to <code>J_x Δx = r</code> satisfies   <code>norm(J_x Δx - r, 1)/norm(r, 1) &gt; refinement_threshold</code>, do iterative refinement to   improve the accuracy. Default: 0.05.</li><li><code>refinement_eps::Float64</code>: run iterative refinement on <code>J_x Δx = r</code> until   <code>norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) &lt; refinement_eps</code>. Default:    1.0e-6 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L283-L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>TrustRegionNRMethod</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>maximum(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>factor::Float64</code>: the trust region starts out with radius <code>factor*norm(x_0, 1)</code>,   where <code>x_0</code> is our initial guess, taken from <code>data</code>. Default: 1.0.</li><li><code>eta::Float64</code>: improvement threshold. If the observed improvement in our residual   exceeds <code>eta</code> times the predicted improvement, we accept the new <code>x_i</code>.   Default: 0.0001.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L338-L348">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><a class="docstring-binding" href="#PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><code>PowerFlows._set_series_voltages_and_flows!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate series voltages at buses removed in degree 2 reduction. Method: number the nodes in the series segment 0, 1, ..., n. Number the segments by their concluding node: 1, 2, ... n. The currents in the segments are given by: [y^i<em>ff y^i</em>ft; y^i<em>tf y^i</em>tt] * [V<em>{i-1}; V</em>i] = [I<em>{i-1, i}; I</em>{i, i-1}] where I&#39;m using upper indices to denote the segment number. There are no loads or generators at the internal nodes, so I<em>{i, i+1} + I</em>{i, i-1} = 0. Substitute the above expressions for the currents and group by V<em>i: y^i</em>{tf} V<em>{i-1} + (y</em>{tt}^i + y<em>{ff}^{i+1}) V</em>i + y<em>{ft}^{i+1} V</em>{i+1} = 0 For i = 1 and i = n-1, move the terms involving V<em>0 and V</em>n [known] to the other side. This gives a tridiagonal system for x = [V<em>1, ..., V</em>{n-1}]: A * x = [-y^1<em>{tf} * V</em>0, 0, ..., 0, -y^{n}<em>{ft} * V</em>n] where A has diagonal entries y<em>{tt}^i + y</em>{ff}^{i+1}, subdiagonal entries y<em>{tf}^{i+1}, and superdiagonal entries y</em>{ft}^i.</p><p>In the below, I use y<em>11 instead of y</em>ff, y<em>12 instead of y</em>ft, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L345-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><code>PowerFlows._set_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the Newton-Raphson step. Usually, this is just <code>J.Jv \ stateVector.r</code>, but <code>J.Jv</code> might be singular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L66-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._simple_step"><a class="docstring-binding" href="#PowerFlows._simple_step"><code>PowerFlows._simple_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Does a single iteration of <code>NewtonRaphsonACPowerFlow</code>. Updates the <code>r</code> and <code>x</code> fields of the <code>stateVector</code>, and computes the Jacobian at the new <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L254-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><code>PowerFlows._singular_J_fallback</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a stand-in matrix for singular J&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._singular_value_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_singular_value_decomposition(J::SparseMatrixCSC{Float64, Int32}, npvpq::Integer; tol::Float64 = 1e-9, max_iter::Integer = 100,)</code></pre><p>Estimate the smallest singular value <code>σ</code> and corresponding left and right singular vectors <code>u</code> and <code>v</code> of a sparse matrix <code>G_s</code> (a sub-matrix of <code>J</code>). This function uses an iterative method involving LU factorization of the Jacobian matrix to estimate the smallest singular value of <code>G_s</code>.  The algorithm alternates between updating <code>u</code> and <code>v</code>, normalizing, and checking for convergence based on the change in the estimated singular value <code>σ</code>. The function uses the method described in <code>Algorithm 3</code> in the following publication:</p><pre><code class="language-julia hljs">P.-A. Lof, T. Smed, G. Andersson, and D. J. Hill, &quot;Fast calculation of a voltage stability index,&quot; in IEEE Transactions on Power Systems, vol. 7, no. 1, pp. 54-64, Feb. 1992, doi: 10.1109/59.141687.</code></pre><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64, Int32}</code>: The sparse block-form Jacobian matrix.</li><li><code>npvpq::Integer</code>: Number of PV and PQ buses in J.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tol::Float64=1e-9</code>: Convergence tolerance for the iterative algorithm.</li><li><code>max_iter::Integer=100</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>σ::Float64</code>: The estimated smallest singular value.</li><li><code>left::Vector{Float64}</code>: The estimated left singular vector (referred to as <code>u</code> in the cited paper).</li><li><code>right::Vector{Float64}</code>: The estimated right singular vector (referred to as <code>v</code> in the cited paper).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L718-L740">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><a class="docstring-binding" href="#PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><code>PowerFlows._solve_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solve for the Newton-Raphson step, given the factorization object for <code>J.Jv</code>  (if non-singular) or its stand-in (if singular).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L37-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><a class="docstring-binding" href="#PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><code>PowerFlows._trust_region_step</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does a single iteration of the <code>TrustRegionNRMethod</code>: updates the <code>x</code> and <code>r</code> fields of the <code>stateVector</code> and computes the value of the Jacobian at the new <code>x</code>, if needed. Unlike  <code>_simple_step</code>, this has a return value, the updated value of <code>delta</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_method.jl#L165-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><a class="docstring-binding" href="#PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><code>PowerFlows._update_gens_from_hvdc!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the parameters of synthetic generators created from HVDC lines, so they reflect the current setpoints and limits of the HVDC devices in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L892-L895">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows._update_hessian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets Hv equal to <code>F_1(x) H_{F_1}(x) + ...+ F_{2n}(x) H_{F_{2n}}(x)</code>, where F<em>k denotes the kth power balance equation and `H</em>{F_k}<code>its Hessian. This isn&#39;t the full Hessian of our function: it&#39;s only the terms in that come from the second derivatives of our power balance equations. (There&#39;s also a</code>J&#39;*J` term.)</p><p>What&#39;s the sparse structure of that expression? It&#39;s split into 2x2 blocks, each  corresponding to a pair of buses. The sparse structure of a block for a pair of buses  connected by a branch is:    | REF| PV | PQ  –-+––+––+–– REF|    |    |       |    |    | –-+––+––+–– PV |    |    |    |    |   .| . . –-+––+––+–– PQ |    |   .| . .    |    |   .| . . Diagonal blocks follow the same pattern as above (as if each bus is its own neighbor). Off-diagonal blocks for a pair of buses not connected by a branch are structurally zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/RobustHomotopy/homotopy_hessian.jl#L129-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64, StaticArraysCore.MVector{4, Float64}}"><a class="docstring-binding" href="#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64, StaticArraysCore.MVector{4, Float64}}"><code>PowerFlows._update_jacobian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Used to update Jv based on the bus voltages, angles, etc. in data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L530">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows._update_residual_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_residual_values!(
    F::Vector{Float64},
    x::Vector{Float64},
    P_net::Vector{Float64},
    Q_net::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64,
)</code></pre><p>Update the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the <code>ACPowerFlowResidual</code> struct. This function also updates the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>F::Vector{Float64}</code>: Vector of the values of the residuals.</li><li><code>x::Vector{Float64}</code>: State vector values.</li><li><code>P_net::Vector{Float64}</code>: Vector of net active power injections at each bus.</li><li><code>Q_net::Vector{Float64}</code>: Vector of net reactive power injections at each bus.</li><li><code>P_net_set::Vector{Float64}</code>: Vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: Sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>ref_bus::Int</code>: The index of the reference bus to be used for the total slack power.</li><li><code>data::ACPowerFlowData</code>: Data structure representing the grid model for the AC power flow calculation.</li><li><code>time_step::Int64</code>: The current time step for which the residual values are being updated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_residual.jl#L270-L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.adjust_power_injection_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><a class="docstring-binding" href="#PowerFlows.adjust_power_injection_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><code>PowerFlows.adjust_power_injection_for_lccs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Adjust the power injection vector to account for the power flows through LCCs.</p><p>Relies on the fact that we calculate those flows during initialization and save them to the <code>active_powerflow_from_to</code> and <code>active_powerflow_to_from</code> fields of the <code>LCCParameters</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/solve_dc_powerflow.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><a class="docstring-binding" href="#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><code>PowerFlows.better_float_to_buf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><a class="docstring-binding" href="#PowerFlows.block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><code>PowerFlows.block_J_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">block_J_indices(data::ACPowerFlowData, time_step::Int) -&gt; (Vector{Int32}, Vector{Int32})</code></pre><p>Get the indices to reindex the Jacobian matrix from the interleaved form to the block form:</p><p>| dP<em>dθ | dP</em>dV | | dQ<em>dθ | dQ</em>dV |</p><p><strong>Arguments</strong></p><ul><li><code>pvpq::Vector{Int32}</code>: Indices of the buses that are PV or PQ buses.</li><li><code>pq::Vector{Int32}</code>: Indices of the buses that are PQ buses.</li></ul><p><strong>Returns</strong></p><ul><li><code>rows::Vector{Int32}</code>: Row indices for the block Jacobian matrix.</li><li><code>cols::Vector{Int32}</code>: Column indices for the block Jacobian matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/ac_power_flow_jacobian.jl#L695-L710">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.calculate_x0-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.calculate_x0-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows.calculate_x0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate x0 from data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_setup.jl#L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.can_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.can_be_PV-Tuple{System}"><code>PowerFlows.can_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that can be PV: i.e. have an available generator, or certain voltage regulation devices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powersystems_utils.jl#L60-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.check_supported_version-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.check_supported_version-Tuple{PSSEExporter}"><code>PowerFlows.check_supported_version</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Throw a <code>NotImplementedError</code> if the <code>psse_version</code> is not supported</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><a class="docstring-binding" href="#PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><code>PowerFlows.contributes_active_power</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check if a device has attribute &#39;active_power&#39; for active power consumption or generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psi_utils.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>PowerFlows.convert_empty</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If <code>val</code> is empty, returns <code>T()</code>; if not, asserts that <code>val isa T</code> and returns <code>val</code>. Has nice type checker semantics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">convert_empty(Vector{String}, [])  # -&gt; String[]
convert_empty(Vector{String}, [&quot;a&quot;])  # -&gt; [&quot;a&quot;]
convert_empty(Vector{String}, [2])  # -&gt; TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}
Base.return_types(Base.Fix1(convert_empty, Vector{String}))  # -&gt; [Vector{String}]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L321-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><a class="docstring-binding" href="#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><code>PowerFlows.create_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The &quot;singles<em>to</em>1&quot; flag detects components that are the only one on their bus and gives them the name &quot;1&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L648-L653">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.dc_powerflow_start!-Tuple{Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64, PowerFlows.ACPowerFlowResidual}"><a class="docstring-binding" href="#PowerFlows.dc_powerflow_start!-Tuple{Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64, PowerFlows.ACPowerFlowResidual}"><code>PowerFlows.dc_powerflow_start!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If initial residual is large, run a DC power flow and see if that gives a better starting point for angles. If so, then overwrite <code>x0</code> with the result of the DC power flow. If not, keep the original <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_setup.jl#L64-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><a class="docstring-binding" href="#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><code>PowerFlows.flatten_power_flow_evaluation_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Expand a single <code>PowerFlowEvaluationModel</code> into its possibly multiple parts for separate evaluation. Namely, if <code>pfem</code> contains a non-nothing <code>exporter</code>, return <code>[pfem, exporter]</code>, else return <code>[pfem]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powerflow_types.jl#L122-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><a class="docstring-binding" href="#PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><code>PowerFlows.get_active_and_reactive_power_from_generator</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active and reactive power generation from a generator component. It&#39;s pg=0 as default for synchronous condensers since there&#39;s no field in the component for active power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L47-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_active_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_active_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L23-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_arc_names-Tuple{PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.get_arc_names-Tuple{PowerFlowData}"><code>PowerFlows.get_arc_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the names of the arcs in the power flow data: those that correspond to branches in the system will get the branch names, others will get a placeholder name of the form from-to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L779-L781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><code>PowerFlows.get_branches_with_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Collects all AC branches (Line, MonitoredLine, DiscreteControlledACBranch) from the system, sorts them by their bus numbers, and returns a vector of tuples (branch, bus_numbers).</p><p><strong>Arguments</strong></p><ul><li><code>exporter::PSSEExporter</code>: The exporter containing the system.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{&lt;:PSY.Branch, Tuple}}</code>: Each tuple contains a branch and its associated bus numbers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1172-L1181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_reactive_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_reactive_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><code>PowerFlows.initialize_LCC_arcs_and_buses!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Initialize the <code>arcs</code> and <code>bus_indices</code> fields of the LCCParameters structure in the PowerFlowData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/lcc_utils.jl#L107-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_powerflow_data!-Tuple{PowerFlowData, PowerFlows.PowerFlowEvaluationModel, System}"><a class="docstring-binding" href="#PowerFlows.initialize_powerflow_data!-Tuple{PowerFlowData, PowerFlows.PowerFlowEvaluationModel, System}"><code>PowerFlows.initialize_powerflow_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the fields of a PowerFlowData struct to match the given System.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/initialize_powerflow_data.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.make_power_flow_container"><a class="docstring-binding" href="#PowerFlows.make_power_flow_container"><code>PowerFlows.make_power_flow_container</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Create an appropriate <code>PowerFlowContainer</code> for the given <code>PowerFlowEvaluationModel</code> and initialize it from the given <code>PSY.System</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pfem::PowerFlowEvaluationModel</code>: power flow model to construct a container for (e.g., <code>DCPowerFlow()</code>)</li><li><code>sys::PSY.System</code>: the system from which to initialize the power flow container</li><li><code>time_steps::Int</code>: number of time periods to consider (default is <code>1</code>)</li><li><code>timestep_names::Vector{String}</code>: names of the time periods defines by the argument &quot;time_steps&quot;. Default value is <code>String[]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/PowerFlowData.jl#L645-L653">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.must_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.must_be_PV-Tuple{System}"><code>PowerFlows.must_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that must be PV: i.e. have an available generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/powersystems_utils.jl#L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Similar to above: A*X where X is a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L339-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.numeric_refactor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Frees numeric factorization stored by <code>cache</code>, if non-null. If <code>cache.check_pattern</code>  is <code>true</code> and the sparse matrix structure of <code>A</code> doesn&#39;t match the cached one,  throws an error. Finally, computes the numeric factorization of <code>A</code> and stores that to  <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/klu_linear_solver.jl#L150-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.partition_state-Tuple{Vector{Float64}, AbstractVector{ACBusTypes}}"><a class="docstring-binding" href="#PowerFlows.partition_state-Tuple{Vector{Float64}, AbstractVector{ACBusTypes}}"><code>PowerFlows.partition_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Partitions the state vector&#39;s variables based on what physical quantity each represents.  Returns a <code>NamedTuple</code>, with the 4 keys <code>Va</code>, <code>Vm</code>, <code>P</code>, and <code>Q</code>. The 4 values are vectors  of length equal to the number of buses, with <code>NaN</code>s in the positions where that physical  quantity is not part of the state vector for that bus. (Currently not intended for use in  spots where performance is critical.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/state_indexing_helpers.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.reset_caches-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.reset_caches-Tuple{PSSEExporter}"><code>PowerFlows.reset_caches</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Force all cached information (serialized metadata, component lists, etc.) to be regenerated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><a class="docstring-binding" href="#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><code>PowerFlows.serialize_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Take the output of <code>create_component_ids</code> and make it more suitable for JSON serialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L683">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows.set_branch_flows_for_dict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Set the power flow in the arcs that remain after network reduction. Called on the  <code>direct_branch_map</code> and <code>transformer3W_map</code> dictionaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L438-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.set_values!-Union{Tuple{I}, Tuple{T}, Tuple{PowerFlows.FixedStructureCHOLMOD{T, I}, AbstractVector{T}}} where {T&lt;:Union{Float32, Float64}, I&lt;:Union{Int32, Int64}}"><a class="docstring-binding" href="#PowerFlows.set_values!-Union{Tuple{I}, Tuple{T}, Tuple{PowerFlows.FixedStructureCHOLMOD{T, I}, AbstractVector{T}}} where {T&lt;:Union{Float32, Float64}, I&lt;:Union{Int32, Int64}}"><code>PowerFlows.set_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_values!(mat::FixedStructureCHOLMOD, new_vals::AbstractVector{Float64})</code></pre><p>In-place update of the numeric values in the CHOLMOD matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/RobustHomotopy/HessianSolver/fixed_structure_CHOLMOD.jl#L25-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.siground-Tuple{Float64}"><a class="docstring-binding" href="#PowerFlows.siground-Tuple{Float64}"><code>PowerFlows.siground</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>For pretty printing floats in debugging messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><a class="docstring-binding" href="#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><code>PowerFlows.supports_multi_period</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Trait signifying whether the <code>PowerFlowContainer</code> can represent multi-period data. Must be implemented for all concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/PowerFlowData.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_factor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Frees up the current symbolic and numeric factorizations stored by <code>cache</code>, if non-null. Then computes the symbolic factorization of <code>A</code> and stores that to <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/klu_linear_solver.jl#L67-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_refactor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Symbolic refactor. Behavior depends on the values of <code>cache.reuse_symbol</code> and  <code>cache.check_pattern</code>. There are 3 cases:</p><ul><li><code>!reuse_symbol</code>: always refactor. Just calls <code>symbolic_factor(cache, A)</code>.</li><li><code>reuse_symbol &amp;&amp; check_pattern</code>: checks if the symbolic structure of <code>A</code> matches the   cached one, and throws an error if it doesn&#39;t. This is to prevent bad input: we expected    the structure to be the same, but it isn&#39;t.</li><li><code>reuse_symbol &amp;&amp; !check pattern</code>: do nothing. Assume the structure of <code>A</code> matches the cached    one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/LinearSolverCache/klu_linear_solver.jl#L112-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_data!-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.update_data!-Tuple{PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Vector{Float64}, Int64}"><code>PowerFlows.update_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the fields of data based on the values of the state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/state_indexing_helpers.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_net_power!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, AbstractVector{ACBusTypes}}"><a class="docstring-binding" href="#PowerFlows.update_net_power!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, AbstractVector{ACBusTypes}}"><code>PowerFlows.update_net_power!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update <code>P_net</code> and <code>Q_net</code> based on the values of the state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/state_indexing_helpers.jl#L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_state!-Tuple{Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.update_state!-Tuple{Vector{Float64}, PowerFlowData{PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Unfactorized}}, Int64}"><code>PowerFlows.update_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update state vector based on values of fields of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/state_indexing_helpers.jl#L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_system!-Tuple{System, PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.update_system!-Tuple{System, PowerFlowData}"><code>PowerFlows.update_system!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Modify the values in the given <code>System</code> to correspond to the given <code>PowerFlowData</code> such that if a new <code>PowerFlowData</code> is constructed from the resulting system it is the same as <code>data</code>. See also <code>write_powerflow_solution!</code>. NOTE that this assumes that <code>data</code> was initialized from <code>sys</code> and then solved with no further modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L953-L958">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wdot-NTuple{4, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wdot-NTuple{4, Vector{Float64}}"><code>PowerFlows.wdot</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted dot product of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><code>PowerFlows.wnorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted norm of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/common.jl#L552">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_powerflow_solution!"><a class="docstring-binding" href="#PowerFlows.write_powerflow_solution!"><code>PowerFlows.write_powerflow_solution!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Updates system voltages and powers with power flow results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/post_processing.jl#L460-L462">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L540-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Case Identification Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 FACTS Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2453-L2455">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Fixed Bus Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L794-L796">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Generator Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L934-L936">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Load Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L725-L727">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Non-Transformer Branch Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1196-L1198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2672-L2674">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Switched Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2533-L2535">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 35.4 POM 5.2.1 System Switching Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1314-L1316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1464-L1466">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Impedance Correction Tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2307-L2309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Two-Terminal DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L1954-L1956">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Voltage Source Converter (VSC) DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2109-L2111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Zone Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/660ac2597b4ca2668af46c740fa03fb16cf8c93e/src/psse_export.jl#L2420-L2422">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 4 December 2025 02:52">Thursday 4 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
