<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Reference · PowerFlows.jl</title><meta name="title" content="Internal API Reference · PowerFlows.jl"/><meta property="og:title" content="Internal API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Internal API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><a class="tocitem" href="../../../tutorials/stub/">Tutorials</a></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li><a class="tocitem" href="../public/">Public API Reference</a></li><li class="is-active"><a class="tocitem" href>Internal API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Internal API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian" href="#PowerFlows.ACPowerFlowJacobian"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ACPowerFlowJacobian</code></pre><p>A struct that represents the Jacobian matrix for AC power flow calculations.</p><p>This struct uses the functor pattern, meaning instances of <code>ACPowerFlowJacobian</code> store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data used for power flow calculations.</li><li><code>Jf!::Function</code>: A function that calculates the Jacobian matrix inplace.</li><li><code>Jv::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix, which is updated by the function <code>Jf!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(time_step::Int64)</code></pre><p>Update the Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step.</p><p>Defining this method allows an instance of <code>ACPowerFlowJacobian</code> to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
J(time_step)  # Updates the Jacobian matrix Jv</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -&gt; ACPowerFlowJacobian</code></pre><p>This is the constructor for ACPowerFlowJacobian. Create an <code>ACPowerFlowJacobian</code> instance. As soon as the instance is created, it already has the Jacobian matrix structure initialized and its values updated, stored internally as Jv. The data instance is stored internally and used to update the Jacobian matrix because the structure of the Jacobian matrix is tied to the data. Changing the data requires creating a new instance of <code>ACPowerFlowJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data used for power flow calculations.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowJacobian</code>: An instance of <code>ACPowerFlowJacobian</code>.</li></ul><p>#Example</p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.
J(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.
J.Jv  # Access the Jacobian matrix stored internally in J.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L71-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)</code></pre><p>Use the <code>ACPowerFlowJacobian</code> to update the provided Jacobian matrix <code>J</code> inplace.</p><p>Update the internally stored Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step, and write the updated Jacobian values to <code>J</code>.</p><p>This method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>`: A sparse matrix to be updated with new values of the Jacobian matrix.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
Jv = SparseArrays.sparse(Float64[], Int32[], Int32[])
J(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L42-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowResidual" href="#PowerFlows.ACPowerFlowResidual"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct ACPowerFlowResidual</code></pre><p>A struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data.</li><li><code>Rf!::Function</code>: A function that updates the residuals based on the latest values stored in the grid at the given iteration.</li><li><code>Rv::Vector{Float64}</code>: A vector of the values of the residuals.</li><li><code>P_net::Vector{Float64}</code>: A vector of net active power injections.</li><li><code>Q_net::Vector{Float64}</code>: A vector of net reactive power injections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_residual.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowResidual-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows.ACPowerFlowResidual-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)</code></pre><p>Create an instance of <code>ACPowerFlowResidual</code> for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data representing the power system model.</li><li><code>time_step::Int64</code>: The time step for which the power flow calculation is executed.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowResidual</code>: An instance containing the residual values, net bus active power injections, </li></ul><p>and net bus reactive power injections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_residual.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)</code></pre><p>Update the AC power flow residuals inplace and store the result in the attribute <code>Rv</code> of the struct. The inputs are the values of state vector <code>x</code> and the current time step <code>time_step</code>. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct.  This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The state vector values.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_residual.jl#L89-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)</code></pre><p>Evaluate the AC power flow residuals and store the result in <code>Rv</code> using the provided  state vector <code>x</code> and the current time step <code>time_step</code>. The residuals are updated inplace in the struct and additionally copied to the provided array.  This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct.  This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>Rv::Vector{Float64}</code>: The vector to store the calculated residuals.</li><li><code>x::Vector{Float64}</code>: The state vector.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_residual.jl#L64-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.KLULinSolveCache" href="#PowerFlows.KLULinSolveCache"><code>PowerFlows.KLULinSolveCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A cached linear solver using KLU. </p><p><strong>Fields:</strong></p><ul><li><code>K</code>: the underlying KLU object.</li><li><code>reuse_symbolic::Bool</code>: reuse the symbolic factorization. Defaults to true.</li><li><code>check_pattern::Bool</code>: if true, <code>numeric_refactor!</code> verifies that the new</li></ul><p>matrix has the same sparsity structure. Defaults to true.</p><ul><li><code>been_factored::Bool</code>: used internally. Keeps track of whether we&#39;ve done a numeric factorization.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.LinearSolverCache" href="#PowerFlows.LinearSolverCache"><code>PowerFlows.LinearSolverCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Abstract supertype for all cached linear solvers. Subtypes must implement: <code>symbolic_factor!</code>, <code>symbolic_refactor!</code>, <code>numeric_refactor!</code> (which doubles as <code>numeric_factor!</code>), and <code>solve!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/linear_solver_cache.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.StateVectorCache" href="#PowerFlows.StateVectorCache"><code>PowerFlows.StateVectorCache</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Cache for non-linear methods</p><p><strong>Fields</strong></p><p>-<code>x::Vector{Float64}</code>: the current state vector. Used for all methods. -<code>r::Vector{Float64}</code>: the current residual. Used for all methods.     For <code>NewtonRaphsonACPowerFlow</code>, we solve <code>J_x Δx = r</code> in-place,     so this also stores the step <code>Δx</code> at times in those methods. The remainder of the fields are only used in the <code>TrustRegionACPowerFlow</code>: -<code>r_predict::Vector{Float64}</code>: the predicted residual at <code>x+Δx_proposed</code>,     under a linear approximation: i.e <code>J_x⋅(x+Δx_proposed)</code>. -<code>Δx_proposed::Vector{Float64}</code>: the suggested step <code>Δx</code>, selected among <code>Δx_nr</code>,      <code>Δx_cauchy</code>, and the dogleg interpolation between the two. The first is chosen when     <code>x+Δx_nr</code> is inside the trust region, the second when both <code>x+Δx_cauchy</code>     and <code>x+Δx_nr</code> are outside the trust region, and the third when <code>x+Δx_cauchy</code>     is inside and <code>x+Δx_nr</code> outside. The dogleg step selects the point where the line     from <code>x+Δx_cauchy</code> to <code>x+Δx_nr</code> crosses the boundary of the trust region. -<code>Δx_cauchy::Vector{Float64}</code>: the step to the Cauchy point if the Cauchy point     lies within the trust region, otherwise a step in that direction. -<code>Δx_nr::Vector{Float64}</code>: the step under the Newton-Raphson method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.SystemPowerFlowContainer" href="#PowerFlows.SystemPowerFlowContainer"><code>PowerFlows.SystemPowerFlowContainer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>A <code>PowerFlowContainer</code> that represents its data as a <code>PSY.System</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/PowerFlowData.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -&gt; SparseMatrixCSC{Float64, Int32}</code></pre><p>Create the structure of the Jacobian matrix for an AC power flow problem. Inputs are the grid model as an instance of <code>ACPowerFlowData</code> at a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow model.</li><li><code>time_step::Int64</code>: The specific time step for which the Jacobian matrix structure is created.</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.</li></ul><p><strong>Description</strong></p><p>This function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.</p><p>Unlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus. See the example below for details.</p><p>This approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.</p><p>The function initializes three arrays (<code>rows</code>, <code>columns</code>, and <code>values</code>) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.</p><p>For each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (<code>REF</code>, <code>PV</code>, or <code>PQ</code>).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.</p><ul><li>For <code>REF</code> buses, entries are added for local active and reactive power.</li><li>For <code>PV</code> buses, entries are added for active and reactive power with respect to angle, and for local reactive power.</li><li>For <code>PQ</code> buses, entries are added for active and reactive power with respect to voltage magnitude and angle.</li></ul><p>For example, suppose we have a system with 3 buses: bus 1 is <code>REF</code>, bus 2 is <code>PV</code>, and bus 3 is <code>PQ</code>. Let ΔPⱼ, ΔQⱼ be the active, reactive power balance at the <code>j</code>th bus. Let Pⱼ and Qⱼ be the active and reactive power generated at the <code>j</code>th bus (<code>REF</code> and <code>PV</code> only). Then the state vector is [P₁, Q₁, Q₂, θ₂, V₃, θ₃], and the Jacobian matrix is</p><p>| ∂ΔP₁/∂P₁ | ∂ΔP₁/∂Q₁ | ∂ΔP₁/∂Q₂ | ∂ΔP₁/∂θ₂ | ∂ΔP₁/∂V₃ | ∂ΔP₁/∂θ₃ |   | ∂ΔQ₁/∂P₁ | ∂ΔQ₁/∂Q₁ | ∂ΔQ₁/∂Q₂ | ∂ΔQ₁/∂θ₂ | ∂ΔQ₁/∂V₃ | ∂ΔQ₁/∂θ₃ | | ∂ΔP₂/∂P₁ | ∂ΔP₂/∂Q₁ | ∂ΔP₂/∂Q₂ | ∂ΔP₂/∂θ₂ | ∂ΔP₂/∂V₃ | ∂ΔP₂/∂θ₃ | | ∂ΔQ₂/∂P₁ | ∂ΔQ₂/∂Q₁ | ∂ΔQ₂/∂Q₂ | ∂ΔQ₂/∂θ₂ | ∂ΔQ₂/∂V₃ | ∂ΔQ₂/∂θ₃ | | ∂ΔP₃/∂P₁ | ∂ΔP₃/∂Q₁ | ∂ΔP₃/∂Q₂ | ∂ΔP₃/∂θ₂ | ∂ΔP₃/∂V₃ | ∂ΔP₃/∂θ₃ | | ∂ΔQ₃/∂P₁ | ∂ΔQ₃/∂Q₁ | ∂ΔQ₃/∂Q₂ | ∂ΔQ₃/∂θ₂ | ∂ΔQ₃/∂V₃ | ∂ΔQ₃/∂θ₃ |</p><p>In reality, for large networks, this matrix would be sparse, and each 4x4 block would only be nonzero when there&#39;s a line between the respective buses.</p><p>Finally, the function constructs a sparse matrix from the collected indices and values and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L195-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create the Jacobian matrix structure for a PV bus. Ignoring this because we fill all four values even for PV buses with      structural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L129-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create the Jacobian matrix structure for a reference bus (REF). Ignoring this because we fill all four values even for PV buses with      structiural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L102-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn&#39;t matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -&gt; PQ transition and then we need to fill all four values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PowerFlows.KLULinSolveCache{Int32}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Float64}" href="#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PowerFlows.KLULinSolveCache{Int32}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Float64}"><code>PowerFlows._dogleg!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Sets <code>Δx_proposed</code> equal to the <code>Δx</code> by which we should update <code>x</code>. Decides between the Cauchy step <code>Δx_cauchy</code>, Newton-Raphson step <code>Δx_nr</code>, and the dogleg interpolation between the two, based on which fall within the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L38-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._first_choice_gen_id-Tuple{String}" href="#PowerFlows._first_choice_gen_id-Tuple{String}"><code>PowerFlows._first_choice_gen_id</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Try to make an informative one or two character name for the load/generator/etc.</p><ul><li>&quot;generator-1234-AB&quot; -&gt; &quot;AB&quot;</li><li>&quot;123<em>CT</em>7&quot; -&gt; &quot;7&quot;</li><li>&quot;load1234&quot; -&gt; &quot;34&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L495-L501">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._get_load_data-Tuple{System, Bus}" href="#PowerFlows._get_load_data-Tuple{System, Bus}"><code>PowerFlows._get_load_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Obtain total load on bus b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L121-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._map_psse_container_names-Tuple{Vector{String}}" href="#PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><code>PowerFlows._map_psse_container_names</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}" href="#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><code>PowerFlows._psse_bus_names</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}" href="#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><code>PowerFlows._psse_bus_numbers</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L341-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector{Tuple{Int64, Int64}}, AbstractDict{Int64, Int64}, Any}" href="#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector{Tuple{Int64, Int64}}, AbstractDict{Int64, Int64}, Any}"><code>PowerFlows._psse_transformer_names</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L855-L860">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Runs the full <code>NewtonRaphsonACPowerFlow</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 30.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>norm(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>refinement_threshold::Float64</code>: If the solution to <code>J_x Δx = r</code> satisfies   <code>norm(J_x Δx - r, 1)/norm(r, 1) &gt; refinement_threshold</code>, do iterative refinement to   improve the accuracy. Default: 0.05.</li><li><code>refinement_eps::Float64</code>: run iterative refinement on <code>J_x Δx = r</code> until   <code>norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) &lt; refinement_eps</code>. Default:    1.0e-6 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L198-L209">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Runs the full <code>TrustRegionNRMethod</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 30.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>maximum(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>factor::Float64</code>: the trust region starts out with radius <code>factor*norm(x_0, 1)</code>,   where <code>x_0</code> is our initial guess, taken from <code>data</code>. Default: 1.0.</li><li><code>eta::Float64</code>: improvement threshold. If the observed improvement in our residual   exceeds <code>eta</code> times the predicted improvement, we accept the new <code>x_i</code>.   Default: 0.0001.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L239-L249">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._simple_step" href="#PowerFlows._simple_step"><code>PowerFlows._simple_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Does a single iteration of <code>NewtonRaphsonACPowerFlow</code>. Updates the <code>r</code> and <code>x</code> fields of the <code>stateVector</code>, and computes the Jacobian at the new <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L143-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._trust_region_step" href="#PowerFlows._trust_region_step"><code>PowerFlows._trust_region_step</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Does a single iteration of the <code>TrustRegionNRMethod</code>: updates the <code>x</code> and <code>r</code> fields of the <code>stateVector</code> and computes the value of the Jacobian at the new <code>x</code>, if needed. Unlike  <code>_simple_step</code>, this has a return value, the updated value of <code>delta</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_method.jl#L84-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._update_branch_flow!-Tuple{System}" href="#PowerFlows._update_branch_flow!-Tuple{System}"><code>PowerFlows._update_branch_flow!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Updates the flow on the branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L110-L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows._update_jacobian_matrix_values!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Used to update Jv based on the bus voltages, angles, etc. in data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L434">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows._update_residual_values!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_update_residual_values!(
    F::Vector{Float64},
    x::Vector{Float64},
    P_net::Vector{Float64},
    Q_net::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64,
)</code></pre><p>Update the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the <code>ACPowerFlowResidual</code> struct. This function also updates the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>F::Vector{Float64}</code>: Vector of the values of the residuals.</li><li><code>x::Vector{Float64}</code>: State vector values.</li><li><code>P_net::Vector{Float64}</code>: Vector of net active power injections at each bus.</li><li><code>Q_net::Vector{Float64}</code>: Vector of net reactive power injections at each bus.</li><li><code>data::ACPowerFlowData</code>: Data structure representing the grid model for the AC power flow calculation.</li><li><code>time_step::Int64</code>: The current time step for which the residual values are being updated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_residual.jl#L153-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}" href="#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><code>PowerFlows.better_float_to_buf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.calculate_loss_factors-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}" href="#PowerFlows.calculate_loss_factors-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.calculate_loss_factors</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)</code></pre><p>Calculate and store the active power loss factors in the <code>loss_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step.</p><p>The loss factors are computed using the Jacobian matrix <code>Jv</code> and the vector <code>dSbus_dV_ref</code>, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injection as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data structure containing power flow information, including the <code>loss_factors</code> matrix.</li><li><code>Jv::SparseMatrixCSC{Float64, Int32}</code>: The sparse Jacobian matrix of the power flow system.</li><li><code>time_step::Int</code>: The time step index for which the loss factors are calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/ac_power_flow_jacobian.jl#L462-L476">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.check_33-Tuple{PSSEExporter}" href="#PowerFlows.check_33-Tuple{PSSEExporter}"><code>PowerFlows.check_33</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Throw a <code>NotImplementedError</code> if the <code>psse_version</code> is not <code>:v33</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>PowerFlows.convert_empty</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If <code>val</code> is empty, returns <code>T()</code>; if not, asserts that <code>val isa T</code> and returns <code>val</code>. Has nice type checker semantics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">convert_empty(Vector{String}, [])  # -&gt; String[]
convert_empty(Vector{String}, [&quot;a&quot;])  # -&gt; [&quot;a&quot;]
convert_empty(Vector{String}, [2])  # -&gt; TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}
Base.return_types(Base.Fix1(convert_empty, Vector{String}))  # -&gt; [Vector{String}]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T" href="#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><code>PowerFlows.create_component_ids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The &quot;singles<em>to</em>1&quot; flag detects components that are the only one on their bus and gives them the name &quot;1&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}" href="#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><code>PowerFlows.flatten_power_flow_evaluation_model</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Expand a single <code>PowerFlowEvaluationModel</code> into its possibly multiple parts for separate evaluation. Namely, if <code>pfem</code> contains a non-nothing <code>exporter</code>, return <code>[pfem, exporter]</code>, else return <code>[pfem]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/powerflow_types.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{ACBranch, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{ACBranch, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{TapTransformer, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{TapTransformer, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type TapTransformer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{Transformer2W, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{Transformer2W, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type Transformer2W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{ACBranch}" href="#PowerFlows.flow_val-Tuple{ACBranch}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{DynamicBranch}" href="#PowerFlows.flow_val-Tuple{DynamicBranch}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{TapTransformer}" href="#PowerFlows.flow_val-Tuple{TapTransformer}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type TapTransformer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{Transformer2W}" href="#PowerFlows.flow_val-Tuple{Transformer2W}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Transformer2W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}" href="#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_active_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_active_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/common.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}" href="#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_reactive_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_reactive_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/common.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.make_power_flow_container" href="#PowerFlows.make_power_flow_container"><code>PowerFlows.make_power_flow_container</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Create an appropriate <code>PowerFlowContainer</code> for the given <code>PowerFlowEvaluationModel</code> and initialize it from the given <code>PSY.System</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pfem::PowerFlowEvaluationModel</code>: power flow model to construct a container for (e.g., <code>DCPowerFlow()</code>)</li><li><code>sys::PSY.System</code>: the system from which to initialize the power flow container</li><li><code>time_steps::Int</code>: number of time periods to consider (default is <code>1</code>)</li><li><code>timestep_names::Vector{String}</code>: names of the time periods defines by the argument &quot;time_steps&quot;. Default value is <code>String[]</code>.</li><li><code>check_connectivity::Bool</code>: Perform connectivity check on the network matrix. Default value is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/PowerFlowData.jl#L486-L495">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Similar to above: A*X where X is a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/common.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/common.jl#L148-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.numeric_refactor!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Frees numeric factorization stored by <code>cache</code>, if non-null. If <code>cache.check_pattern</code>  is <code>true</code> and the sparse matrix structure of <code>A</code> doesn&#39;t match the cached one,  throws an error. Finally, computes the numeric factorization of <code>A</code> and stores that to  <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.reset_caches-Tuple{PSSEExporter}" href="#PowerFlows.reset_caches-Tuple{PSSEExporter}"><code>PowerFlows.reset_caches</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Force all cached information (serialized metadata, component lists, etc.) to be regenerated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.same_pattern-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.same_pattern-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.same_pattern</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Compares sparsity structure of A with that of cache. Note the fields of <code>cache.K</code> are  0-indexed, while those of A are 1-indexed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L25-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}" href="#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><code>PowerFlows.serialize_component_ids</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Take the output of <code>create_component_ids</code> and make it more suitable for JSON serialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, StridedVecOrMat{Float64}}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.solve!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, StridedVecOrMat{Float64}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.solve!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Solves Ax = B in-place, where B is a vector or matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L112">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.solve_w_refinement-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}, StridedVecOrMat{Float64}}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}, StridedVecOrMat{Float64}, Float64}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.solve_w_refinement-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}, StridedVecOrMat{Float64}}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}, StridedVecOrMat{Float64}, Float64}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.solve_w_refinement</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Solve with iterative refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}" href="#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><code>PowerFlows.supports_multi_period</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Trait signifying whether the <code>PowerFlowContainer</code> can represent multi-period data. Must be implemented for all concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/PowerFlowData.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_factor!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Frees up the current symbolic and numeric factorizations stored by <code>cache</code>, if non-null. Then computes the symbolic factorization of <code>A</code> and stores that to <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L40-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}" href="#PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_refactor!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Symbolic refactor. Behavior depends on the values of <code>cache.reuse_symbol</code> and  <code>cache.check_pattern</code>. There are 3 cases:</p><ul><li><code>!reuse_symbol</code>: always refactor. Just calls <code>symbolic_factor(cache, A)</code>.</li><li><code>reuse_symbol &amp;&amp; check_pattern</code>: checks if the symbolic structure of <code>A</code> matches the   cached one, and throws an error if it doesn&#39;t. This is to prevent bad input: we expected    the structure to be the same, but it isn&#39;t.</li><li><code>reuse_symbol &amp;&amp; !check pattern</code>: do nothing. Assume the structure of <code>A</code> matches the cached    one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/LinearSolverCache/klu_linear_solver.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.update_system!-Tuple{System, PowerFlowData}" href="#PowerFlows.update_system!-Tuple{System, PowerFlowData}"><code>PowerFlows.update_system!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Modify the values in the given <code>System</code> to correspond to the given <code>PowerFlowData</code> such that if a new <code>PowerFlowData</code> is constructed from the resulting system it is the same as <code>data</code>. See also <code>write_powerflow_solution!</code>. NOTE that this assumes that <code>data</code> was initialized from <code>sys</code> and then solved with no further modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L694-L699">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_powerflow_solution!" href="#PowerFlows.write_powerflow_solution!"><code>PowerFlows.write_powerflow_solution!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Updates system voltages and powers with power flow results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/post_processing.jl#L433-L435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L420-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Case Identification Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Fixed Bus Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L616-L618">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>If the export<em>settings flag `sources</em>as<em>generators<code>is set, export</code>PSY.Source<code>instances as PSS/E generators in addition to</code>PSY.Generator<code>s. Same for</code>storages</em>as_generators<code>and</code>PSY.Storage`.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Generator Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L671-L677">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Load Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L574-L576">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Non-Transformer Branch Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L783-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L1037-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Currently only supports two-winding transformers</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L900-L904">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Zone Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/ecf0566206d9cec8cbbf098519289f04974686f9/src/psse_export.jl#L1009-L1011">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 8 April 2025 15:33">Tuesday 8 April 2025</span>. Using Julia version 1.11.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
