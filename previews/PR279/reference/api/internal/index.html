<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Reference · PowerFlows.jl</title><meta name="title" content="Internal API Reference · PowerFlows.jl"/><meta property="og:title" content="Internal API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Internal API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../../tutorials/solving-a-power-flow/">Solving a Power Flow</a></li></ul></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li><a class="tocitem" href="../../developers/lcc_model/">LCC Model Implementation</a></li><li><a class="tocitem" href="../public/">Public API Reference</a></li><li class="is-active"><a class="tocitem" href>Internal API Reference</a><ul class="internal"><li><a class="tocitem" href="#Power-Flow-Types"><span>Power Flow Types</span></a></li><li class="toplevel"><a class="tocitem" href="#PowerFlowData"><span>PowerFlowData</span></a></li><li><a class="tocitem" href="#Struct-and-Type-Definitions"><span>Struct and Type Definitions</span></a></li><li><a class="tocitem" href="#Solving-a-PowerFlowData-instance"><span>Solving a PowerFlowData instance</span></a></li><li><a class="tocitem" href="#Manipulating-a-PowerFlowData-instance"><span>Manipulating a PowerFlowData instance</span></a></li><li class="toplevel"><a class="tocitem" href="#LCC-HVDC-Parameters-and-Utilities"><span>LCC HVDC Parameters and Utilities</span></a></li><li class="toplevel"><a class="tocitem" href="#AC-Power-Flow"><span>AC Power Flow</span></a></li><li><a class="tocitem" href="#Residuals"><span>Residuals</span></a></li><li><a class="tocitem" href="#Jacobian"><span>Jacobian</span></a></li><li><a class="tocitem" href="#Iterative-Methods"><span>Iterative Methods</span></a></li><li><a class="tocitem" href="#Robust-Homotopy-Method"><span>Robust Homotopy Method</span></a></li><li><a class="tocitem" href="#Levenberg-Marquardt-Method"><span>Levenberg-Marquardt Method</span></a></li><li class="toplevel"><a class="tocitem" href="#Linear-Algebra-Backends"><span>Linear Algebra Backends</span></a></li><li><a class="tocitem" href="#Robust-Homotopy"><span>Robust Homotopy</span></a></li><li><a class="tocitem" href="#Newton-Raphson"><span>Newton-Raphson</span></a></li><li class="toplevel"><a class="tocitem" href="#Misc."><span>Misc.</span></a></li><li><a class="tocitem" href="#PSSE-Export"><span>PSSE Export</span></a></li><li><a class="tocitem" href="#Post-Processing"><span>Post-Processing</span></a></li><li><a class="tocitem" href="#Power-Systems-Utilities"><span>Power Systems Utilities</span></a></li><li><a class="tocitem" href="#Common-Utilities-and-Definitions"><span>Common Utilities and Definitions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Internal API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><h2 id="Power-Flow-Types"><a class="docs-heading-anchor" href="#Power-Flow-Types">Power Flow Types</a><a id="Power-Flow-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Types" title="Permalink"></a></h2><h1 id="PowerFlowData"><a class="docs-heading-anchor" href="#PowerFlowData">PowerFlowData</a><a id="PowerFlowData-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlowData" title="Permalink"></a></h1><h2 id="Struct-and-Type-Definitions"><a class="docs-heading-anchor" href="#Struct-and-Type-Definitions">Struct and Type Definitions</a><a id="Struct-and-Type-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Struct-and-Type-Definitions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ABAPowerFlowData"><a class="docstring-binding" href="#PowerFlows.ABAPowerFlowData"><code>PowerFlows.ABAPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>DCPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L163-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowData"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowData"><code>PowerFlows.ACPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>ACPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L133-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PTDFPowerFlowData"><a class="docstring-binding" href="#PowerFlows.PTDFPowerFlowData"><code>PowerFlows.PTDFPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>PTDFDCPowerFlow</code> method .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L145-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData"><a class="docstring-binding" href="#PowerFlows.PowerFlowData"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData{M &lt;: PNM.PowerNetworkMatrix, N &lt;: Union{PNM.PowerNetworkMatrix, Nothing}}</code></pre><p>Structure containing all the data required for the evaluation of the power flows and angles, as well as these ones.</p><p>All fields starting with <code>bus_</code> are ordered according to <code>bus_lookup</code>, and all fields  starting with <code>arc_</code> are ordered according to <code>arc_lookup</code>: one row per bus/arc,  one column per time period. Here, buses should be understood as &quot;buses remaining, after  the network reduction.&quot; Similarly, we use &quot;arcs&quot; instead of &quot;branches&quot; to distinguish  between network elements (post-reduction) and system objects (pre-reduction).</p><p>Generally, do not construct this directly. Instead, use one of the later constructors to  pass in a <code>PowerFlowEvaluationModel</code> and a <code>PowerSystems.System</code>.  <code>aux\_network\_matrix</code> and <code>power\_network\_matrix</code> will then be set to the appropriate  matrices that are needed for computing that type of power flow. See also <code>ACPowerFlowData</code>, <code>ABAPowerFlowData</code>, <code>PTDFPowerFlowData</code>, and <code>vPTDFPowerFlowData</code>:  these are all aliases for <code>PowerFlowData{N, M}</code> with specific <code>N</code>,<code>M</code>, that are used for  the respective type of power flow evaluations.</p><p><strong>Fields:</strong></p><ul><li><code>bus_active_power_injections::Matrix{Float64}</code>:       matrix containing the bus active power injections.</li><li><code>bus_reactive_power_injections::Matrix{Float64}</code>:       matrix containing the bus reactive power injections.</li><li><code>bus_active_power_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power withdrawals.</li><li><code>bus_reactive_power_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power withdrawals.</li><li><code>bus_active_power_constant_current_withdrawals::Matrix{Float64}</code>:       matrix containing the bus active power constant current       withdrawals.</li><li><code>bus_reactive_power_constant_current_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power constant current       withdrawals.</li><li><code>bus_active_power_constant_impedance_withdrawals::Matrix{Float64}</code>:       matrix containing the bus active power constant impedance       withdrawals.</li><li><code>bus_reactive_power_constant_impedance_withdrawals::Matrix{Float64}</code>:         matrix containing the bus reactive power constant impedance       withdrawals.</li><li><code>bus_reactive_power_bounds::Matrix{Float64}</code>:       matrix containing upper and lower bounds for the reactive supply at each       bus at each time period.</li><li><code>bus_type::Matrix{PSY.ACBusTypes}</code>:       matrix containing type of buses present in the system.</li><li><code>bus_magnitude::Matrix{Float64}</code>:       matrix containing the bus voltage magnitudes.</li><li><code>bus_angles::Matrix{Float64}</code>:       matrix containing the bus voltage angles.</li><li><code>arc_active_power_flow_from_to::Matrix{Float64}</code>:       matrix containing the active power flows measured at the <code>from</code> bus.</li><li><code>arc_reactive_power_flow_from_to::Matrix{Float64}</code>:       matrix containing the reactive power flows measured at the <code>from</code> bus.</li><li><code>arc_active_power_flow_to_from::Matrix{Float64}</code>:       matrix containing the active power flows measured at the <code>to</code> bus.</li><li><code>arc_reactive_power_flow_to_from::Matrix{Float64}</code>:       matrix containing the reactive power flows measured at the <code>to</code> bus.</li><li><code>generic_hvdc_flows::Dict{Tuple{Int, Int}, Tuple{Float64, Float64}}</code>:       dictionary mapping each generic HVDC line (represented as a tuple of the from and to bus       numbers) to a tuple of <code>(P_from_to, P_to_from)</code> active power flows.</li><li><code>bus_hvdc_net_power::Matrix{Float64}</code>:       &quot;(b, t)&quot; matrix containing the net power injections from all HVDC lines at each bus.       b: number of buses, t: number of time period. Only contains HVDCs handled as       separate injection/withdrawal pairs: LCCs and generic for DC, or just generic for AC.</li><li><code>time_step_map::Dict{Int, S}</code>:       dictionary mapping the number of the time periods (corresponding to the       column number of the previously mentioned matrices) and their names.</li><li><code>power_network_matrix::M</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>aux_network_matrix::N</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>neighbors::Vector{Set{Int}}</code>: Vector with the sets of adjacent buses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L18-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    pf::ACPowerFlow{&lt;:ACPowerFlowSolverType},
    sys::PSY.System
) -&gt; ACPowerFlowData{&lt;:ACPowerFlowSolverType}</code></pre><p>Creates the structure for an AC power flow calculation, given the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>. Configuration options like <code>time_steps</code>, <code>timestep_names</code>, <code>network_reductions</code>, and <code>correct_bustypes</code> are taken from the <a href="../public/#PowerFlows.ACPowerFlow"><code>ACPowerFlow</code></a> object.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="../public/#PowerFlows.ACPowerFlow"><code>ACPowerFlow</code></a>: this version is used to solve AC power flows, and returns an <a href="#PowerFlows.ACPowerFlowData"><code>ACPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="../public/#PowerFlows.ACPowerFlow"><code>pf::ACPowerFlow</code></a>:       the settings for the AC power flow solver, including <code>time_steps</code>, <code>time_step_names</code>,       <code>network_reductions</code>, and <code>correct_bustypes</code>.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power       grid under consideration.</li></ul><p>WARNING: functions for the evaluation of the multi-period AC PF still to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L436-L460">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    pf::DCPowerFlow,
    sys::PSY.System
) -&gt; ABAPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a standard DC power flow calculation, given the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>. Configuration options like <code>time_steps</code>, <code>time_step_names</code>, <code>network_reductions</code>, and <code>correct_bustypes</code> are taken from the <a href="../public/#PowerFlows.DCPowerFlow"><code>DCPowerFlow</code></a> object.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="../public/#PowerFlows.DCPowerFlow"><code>DCPowerFlow</code></a>: this version is used to solve DC power flows, and returns an <a href="#PowerFlows.ABAPowerFlowData"><code>ABAPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="../public/#PowerFlows.DCPowerFlow"><code>pf::DCPowerFlow</code></a>:       Run a DC power flow: internally, store the ABA matrix as <code>power_network_matrix</code> and       the BA matrix as <code>aux_network_matrix</code>. Configuration options are taken from this object.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power       grid under consideration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L492-L514">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{PTDFDCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{PTDFDCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    pf::PTDFDCPowerFlow,
    sys::PSY.System
) -&gt; PTDFPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a Partial Transfer Distribution Factor Matrix DC power flow calculation, given the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>. Configuration options like <code>time_steps</code>, <code>time_step_names</code>, <code>network_reductions</code>, and <code>correct_bustypes</code> are taken from the <a href="../public/#PowerFlows.PTDFDCPowerFlow"><code>PTDFDCPowerFlow</code></a> object.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="../public/#PowerFlows.PTDFDCPowerFlow"><code>PTDFDCPowerFlow</code></a>: this version is used to solve DC power flows via the Power Transfer Distribution Factor (PTDF) matrix. This function returns a <a href="#PowerFlows.PTDFPowerFlowData"><code>PTDFPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="../public/#PowerFlows.PTDFDCPowerFlow"><code>pf::PTDFDCPowerFlow</code></a>:       Run a DC power flow with PTDF matrix: internally, store the PTDF matrix       as <code>power_network_matrix</code> and the ABA matrix as <code>aux_network_matrix</code>.       Configuration options are taken from this object.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power       grid under consideration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L534-L559">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    pf::vPTDFDCPowerFlow,
    sys::PSY.System
) -&gt; vPTDFPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a virtual Partial Transfer Distribution Factor Matrix DC power flow calculation, given the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>. Configuration options like <code>time_steps</code>, <code>time_step_names</code>, <code>network_reductions</code>, and <code>correct_bustypes</code> are taken from the <a href="../public/#PowerFlows.vPTDFDCPowerFlow"><code>vPTDFDCPowerFlow</code></a> object.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="../public/#PowerFlows.vPTDFDCPowerFlow"><code>vPTDFDCPowerFlow</code></a>: this version is used to solve DC power flows using a virtual Power Transfer Distribution Factor (PTDF) matrix. This function returns a <a href="#PowerFlows.vPTDFPowerFlowData"><code>vPTDFPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="../public/#PowerFlows.vPTDFDCPowerFlow"><code>pf::vPTDFDCPowerFlow</code></a>:       Run a virtual PTDF power flow: internally, store the virtual PTDF matrix as       <code>power_network_matrix</code> and the ABA matrix as <code>aux_network_matrix</code>.       Configuration options are taken from this object.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power       grid under consideration.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L579-L604">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64}} where {T&lt;:PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64}} where {T&lt;:PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the two <code>PowerNetworkMatrix</code> fields and a few others (<code>time_steps</code>, <code>time_step_map</code>),  then creates arrays of default values (usually zeros) for the rest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L289-L292">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.SystemPowerFlowContainer"><a class="docstring-binding" href="#PowerFlows.SystemPowerFlowContainer"><code>PowerFlows.SystemPowerFlowContainer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A <code>PowerFlowContainer</code> that represents its data as a <code>PSY.System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.vPTDFPowerFlowData"><a class="docstring-binding" href="#PowerFlows.vPTDFPowerFlowData"><code>PowerFlows.vPTDFPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>vPTDFDCPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L153-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.make_power_flow_container"><a class="docstring-binding" href="#PowerFlows.make_power_flow_container"><code>PowerFlows.make_power_flow_container</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Create an appropriate <code>PowerFlowContainer</code> for the given <code>PowerFlowEvaluationModel</code> and initialize it from the given <code>PSY.System</code>.</p><p>Configuration options like <code>time_steps</code>, <code>time_step_names</code>, <code>network_reductions</code>, and <code>correct_bustypes</code> are taken from the <code>PowerFlowEvaluationModel</code> object.</p><p><strong>Arguments:</strong></p><ul><li><code>pfem::PowerFlowEvaluationModel</code>: power flow model to construct a container for (e.g., <code>DCPowerFlow()</code>)</li><li><code>sys::PSY.System</code>: the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System">System</a> from which to initialize the   power flow container</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L625-L635">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><a class="docstring-binding" href="#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><code>PowerFlows.supports_multi_period</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Trait signifying whether the <code>PowerFlowContainer</code> can represent multi-period data. Must be implemented for all concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/PowerFlowData.jl#L3-L6">source</a></section></details></article><h2 id="Solving-a-PowerFlowData-instance"><a class="docs-heading-anchor" href="#Solving-a-PowerFlowData-instance">Solving a PowerFlowData instance</a><a id="Solving-a-PowerFlowData-instance-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-a-PowerFlowData-instance" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}}"><a class="docstring-binding" href="#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}}"><code>PowerFlows.solve_power_flow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_power_flow!(data::ACPowerFlowData; kwargs...)</code></pre><p>Solve the multiperiod AC power flow problem for the given power flow data.</p><p>The bus types can be changed from PV to PQ if the reactive power limits are violated. The power flow solver settings are taken from the <code>ACPowerFlow</code> object stored in <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><a href="#PowerFlows.ACPowerFlowData"><code>data::ACPowerFlowData</code></a>: The power flow data containing the grid information and initial conditions.</li><li><code>kwargs...</code>: Additional keyword arguments. If these overlap with those in the    <code>solver_settings</code> of the <code>ACPowerFlow</code> object, the values in <code>kwargs</code> take precedence.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>time_steps</code>: Specifies the time steps to solve. Defaults to sorting and collecting the keys of <code>get_time_step_map(data)</code>.</li></ul><p><strong>Description</strong></p><p>This function solves the AC power flow problem for each time step specified in <code>data</code>. It preallocates memory for the results and iterates over the sorted time steps.     For each time step, it calls the <code>_ac_power_flow</code> function to solve the power flow equations and updates the <code>data</code> object with the results.     If the power flow converges, it updates the active and reactive power injections, as well as the voltage magnitudes and angles for different bus types (REF, PV, PQ).     If the power flow does not converge, it sets the corresponding entries in <code>data</code> to <code>NaN</code>.     Finally, it calculates the branch power flows and updates the <code>data</code> object.</p><p><strong>Notes</strong></p><ul><li>If the grid topology changes (e.g., tap positions of transformers or in-service status of branches), the admittance matrices <code>Yft</code> and <code>Ytf</code> must be updated.</li><li>If <code>Yft</code> and <code>Ytf</code> change between time steps, the branch flow calculations must be moved inside the loop.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">solve_power_flow!(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/solve_ac_power_flow.jl#L104-L136">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.adjust_power_injections_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><a class="docstring-binding" href="#PowerFlows.adjust_power_injections_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><code>PowerFlows.adjust_power_injections_for_lccs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Adjust the power injections vector to account for the power flows through LCCs.</p><p>Relies on the fact that we calculate those flows during initialization and save them to the <code>active_power_flow_from_to</code> and <code>active_power_flow_to_from</code> fields of the <code>LCCParameters</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/solve_dc_power_flow.jl#L1-L7">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><a class="docstring-binding" href="#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><code>PowerFlows.solve_power_flow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_power_flow!(data::PTDFPowerFlowData)</code></pre><p>Evaluates the PTDF power flow and writes the result to the fields of the  <a href="#PowerFlows.PTDFPowerFlowData"><code>PTDFPowerFlowData</code></a> structure.</p><p>This function modifies the following fields of <code>data</code>, setting them to the computed values:</p><ul><li><code>data.bus_angles</code>: the bus angles for each bus in the system.</li><li><code>data.branch_active_power_flow_from_to</code>: the active power flow from the &quot;from&quot; bus to the &quot;to&quot; bus of each branch</li><li><code>data.branch_active_power_flow_to_from</code>: the active power flow from the &quot;to&quot; bus to the &quot;from&quot; bus of each branch</li></ul><p>Additionally, it sets <code>data.converged</code> to <code>true</code>, indicating that the power flow calculation was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/solve_dc_power_flow.jl#L22-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{vPTDFDCPowerFlow, &lt;:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><a class="docstring-binding" href="#PowerFlows.solve_power_flow!-Tuple{PowerFlows.PowerFlowData{vPTDFDCPowerFlow, &lt;:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><code>PowerFlows.solve_power_flow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_power_flow!(data::vPTDFPowerFlowData)</code></pre><p>Evaluates the virtual PTDF power flow and writes the results to the fields  of the <a href="#PowerFlows.vPTDFPowerFlowData"><code>vPTDFPowerFlowData</code></a> structure.</p><p>This function modifies the following fields of <code>data</code>, setting them to the computed values:</p><ul><li><code>data.bus_angles</code>: the bus angles for each bus in the system.</li><li><code>data.branch_active_power_flow_from_to</code>: the active power flow from the &quot;from&quot; bus to the &quot;to&quot; bus of each branch</li><li><code>data.branch_active_power_flow_to_from</code>: the active power flow from the &quot;to&quot; bus to the &quot;from&quot; bus of each branch</li></ul><p>Additionally, it sets <code>data.converged</code> to <code>true</code>, indicating that the power flow calculation was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/solve_dc_power_flow.jl#L55-L68">source</a></section></details></article><h2 id="Manipulating-a-PowerFlowData-instance"><a class="docs-heading-anchor" href="#Manipulating-a-PowerFlowData-instance">Manipulating a PowerFlowData instance</a><a id="Manipulating-a-PowerFlowData-instance-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-a-PowerFlowData-instance" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.partition_state-Tuple{Vector{Float64}, AbstractVector{ACBusTypes}}"><a class="docstring-binding" href="#PowerFlows.partition_state-Tuple{Vector{Float64}, AbstractVector{ACBusTypes}}"><code>PowerFlows.partition_state</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Partitions the state vector&#39;s variables based on what physical quantity each represents.  Returns a <code>NamedTuple</code>, with the 4 keys <code>Va</code>, <code>Vm</code>, <code>P</code>, and <code>Q</code>. The 4 values are vectors  of length equal to the number of buses, with <code>NaN</code>s in the positions where that physical  quantity is not part of the state vector for that bus. (Currently not intended for use in  spots where performance is critical.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/state_indexing_helpers.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_data!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.update_data!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Float64}, Int64}"><code>PowerFlows.update_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the fields of data based on the values of the state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/state_indexing_helpers.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_net_power!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, AbstractVector{ACBusTypes}}"><a class="docstring-binding" href="#PowerFlows.update_net_power!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, AbstractVector{ACBusTypes}}"><code>PowerFlows.update_net_power!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update <code>P_net</code> and <code>Q_net</code> based on the values of the state vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/state_indexing_helpers.jl#L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_state!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.update_state!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.update_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update state vector based on values of fields of data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/state_indexing_helpers.jl#L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_power_flow_data!-Tuple{PowerFlows.PowerFlowData, PowerFlowEvaluationModel, System}"><a class="docstring-binding" href="#PowerFlows.initialize_power_flow_data!-Tuple{PowerFlows.PowerFlowData, PowerFlowEvaluationModel, System}"><code>PowerFlows.initialize_power_flow_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the fields of a PowerFlowData struct to match the given System.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/initialize_power_flow_data.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._dc_power_flow_fallback!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._dc_power_flow_fallback!-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows._dc_power_flow_fallback!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>When solving AC power flows, if the initial guess has large residual, we run a DC power  flow as a fallback. This runs a DC power flow on <code>data::ACPowerFlowData</code> for the given <code>time_step</code>, and writes the solution to <code>data.bus_angles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_setup.jl#L110-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.calculate_x0-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.calculate_x0-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.calculate_x0</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate x0 from data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_setup.jl#L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.dc_power_flow_start!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, PowerFlows.ACPowerFlowResidual}"><a class="docstring-binding" href="#PowerFlows.dc_power_flow_start!-Tuple{Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, PowerFlows.ACPowerFlowResidual}"><code>PowerFlows.dc_power_flow_start!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If initial residual is large, run a DC power flow and see if that gives a better starting point for angles. If so, then overwrite <code>x0</code> with the result of the DC power flow. If not, keep the original <code>x0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_setup.jl#L64-L67">source</a></section></details></article><h1 id="LCC-HVDC-Parameters-and-Utilities"><a class="docs-heading-anchor" href="#LCC-HVDC-Parameters-and-Utilities">LCC HVDC Parameters and Utilities</a><a id="LCC-HVDC-Parameters-and-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#LCC-HVDC-Parameters-and-Utilities" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dV_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dV_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to voltage magnitude Vm for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dt_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dt_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to transformer tap t for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><code>PowerFlows._calculate_dQ_dα_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dα_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64, α::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to firing/extinction angle α for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L57-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><code>PowerFlows._calculate_y_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_y_lcc(t::Float64, I_dc::Float64, Vm::Float64, ϕ::Float64) -&gt; ComplexF64</code></pre><p>Compute the admittance value Y for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_ϕ_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_ϕ_lcc(α::Float64, I_dc::Float64, x_t::Float64, Vm::Float64) -&gt; Float64</code></pre><p>Compute the phase angle ϕ for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.hvdc_fixed_injections!-Tuple{PowerFlows.PowerFlowData, Type{&lt;:TwoTerminalHVDC}, System, Dict{Int64, Int64}, Dict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows.hvdc_fixed_injections!-Tuple{PowerFlows.PowerFlowData, Type{&lt;:TwoTerminalHVDC}, System, Dict{Int64, Int64}, Dict{Int64, Int64}}"><code>PowerFlows.hvdc_fixed_injections!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Adjust the power injections/withdrawal vectors to account for all HVDC lines of a given type, modeling those HVDC lines as a simple fixed injection/withdrawal at each terminal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L222-L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlows.PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlows.PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><code>PowerFlows.initialize_LCC_arcs_and_buses!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Initialize the <code>arcs</code> and <code>bus_indices</code> fields of the LCCParameters structure in the PowerFlowData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/lcc_utils.jl#L107-L109">source</a></section></details></article><h1 id="AC-Power-Flow"><a class="docs-heading-anchor" href="#AC-Power-Flow">AC Power Flow</a><a id="AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#AC-Power-Flow" title="Permalink"></a></h1><h2 id="Residuals"><a class="docs-heading-anchor" href="#Residuals">Residuals</a><a id="Residuals-1"></a><a class="docs-heading-anchor-permalink" href="#Residuals" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowResidual</code></pre><p>A struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data.</li><li><code>Rf!::Function</code>: A function that updates the residuals based on the latest values stored in the grid at the given iteration.</li><li><code>Rv::Vector{Float64}</code>: A vector of the values of the residuals.</li><li><code>P_net::Vector{Float64}</code>: A vector of net active power injections.</li><li><code>Q_net::Vector{Float64}</code>: A vector of net reactive power injections.</li><li><code>P_net_set::Vector{Float64}</code>: A vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: A sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>subnetworks::Dict{Int64, Vector{Int64}}</code>: The dictionary that identifies subnetworks (connected components), with the key defining the REF bus, values defining the corresponding buses in the subnetwork.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_residual.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)</code></pre><p>Create an instance of <code>ACPowerFlowResidual</code> for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data representing the power system model.</li><li><code>time_step::Int64</code>: The time step for which the power flow calculation is executed.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowResidual</code>: An instance containing the residual values, net bus active power injections,    and net bus reactive power injections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_residual.jl#L27-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)</code></pre><p>Update the AC power flow residuals inplace and store the result in the attribute <code>Rv</code> of the struct. The inputs are the values of state vector <code>x</code> and the current time step <code>time_step</code>. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The state vector values.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_residual.jl#L147-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)</code></pre><p>Evaluate the AC power flow residuals and store the result in <code>Rv</code> using the provided state vector <code>x</code> and the current time step <code>time_step</code>. The residuals are updated inplace in the struct and additionally copied to the provided array. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>Rv::Vector{Float64}</code>: The vector to store the calculated residuals.</li><li><code>x::Vector{Float64}</code>: The state vector.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_residual.jl#L112-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows._update_residual_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_residual_values!(
    F::Vector{Float64},
    x::Vector{Float64},
    P_net::Vector{Float64},
    Q_net::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64,
)</code></pre><p>Update the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the <code>ACPowerFlowResidual</code> struct. This function also updates the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>F::Vector{Float64}</code>: Vector of the values of the residuals.</li><li><code>x::Vector{Float64}</code>: State vector values.</li><li><code>P_net::Vector{Float64}</code>: Vector of net active power injections at each bus.</li><li><code>Q_net::Vector{Float64}</code>: Vector of net reactive power injections at each bus.</li><li><code>P_net_set::Vector{Float64}</code>: Vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: Sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>ref_bus::Int</code>: The index of the reference bus to be used for the total slack power.</li><li><code>data::ACPowerFlowData</code>: Data structure representing the grid model for the AC power flow calculation.</li><li><code>time_step::Int64</code>: The current time step for which the residual values are being updated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_residual.jl#L274-L297">source</a></section></details></article><h2 id="Jacobian"><a class="docs-heading-anchor" href="#Jacobian">Jacobian</a><a id="Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Jacobian" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowJacobian</code></pre><p>A struct that represents the Jacobian matrix for AC power flow calculations.</p><p>This struct uses the functor pattern, meaning instances of <code>ACPowerFlowJacobian</code> store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data used for power flow calculations.</li><li><code>Jf!::Function</code>: A function that calculates the Jacobian matrix inplace.</li><li><code>Jv::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix, which is updated by the function <code>Jf!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(time_step::Int64)</code></pre><p>Update the Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step.</p><p>Defining this method allows an instance of <code>ACPowerFlowJacobian</code> to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
J(time_step)  # Updates the Jacobian matrix Jv</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L22-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -&gt; ACPowerFlowJacobian</code></pre><p>This is the constructor for ACPowerFlowJacobian. Create an <code>ACPowerFlowJacobian</code> instance. As soon as the instance is created, it already has  the Jacobian matrix structure initialized and its values updated, stored internally as <code>Jv</code>. The data instance is stored internally and used to update the Jacobian matrix because the  structure of the Jacobian matrix is tied to the data. Changing the data requires creating a  new instance of <code>ACPowerFlowJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data used for power flow calculations.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowJacobian</code>: An instance of <code>ACPowerFlowJacobian</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.
J(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.
J.Jv  # Access the Jacobian matrix stored internally in J.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L72-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)</code></pre><p>Use the <code>ACPowerFlowJacobian</code> to update the provided Jacobian matrix <code>J</code> inplace.</p><p>Update the internally stored Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step, and write the updated Jacobian values to <code>J</code>.</p><p>This method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix to be updated with new values of the Jacobian matrix.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
Jv = SparseArrays.sparse(Float64[], J_INDEX_TYPE[], J_INDEX_TYPE[])
J(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L43-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><a class="docstring-binding" href="#PowerFlows._block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><code>PowerFlows._block_J_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_block_J_indices(data::ACPowerFlowData, time_step::Int) -&gt; (Vector{Int32}, Vector{Int32})</code></pre><p>Get the indices to reindex the Jacobian matrix from the interleaved form to the block form:</p><p class="math-container">\[\begin{bmatrix}
\frac{\partial P}{\partial \theta} &amp; \frac{\partial P}{\partial V} \\
\frac{\partial Q}{\partial \theta} &amp; \frac{\partial Q}{\partial V}
\end{bmatrix}\]</p><p><strong>Arguments</strong></p><ul><li><code>pvpq::Vector{Int32}</code>: Indices of the buses that are PV or PQ buses.</li><li><code>pq::Vector{Int32}</code>: Indices of the buses that are PQ buses.</li></ul><p><strong>Returns</strong></p><ul><li><code>rows::Vector{Int32}</code>: Row indices for the block Jacobian matrix.</li><li><code>cols::Vector{Int32}</code>: Column indices for the block Jacobian matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L734-L753">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_loss_factors-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_loss_factors-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows._calculate_loss_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)</code></pre><p>Calculate and store the active power loss factors in the <code>loss_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step.</p><p>The loss factors are computed using the Jacobian matrix <code>Jv</code> and the vector <code>dSbus_dV_ref</code>, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injections as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data structure containing power flow information, including the <code>loss_factors</code> matrix.</li><li><code>Jv::SparseMatrixCSC{Float64, Int32}</code>: The sparse Jacobian matrix of the power flow system.</li><li><code>time_step::Int</code>: The time step index for which the loss factors are calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L660-L674">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_voltage_stability_factors-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._calculate_voltage_stability_factors-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._calculate_voltage_stability_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_voltage_stability_factors(data::ACPowerFlowData, J::ACPowerFlowJacobian, time_step::Integer)</code></pre><p>Calculate and store the voltage stability factors in the <code>voltage_stability_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step. The voltage stability factors are computed using the Jacobian matrix <code>J</code> in block format after a converged power flow calculation.  The results are stored in the <code>voltage_stability_factors</code> matrix in the <code>data</code> instance. The factor for the grid as a whole (σ) is stored in the position of the REF bus. The values of the singular vector <code>v</code> indicate the sensitivity of the buses and are stored in the positions of the PQ buses. The values of <code>v</code> for PV buses are set to zero.  The function uses the method described in &quot;Fast calculation of a voltage stability index&quot; by PA Lof et. al.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The instance containing the grid model data.</li><li><code>J::ACPowerFlowJacobian</code>: The Jacobian matrix cache.</li><li><code>time_step::Integer</code>: The calculated time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L701-L715">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -&gt; SparseMatrixCSC{Float64, Int32}</code></pre><p>Create the structure of the Jacobian matrix for an AC power flow problem.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow model.</li><li><code>time_step::Int64</code>: The specific time step for which the Jacobian matrix structure is created.</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.</li></ul><p><strong>Description</strong></p><p>This function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.</p><p>Unlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus.</p><p>This approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.</p><p>The function initializes three arrays (<code>rows</code>, <code>columns</code>, and <code>values</code>) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.</p><p>For each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (<code>REF</code>, <code>PV</code>, or <code>PQ</code>).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.</p><ul><li>For <code>REF</code> buses, entries are added for local active and reactive power.</li><li>For <code>PV</code> buses, entries are added for active and reactive power with respect to angle, and for local reactive power.</li><li>For <code>PQ</code> buses, entries are added for active and reactive power with respect to voltage magnitude and angle.</li></ul><p><strong>Example Structure</strong></p><p>For a system with 3 buses where bus 1 is <code>REF</code>, bus 2 is <code>PV</code>, and bus 3 is <code>PQ</code>:</p><p>Let <span>$\Delta P_j$</span>, <span>$\Delta Q_j$</span> be the active, reactive power balance at the <span>$j$</span>th bus. Let <span>$P_j$</span> and <span>$Q_j$</span> be the active and reactive power generated at the <span>$j$</span>th bus (<code>REF</code> and <code>PV</code> only). The state vector is <span>$x = [P_1, Q_1, Q_2, \theta_2, V_3, \theta_3]$</span>, and the residual vector is <span>$F(x) = [\Delta P_1, \Delta Q_1, \Delta P_2, \Delta Q_2, \Delta P_3, \Delta Q_3]$</span>.</p><p>The Jacobian matrix <span>$J = \nabla F(x)$</span> has the structure:</p><p class="math-container">\[J = \begin{bmatrix}
\frac{\partial \vec{F}}{\partial P_1} &amp; 
\frac{\partial \vec{F}}{\partial Q_1} &amp; 
\frac{\partial \vec{F}}{\partial Q_2} &amp; 
\frac{\partial \vec{F}}{\partial \theta_2} &amp; 
\frac{\partial \vec{F}}{\partial V_3} &amp; 
\frac{\partial \vec{F}}{\partial \theta_3}
\end{bmatrix}\]</p><p>In reality, for large networks, this matrix would be sparse, and each 2×2 block would only be nonzero when there&#39;s a line between the respective buses.</p><p>Finally, the function constructs a sparse matrix from the collected indices and values and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L306-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PV bus. Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L137-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a reference bus (REF). Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L110-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn&#39;t matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -&gt; PQ transition and then we need to fill all four values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L168-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure_lcc(
    data::ACPowerFlowData,
    rows::Vector{Int32},
    columns::Vector{Int32},
    values::Vector{Float64},
    num_buses::Int
)</code></pre><p>Create the Jacobian matrix structure for LCC HVDC systems.</p><p><strong>Description</strong></p><p>The function iterates over each LCC system and adds the non-zero entries to the Jacobian matrix structure. The state vector for every LCC contains 4 variables: tap position and thyristor angle for both the rectifier and inverter sides. The indices of non-zero entries correspond to the positions of these variables in the extended state vector.</p><p>For an LCC system connecting bus <span>$i$</span> (rectifier side) and bus <span>$j$</span> (inverter side), the state variables are:</p><ul><li><span>$t_i$</span>: tap position at rectifier</li><li><span>$t_j$</span>: tap position at inverter  </li><li><span>$\alpha_i$</span>: thyristor angle at rectifier</li><li><span>$\alpha_j$</span>: thyristor angle at inverter</li></ul><p>The residuals include:</p><ul><li><span>$F_{t_i}$</span>: Active power balance at rectifier (controls <span>$P_i$</span> to match setpoint)</li><li><span>$F_{t_j}$</span>: Total active power balance across LCC system</li><li><span>$F_{\alpha_i}$</span>: Rectifier thyristor angle constraint (maintains <span>$\alpha_i$</span> at minimum)</li><li><span>$F_{\alpha_j}$</span>: Inverter thyristor angle constraint (maintains <span>$\alpha_j$</span> at minimum)</li></ul><p><strong>Example Structure</strong></p><p>For a system with 2 buses connected by one LCC where bus 1 is the rectifier side and bus 2 is the inverter side, the Jacobian matrix would have non-zero entries at positions like:</p><p class="math-container">\[\begin{array}{c|cccccccc}
 &amp; V_1 &amp; \delta_1 &amp; V_2 &amp; \delta_2 &amp; t_1 &amp; t_2 &amp; \alpha_1 &amp; \alpha_2 \\
\hline
P_1 &amp; \frac{\partial P_1}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial P_1}{\partial t_1} &amp; &amp; \frac{\partial P_1}{\partial \alpha_1} &amp; \\
Q_1 &amp; \frac{\partial Q_1}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial Q_1}{\partial t_1} &amp; &amp; \frac{\partial Q_1}{\partial \alpha_1} &amp; \\
P_2 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
Q_2 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
F_{t_1} &amp; \frac{\partial F_{t_1}}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial F_{t_1}}{\partial t_1} &amp; &amp; \frac{\partial F_{t_1}}{\partial \alpha_1} &amp; \\
F_{t_2} &amp; \frac{\partial F_{t_2}}{\partial V_1} &amp; &amp; \frac{\partial F_{t_2}}{\partial V_2} &amp; &amp; \frac{\partial F_{t_2}}{\partial t_1} &amp; \frac{\partial F_{t_2}}{\partial t_2} &amp; \frac{\partial F_{t_2}}{\partial \alpha_1} &amp; \frac{\partial F_{t_2}}{\partial \alpha_2} \\
F_{\alpha_1} &amp; &amp; &amp; &amp; &amp; &amp; &amp; \frac{\partial F_{\alpha_1}}{\partial \alpha_1} &amp; \\
F_{\alpha_2} &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \frac{\partial F_{\alpha_2}}{\partial \alpha_2}
\end{array}\]</p><p>This function sets up the indices of these non-zero entries in the sparse Jacobian matrix structure.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data containing LCC system information.</li><li><code>rows::Vector{Int32}</code>: Vector to store row indices of non-zero Jacobian entries.</li><li><code>columns::Vector{Int32}</code>: Vector to store column indices of non-zero Jacobian entries.</li><li><code>values::Vector{Float64}</code>: Vector to store initial values of non-zero Jacobian entries.</li><li><code>num_buses::Int</code>: Total number of buses in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L203-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._singular_value_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_singular_value_decomposition(J::SparseMatrixCSC{Float64, Int32}, npvpq::Integer; tol::Float64 = 1e-9, max_iter::Integer = 100,)</code></pre><p>Estimate the smallest singular value <code>σ</code> and corresponding left and right singular vectors <code>u</code> and <code>v</code> of a sparse matrix <code>G_s</code> (a sub-matrix of <code>J</code>). This function uses an iterative method involving LU factorization of the Jacobian matrix to estimate the smallest singular value of <code>G_s</code>.  The algorithm alternates between updating <code>u</code> and <code>v</code>, normalizing, and checking for convergence based on the change in the estimated singular value <code>σ</code>. The function uses the method described in <code>Algorithm 3</code> of &quot;Fast calculation of a voltage stability index&quot; by PA Lof et. al.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64, Int32}</code>: The sparse block-form Jacobian matrix.</li><li><code>npvpq::Integer</code>: Number of PV and PQ buses in J.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tol::Float64=1e-9</code>: Convergence tolerance for the iterative algorithm.</li><li><code>max_iter::Integer=100</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>σ::Float64</code>: The estimated smallest singular value.</li><li><code>left::Vector{Float64}</code>: The estimated left singular vector (referred to as <code>u</code> in the cited paper).</li><li><code>right::Vector{Float64}</code>: The estimated right singular vector (referred to as <code>v</code> in the cited paper).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L761-L781">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, StaticArraysCore.MVector{4, Float64}}"><a class="docstring-binding" href="#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64, StaticArraysCore.MVector{4, Float64}}"><code>PowerFlows._update_jacobian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Used to update Jv based on the bus voltages, angles, etc. in data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/ac_power_flow_jacobian.jl#L569">source</a></section></details></article><h2 id="Iterative-Methods"><a class="docs-heading-anchor" href="#Iterative-Methods">Iterative Methods</a><a id="Iterative-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Iterative-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.StateVectorCache"><a class="docstring-binding" href="#PowerFlows.StateVectorCache"><code>PowerFlows.StateVectorCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Cache for non-linear methods.</p><p><strong>Fields</strong></p><ul><li><code>x::Vector{Float64}</code>: the current state vector.</li><li><code>r::Vector{Float64}</code>: the current residual.</li><li><code>Δx_nr::Vector{Float64}</code>: the step under the Newton-Raphson method.</li></ul><p>The remainder of the fields are only used in the <code>TrustRegionACPowerFlow</code>:</p><ul><li><code>r_predict::Vector{Float64}</code>: the predicted residual at <code>x+Δx_proposed</code>,   under a linear approximation: i.e <code>J_x⋅(x+Δx_proposed)</code>.</li><li><code>Δx_proposed::Vector{Float64}</code>: the suggested step <code>Δx</code>, selected among <code>Δx_nr</code>,    <code>Δx_cauchy</code>, and the dogleg interpolation between the two. The first is chosen when   <code>x+Δx_nr</code> is inside the trust region, the second when both <code>x+Δx_cauchy</code>   and <code>x+Δx_nr</code> are outside the trust region, and the third when <code>x+Δx_cauchy</code>   is inside and <code>x+Δx_nr</code> outside. The dogleg step selects the point where the line   from <code>x+Δx_cauchy</code> to <code>x+Δx_nr</code> crosses the boundary of the trust region.</li><li><code>Δx_cauchy::Vector{Float64}</code>: the step to the Cauchy point if the Cauchy point   lies within the trust region, otherwise a step in that direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><code>PowerFlows._do_refinement!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check error and do refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><a class="docstring-binding" href="#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><code>PowerFlows._dogleg!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets <code>Δx_proposed</code> equal to the <code>Δx</code> by which we should update <code>x</code>. Decides between the Cauchy step <code>Δx_cauchy</code>, Newton-Raphson step <code>Δx_nr</code>, and the dogleg interpolation between the two, based on which fall within the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L113-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><code>PowerFlows._run_power_flow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>NewtonRaphsonACPowerFlow</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>norm(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>refinement_threshold::Float64</code>: If the solution to <code>J_x Δx = r</code> satisfies   <code>norm(J_x Δx - r, 1)/norm(r, 1) &gt; refinement_threshold</code>, do iterative refinement to   improve the accuracy. Default: 0.05.</li><li><code>refinement_eps::Float64</code>: run iterative refinement on <code>J_x Δx = r</code> until   <code>norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) &lt; refinement_eps</code>. Default:    1.0e-6 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L284-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_power_flow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><code>PowerFlows._run_power_flow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>TrustRegionNRMethod</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>maximum(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>factor::Float64</code>: the trust region starts out with radius <code>factor*norm(x_0, 1)</code>,   where <code>x_0</code> is our initial guess, taken from <code>data</code>. Default: 1.0.</li><li><code>eta::Float64</code>: improvement threshold. If the observed improvement in our residual   exceeds <code>eta</code> times the predicted improvement, we accept the new <code>x_i</code>.   Default: 0.0001.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L339-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><code>PowerFlows._set_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the Newton-Raphson step. Usually, this is just <code>J.Jv \ stateVector.r</code>, but <code>J.Jv</code> might be singular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L67-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._simple_step"><a class="docstring-binding" href="#PowerFlows._simple_step"><code>PowerFlows._simple_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Does a single iteration of <code>NewtonRaphsonACPowerFlow</code>. Updates the <code>r</code> and <code>x</code> fields of the <code>stateVector</code>, and computes the Jacobian at the new <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L255-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><code>PowerFlows._singular_J_fallback</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a stand-in matrix for singular J&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><a class="docstring-binding" href="#PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><code>PowerFlows._solve_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solve for the Newton-Raphson step, given the factorization object for <code>J.Jv</code>  (if non-singular) or its stand-in (if singular).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L38-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><a class="docstring-binding" href="#PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><code>PowerFlows._trust_region_step</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does a single iteration of the <code>TrustRegionNRMethod</code>: updates the <code>x</code> and <code>r</code> fields of the <code>stateVector</code> and computes the value of the Jacobian at the new <code>x</code>, if needed. Unlike  <code>_simple_step</code>, this has a return value, the updated value of <code>delta</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/power_flow_method.jl#L166-L170">source</a></section></details></article><h2 id="Robust-Homotopy-Method"><a class="docs-heading-anchor" href="#Robust-Homotopy-Method">Robust Homotopy Method</a><a id="Robust-Homotopy-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Homotopy-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><a class="docstring-binding" href="#PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><code>PowerFlows.HomotopyHessian</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute value of gradient and Hessian at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/RobustHomotopy/homotopy_hessian.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>PowerFlows.A_plus_eq_BT_B!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does <code>A += B&#39; * B</code>, in a way that preserves the sparse structure of <code>A</code>, if possible. A workaround for the fact that Julia seems to run <code>dropzeros!(A)</code> automatically if I just  do <code>A .+= B&#39; * B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/RobustHomotopy/homotopy_hessian.jl#L11-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows._update_hessian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_hessian_matrix_values!(
    Hv::SparseMatrixCSC{Float64, Int32},
    F_value::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64
)</code></pre><p>Update the Hessian matrix values for the robust homotopy power flow solver.</p><p><strong>Description</strong></p><p>This function sets <code>Hv</code> equal to:</p><p class="math-container">\[\sum_{k=1}^{2n} F_k(x) H_{F_k}(x)\]</p><p>where <span>$F_k$</span> denotes the <span>$k$</span>th power balance equation and <span>$H_{F_k}$</span> denotes its Hessian matrix.</p><p>This computes only the terms in the Hessian that come from the second derivatives of the power balance equations.  The full Hessian of the objective function also includes a <span>$J^T J$</span> term, which is computed separately.</p><p><strong>Sparse Structure</strong></p><p>The Hessian is organized into 2×2 blocks, each corresponding to a pair of buses. For a pair of buses <span>$i$</span> and <span>$k$</span>  connected by a branch, the sparse structure of their block depends on the bus types:</p><p class="math-container">\[\begin{array}{c|cc|cc|cc}
 &amp; \text{REF} &amp; &amp; \text{PV} &amp; &amp; \text{PQ} &amp; \\
 &amp; P_i &amp; Q_i &amp; Q_i &amp; V_i &amp; V_i &amp; \theta_i \\
\hline
\text{REF: } P_k &amp; &amp; &amp; &amp; &amp; &amp; \\
Q_k &amp; &amp; &amp; &amp; &amp; &amp; \\
\hline
\text{PV: } Q_k &amp; &amp; &amp; &amp; &amp; &amp; \\
V_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet \\
\hline
\text{PQ: } V_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet \\
\theta_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet
\end{array}\]</p><p>where <span>$\bullet$</span> represents a potentially non-zero entry.</p><p>Diagonal blocks (where <span>$i = k$</span>) follow the same pattern as if each bus is its own neighbor. Off-diagonal blocks for pairs of buses not connected by a branch are structurally zero.</p><p><strong>Arguments</strong></p><ul><li><code>Hv::SparseMatrixCSC{Float64, Int32}</code>: The Hessian matrix to be updated (modified in-place).</li><li><code>F_value::Vector{Float64}</code>: Current values of the power balance residuals.</li><li><code>data::ACPowerFlowData</code>: The power flow data containing bus and network information.</li><li><code>time_step::Int64</code>: The time step for which to compute the Hessian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/RobustHomotopy/homotopy_hessian.jl#L129-L183">source</a></section></details></article><h2 id="Levenberg-Marquardt-Method"><a class="docs-heading-anchor" href="#Levenberg-Marquardt-Method">Levenberg-Marquardt Method</a><a id="Levenberg-Marquardt-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Levenberg-Marquardt-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._newton_power_flow-Tuple{ACPowerFlow{LevenbergMarquardtACPowerFlow}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows._newton_power_flow-Tuple{ACPowerFlow{LevenbergMarquardtACPowerFlow}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows._newton_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Driver for the LevenbergMarquardtACPowerFlow method: sets up the data  structures (e.g. residual), runs the power flow method via calling <code>_run_power_flow_method</code>  on them, then handles post-processing (e.g. loss factors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/levenberg-marquardt.jl#L1-L4">source</a></section></details></article><h1 id="Linear-Algebra-Backends"><a class="docs-heading-anchor" href="#Linear-Algebra-Backends">Linear Algebra Backends</a><a id="Linear-Algebra-Backends-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Algebra-Backends" title="Permalink"></a></h1><h2 id="Robust-Homotopy"><a class="docs-heading-anchor" href="#Robust-Homotopy">Robust Homotopy</a><a id="Robust-Homotopy-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Homotopy" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.FixedStructureCHOLMOD"><a class="docstring-binding" href="#PowerFlows.FixedStructureCHOLMOD"><code>PowerFlows.FixedStructureCHOLMOD</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>In order to in-place modify the numeric values of a CHOLMOD matrix, we need to  write our own wrapper around <code>CHOLMOD.Sparse</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/RobustHomotopy/HessianSolver/fixed_structure_CHOLMOD.jl#L1-L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.set_values!-Union{Tuple{I}, Tuple{T}, Tuple{PowerFlows.FixedStructureCHOLMOD{T, I}, AbstractVector{T}}} where {T&lt;:Union{Float32, Float64}, I&lt;:Union{Int32, Int64}}"><a class="docstring-binding" href="#PowerFlows.set_values!-Union{Tuple{I}, Tuple{T}, Tuple{PowerFlows.FixedStructureCHOLMOD{T, I}, AbstractVector{T}}} where {T&lt;:Union{Float32, Float64}, I&lt;:Union{Int32, Int64}}"><code>PowerFlows.set_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_values!(mat::FixedStructureCHOLMOD, new_vals::AbstractVector{Float64})</code></pre><p>In-place update of the numeric values in the CHOLMOD matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/RobustHomotopy/HessianSolver/fixed_structure_CHOLMOD.jl#L25-L28">source</a></section></details></article><h2 id="Newton-Raphson"><a class="docs-heading-anchor" href="#Newton-Raphson">Newton-Raphson</a><a id="Newton-Raphson-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-Raphson" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.KLULinSolveCache"><a class="docstring-binding" href="#PowerFlows.KLULinSolveCache"><code>PowerFlows.KLULinSolveCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A cached linear solver using KLU. Carefully written so as to minimize allocations: <code>solve!</code> and <code>numeric_refactor!</code> are completely non-allocating.</p><p><strong>Fields:</strong></p><ul><li><code>K</code>: the underlying KLU object.</li><li><code>reuse_symbolic::Bool</code>: reuse the symbolic factorization. Defaults to <code>true</code>.</li><li><code>check_pattern::Bool</code>: if true, <code>numeric_refactor!</code> verifies that the new   matrix has the same sparsity structure. Defaults to <code>true</code>.</li><li><code>rf_common</code>, <code>rf_symbolic</code>, <code>rf_numeric</code>: internal usage. Stored to avoid allocations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/klu_linear_solver.jl#L25-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.KLULinSolveCache</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/klu_linear_solver.jl#L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.numeric_refactor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Frees numeric factorization stored by <code>cache</code>, if non-null. If <code>cache.check_pattern</code>  is <code>true</code> and the sparse matrix structure of <code>A</code> doesn&#39;t match the cached one,  throws an error. Finally, computes the numeric factorization of <code>A</code> and stores that to  <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/klu_linear_solver.jl#L155-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_factor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbolic_factor!(cache::KLULinSolveCache{T},  A::SparseMatrixCSC{Float64, T})</code></pre><p>Frees up the current symbolic and numeric factorizations stored by <code>cache</code>, if non-null. Then computes the symbolic factorization of <code>A</code> and stores that to <code>cache</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/klu_linear_solver.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><a class="docstring-binding" href="#PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T&lt;:Union{Int32, Int64}"><code>PowerFlows.symbolic_refactor!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Symbolic refactor. Behavior depends on the values of <code>cache.reuse_symbol</code> and  <code>cache.check_pattern</code>. There are 3 cases:</p><ul><li><code>!reuse_symbol</code>: always refactor. Just calls <code>symbolic_factor(cache, A)</code>.</li><li><code>reuse_symbol &amp;&amp; check_pattern</code>: checks if the symbolic structure of <code>A</code> matches the   cached one, and throws an error if it doesn&#39;t. This is to prevent bad input: we expected    the structure to be the same, but it isn&#39;t.</li><li><code>reuse_symbol &amp;&amp; !check pattern</code>: do nothing. Assume the structure of <code>A</code> matches the cached    one.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/klu_linear_solver.jl#L117-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.LinearSolverCache"><a class="docstring-binding" href="#PowerFlows.LinearSolverCache"><code>PowerFlows.LinearSolverCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Abstract supertype for all cached linear solvers. Subtypes must implement: <code>symbolic_factor!</code>, <code>symbolic_refactor!</code>, <code>numeric_refactor!</code> (which doubles as <code>numeric_factor!</code>), and <code>solve!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/LinearSolverCache/linear_solver_cache.jl#L1-L4">source</a></section></details></article><h1 id="Misc."><a class="docs-heading-anchor" href="#Misc.">Misc.</a><a id="Misc.-1"></a><a class="docs-heading-anchor-permalink" href="#Misc." title="Permalink"></a></h1><h2 id="PSSE-Export"><a class="docs-heading-anchor" href="#PSSE-Export">PSSE Export</a><a id="PSSE-Export-1"></a><a class="docs-heading-anchor-permalink" href="#PSSE-Export" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._first_choice_gen_id-Tuple{String}"><a class="docstring-binding" href="#PowerFlows._first_choice_gen_id-Tuple{String}"><code>PowerFlows._first_choice_gen_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Try to make an informative one or two character name for the load/generator/etc.</p><ul><li>generator-1234-AB -&gt; AB</li><li>123_CT_7 -&gt; 7</li><li>load1234 -&gt; 34</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L726-L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><a class="docstring-binding" href="#PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><code>PowerFlows._fix_3w_transformer_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Setting a value of zero 0.0 when having a value greater than or equal to INFINITE_BOUND reverses the operation done in the PSY parsing side, according to PSSE Manual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L494-L497">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><a class="docstring-binding" href="#PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><code>PowerFlows._make_gens_from_hvdc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create a synthetic generator (<code>PSY.ThermalStandard</code>) representing one end of a TwoTerminalGenericHVDCLine for export purposes. The generator is initialized with parameters reflecting the HVDC line&#39;s state. </p><p><strong>Notes</strong></p><pre><code class="language-julia hljs">- The generator&#39;s name is constructed as &quot;&lt;hvdc_line_name&gt;_&lt;suffix&gt;&quot;.
- The `ext` field includes `&quot;HVDC_END&quot;` to indicate the end (&quot;FR&quot;/&quot;TO&quot;).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L937-L943">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><a class="docstring-binding" href="#PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><code>PowerFlows._map_psse_container_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><code>PowerFlows._psse_bus_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L597-L602">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><code>PowerFlows._psse_bus_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L548-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><a class="docstring-binding" href="#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><code>PowerFlows._psse_transformer_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1519-L1524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._to_float-Tuple{Number}"><a class="docstring-binding" href="#PowerFlows._to_float-Tuple{Number}"><code>PowerFlows._to_float</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Parse a value to Int64, handling strings, floats, and PSSE<em>DEFAULT. Returns PSSE</em>DEFAULT for non-whole numbers or invalid values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L404-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><a class="docstring-binding" href="#PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><code>PowerFlows._update_gens_from_hvdc!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the parameters of synthetic generators created from HVDC lines, so they reflect the current setpoints and limits of the HVDC devices in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L976-L979">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><a class="docstring-binding" href="#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><code>PowerFlows.better_float_to_buf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L337">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.check_supported_version-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.check_supported_version-Tuple{PSSEExporter}"><code>PowerFlows.check_supported_version</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Throw a <code>NotImplementedError</code> if the <code>psse_version</code> is not supported</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L453">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>PowerFlows.convert_empty</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If <code>val</code> is empty, returns <code>T()</code>; if not, asserts that <code>val isa T</code> and returns <code>val</code>. Has nice type checker semantics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">convert_empty(Vector{String}, [])  # -&gt; String[]
convert_empty(Vector{String}, [&quot;a&quot;])  # -&gt; [&quot;a&quot;]
convert_empty(Vector{String}, [2])  # -&gt; TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}
Base.return_types(Base.Fix1(convert_empty, Vector{String}))  # -&gt; [Vector{String}]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L420-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><a class="docstring-binding" href="#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><code>PowerFlows.create_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The &quot;singles<em>to</em>1&quot; flag detects components that are the only one on their bus and gives them the name &quot;1&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L738-L743">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlowEvaluationModel}"><a class="docstring-binding" href="#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlowEvaluationModel}"><code>PowerFlows.flatten_power_flow_evaluation_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Expand a single <code>PowerFlowEvaluationModel</code> into its possibly multiple parts for separate evaluation. Namely, if <code>pfem</code> contains a non-nothing <code>exporter</code>, return <code>[pfem, exporter]</code>, else return <code>[pfem]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L158-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><code>PowerFlows.get_branches_with_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Collects all AC branches (Line, MonitoredLine, DiscreteControlledACBranch) from the system, sorts them by their bus numbers, and returns a vector of tuples (branch, bus_numbers).</p><p><strong>Arguments</strong></p><ul><li><code>exporter::PSSEExporter</code>: The exporter containing the system.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{&lt;:PSY.Branch, Tuple}}</code>: Each tuple contains a branch and its associated bus numbers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1251-L1260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.reset_caches-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.reset_caches-Tuple{PSSEExporter}"><code>PowerFlows.reset_caches</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Force all cached information (serialized metadata, component lists, etc.) to be regenerated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L288">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><a class="docstring-binding" href="#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><code>PowerFlows.serialize_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Take the output of <code>create_component_ids</code> and make it more suitable for JSON serialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L773">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L635-L638">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Case Identification Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L506">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 FACTS Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2520-L2522">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Fixed Bus Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L880-L882">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Generator Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1018-L1020">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Load Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L815-L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Non-Transformer Branch Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1275-L1277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2729-L2731">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Switched Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2595-L2597">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 35.4 POM 5.2.1 System Switching Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1433-L1435">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L1575-L1577">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Impedance Correction Tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2387-L2389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Two-Terminal DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2053-L2055">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Voltage Source Converter (VSC) DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2194-L2196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Zone Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L2489-L2491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_v35_header-Tuple{IO, PSSEExporter, String}"><a class="docstring-binding" href="#PowerFlows.write_v35_header-Tuple{IO, PSSEExporter, String}"><code>PowerFlows.write_v35_header</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Write v35 header comments for a given section if applicable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psse_export.jl#L249-L251">source</a></section></details></article><h2 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlows.PowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlows.PowerFlowData, Int64}"><code>PowerFlows._calculate_fixed_admittance_powers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a dictionary of bus index to power contribution at that bus from FixedAdmittance components, as a tuple of (active power, reactive power).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L7-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><a class="docstring-binding" href="#PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><code>PowerFlows._set_series_voltages_and_flows!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_set_series_voltages_and_flows!(
    sys::PSY.System,
    segment_sequence::PNM.BranchesSeries,
    equivalent_arc::Tuple{Int, Int},
    V_endpoints::Tuple{ComplexF64, ComplexF64},
    temp_bus_map::Dict{Int, String},
)</code></pre><p>Calculate series voltages at buses removed in degree 2 reduction.</p><p><strong>Method</strong></p><p>Number the nodes in the series segment 0, 1, ..., n. Number the segments by their concluding node: 1, 2, ... n. The currents in the segments are given by:</p><p class="math-container">\[\begin{bmatrix} y^i_{ff} &amp; y^i_{ft} \\ y^i_{tf} &amp; y^i_{tt} \end{bmatrix} 
\begin{bmatrix} V_{i-1} \\ V_i \end{bmatrix} = 
\begin{bmatrix} I_{i-1, i} \\ I_{i, i-1} \end{bmatrix}\]</p><p>where upper indices denote the segment number.</p><p>There are no loads or generators at the internal nodes, so <span>$I_{i, i+1} + I_{i, i-1} = 0$</span>. Substitute the above expressions for the currents and group by <span>$V_i$</span>:</p><p class="math-container">\[y^i_{tf} V_{i-1} + (y_{tt}^i + y_{ff}^{i+1}) V_i + y_{ft}^{i+1} V_{i+1} = 0\]</p><p>For <span>$i = 1$</span> and <span>$i = n-1$</span>, move the terms involving <span>$V_0$</span> and <span>$V_n$</span> (known) to  the other side. This gives a tridiagonal system for <span>$x = [V_1, \ldots, V_{n-1}]$</span>:</p><p class="math-container">\[A x = [-y^1_{tf} V_0, 0, \ldots, 0, -y^{n}_{ft} V_n]\]</p><p>where <span>$A$</span> has diagonal entries <span>$y_{tt}^i + y_{ff}^{i+1}$</span>, subdiagonal entries <span>$y_{tf}^{i+1}$</span>, and superdiagonal entries <span>$y_{ft}^i$</span>.</p><p>In the implementation, <span>$y_{11}$</span> is used instead of <span>$y_{ff}$</span>, <span>$y_{12}$</span> instead of  <span>$y_{ft}$</span>, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L349-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_arc_names-Tuple{PowerFlows.PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.get_arc_names-Tuple{PowerFlows.PowerFlowData}"><code>PowerFlows.get_arc_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the names of the arcs in the power flow data: those that correspond to branches in the system will get the branch names, others will get a placeholder name of the form from-to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L810-L812">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.set_branch_flows_for_dict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Set the power flow in the arcs that remain after network reduction. Called on the  <code>direct_branch_map</code> and <code>transformer3W_map</code> dictionaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L469-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_system!-Tuple{System, PowerFlows.PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.update_system!-Tuple{System, PowerFlows.PowerFlowData}"><code>PowerFlows.update_system!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> update_system!(sys::PSY.System, data::PowerFlowData; time_step = 1)</code></pre><p>Modify the values in the given <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> to correspond to the  given <code>PowerFlowData</code> such that if a new <code>PowerFlowData</code> is constructed from the resulting  system it is the same as <code>data</code>. See also <a href="#PowerFlows.write_power_flow_solution!"><code>write_power_flow_solution!</code></a>. NOTE this  assumes that <code>data</code> was initialized from <code>sys</code> and then solved with no further  modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L999-L1007">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_power_flow_solution!"><a class="docstring-binding" href="#PowerFlows.write_power_flow_solution!"><code>PowerFlows.write_power_flow_solution!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Updates system voltages and powers with power flow results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L491-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><a class="docstring-binding" href="#PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlows.PowerFlowData{&lt;:ACPowerFlow, PowerNetworkMatrices.AC_Ybus_Matrix, &lt;:Union{Nothing, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, Int64}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_results(
    ::ACPowerFlow{&lt;:ACPowerFlowSolverType},
    sys::PSY.System,
    data::ACPowerFlowData,
    time_step::Int64,
) -&gt; Dict{String, DataFrames.DataFrame}</code></pre><p>Returns a dictionary containing the AC power flow results.</p><p>Only single-period evaluation is supported at the moment for AC Power flows. The resulting dictionary will therefore feature just one key linked to one <code>DataFrame</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>::ACPowerFlow</code>:       use ACPowerFlow() storing AC power flow results.</li><li><code>sys::PSY.System</code>:       container storing the system information.</li><li><code>result::Vector{Float64}</code>:       vector containing the results for one single time-period.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L920-L940">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_results-Tuple{Union{PowerFlows.PowerFlowData{DCPowerFlow, PowerNetworkMatrices.DC_ABA_Matrix_Factorized, PowerNetworkMatrices.DC_BA_Matrix}, PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlows.PowerFlowData{vPTDFDCPowerFlow, &lt;:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, System}"><a class="docstring-binding" href="#PowerFlows.write_results-Tuple{Union{PowerFlows.PowerFlowData{DCPowerFlow, PowerNetworkMatrices.DC_ABA_Matrix_Factorized, PowerNetworkMatrices.DC_BA_Matrix}, PowerFlows.PowerFlowData{PTDFDCPowerFlow, PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlows.PowerFlowData{vPTDFDCPowerFlow, &lt;:PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}, System}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_results(
    data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData},
    sys::PSY.System,
)</code></pre><p>Returns a dictionary containing the DC power flow results. Each key corresponds to the name of the considered time periods, storing a <code>DataFrame</code> with the power flow results.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}</code>:       PowerFlowData structure containing power flows and bus angles.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>PowerSystems.System</code></a> object storing the system information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/post_processing.jl#L851-L866">source</a></section></details></article><h2 id="Power-Systems-Utilities"><a class="docs-heading-anchor" href="#Power-Systems-Utilities">Power Systems Utilities</a><a id="Power-Systems-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Systems-Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.can_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.can_be_PV-Tuple{System}"><code>PowerFlows.can_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that can be PV: i.e. have an available generator, or certain voltage regulation devices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/powersystems_utils.jl#L120-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><a class="docstring-binding" href="#PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><code>PowerFlows.get_active_and_reactive_power_from_generator</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active and reactive power generation from a generator component. It&#39;s pg=0 as default for synchronous condensers since there&#39;s no field in the component for active power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/powersystems_utils.jl#L45-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_active_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_active_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/powersystems_utils.jl#L21-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_reactive_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_reactive_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/powersystems_utils.jl#L1-L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.must_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.must_be_PV-Tuple{System}"><code>PowerFlows.must_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that must be PV: i.e. have an available generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/powersystems_utils.jl#L104">source</a></section></details></article><h2 id="Common-Utilities-and-Definitions"><a class="docs-heading-anchor" href="#Common-Utilities-and-Definitions">Common Utilities and Definitions</a><a id="Common-Utilities-and-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Utilities-and-Definitions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Similar to above: A*X where X is a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/common.jl#L343">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/common.jl#L328-L331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.siground-Tuple{Float64}"><a class="docstring-binding" href="#PowerFlows.siground-Tuple{Float64}"><code>PowerFlows.siground</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>For pretty printing floats in debugging messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/common.jl#L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wdot-NTuple{4, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wdot-NTuple{4, Vector{Float64}}"><code>PowerFlows.wdot</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted dot product of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/common.jl#L537">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><code>PowerFlows.wnorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted norm of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/common.jl#L541">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><a class="docstring-binding" href="#PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><code>PowerFlows.contributes_active_power</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check if a device has attribute &#39;active_power&#39; for active power consumption or generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/23e57758777ebc9ae35496a23f47802c81c31ab7/src/psi_utils.jl#L1-L3">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 00:11">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
