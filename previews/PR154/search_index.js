var documenterSearchIndex = {"docs":
[{"location":"how-tos/stub/#How-to-Guides","page":"How-to-Guides","title":"How-to Guides","text":"","category":"section"},{"location":"how-tos/stub/","page":"How-to-Guides","title":"How-to-Guides","text":"How-to's can be be referenced when looking for guidance for specific scenarios and issues in PowerAnalytics.  ","category":"page"},{"location":"reference/api/internal/#Internal","page":"Internal API Reference","title":"Internal","text":"","category":"section"},{"location":"reference/api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"CurrentModule = PowerFlows\nDocTestSetup  = quote\n    using PowerFlows\nend","category":"page"},{"location":"reference/api/internal/","page":"Internal API Reference","title":"Internal API Reference","text":"Modules = [PowerFlows]\nPublic = false\nPrivate = true","category":"page"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -> ACPowerFlowJacobian\n\nThis is the constructor for ACPowerFlowJacobian. Create an ACPowerFlowJacobian instance. As soon as the instance is created, it already has the Jacobian matrix structure initialized and its values updated, stored internally as Jv. The data instance is stored internally and used to update the Jacobian matrix because the structure of the Jacobian matrix is tied to the data. Changing the data requires creating a new instance of ACPowerFlowJacobian.\n\nArguments\n\ndata::ACPowerFlowData: The data used for power flow calculations.\ntime_step::Int64: The time step for the calculations.\n\nReturns\n\nACPowerFlowJacobian: An instance of ACPowerFlowJacobian.\n\n#Example\n\nJ = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.\nJ(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.\nJ.Jv  # Access the Jacobian matrix stored internally in J.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-2","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"struct ACPowerFlowJacobian\n\nA struct that represents the Jacobian matrix for AC power flow calculations.\n\nThis struct uses the functor pattern, meaning instances of ACPowerFlowJacobian store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.\n\nFields\n\ndata::ACPowerFlowData: The grid model data used for power flow calculations.\nJf!::Function: A function that calculates the Jacobian matrix inplace.\nJv::SparseArrays.SparseMatrixCSC{Float64, Int32}: The Jacobian matrix, which is updated by the function Jf!.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"(J::ACPowerFlowJacobian)(time_step::Int64)\n\nUpdate the Jacobian matrix Jv using the function Jf! and the provided data and time step.\n\nDefining this method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.\n\nArguments\n\ntime_step::Int64: The time step for the calculations.\n\nExample\n\nJ = ACPowerFlowJacobian(data, time_step)\nJ(time_step)  # Updates the Jacobian matrix Jv\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowJacobian","text":"(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)\n\nUse the ACPowerFlowJacobian to update the provided Jacobian matrix J inplace.\n\nUpdate the internally stored Jacobian matrix Jv using the function Jf! and the provided data and time step, and write the updated Jacobian values to J.\n\nThis method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.\n\nArguments\n\nJ::SparseArrays.SparseMatrixCSC{Float64, Int32}`: A sparse matrix to be updated with new values of the Jacobian matrix.\ntime_step::Int64: The time step for the calculations.\n\nExample\n\nJ = ACPowerFlowJacobian(data, time_step)\nJv = SparseArrays.sparse(Float64[], Int32[], Int32[])\nJ(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"struct ACPowerFlowResidual\n\nA struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.\n\nFields\n\ndata::ACPowerFlowData: The grid model data.\nRf!::Function: A function that updates the residuals based on the latest values stored in the grid at the given iteration.\nRv::Vector{Float64}: A vector of the values of the residuals.\nP_net::Vector{Float64}: A vector of net active power injections.\nQ_net::Vector{Float64}: A vector of net reactive power injections.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)\n\nCreate an instance of ACPowerFlowResidual for a given time step.\n\nArguments\n\ndata::ACPowerFlowData: The power flow data representing the power system model.\ntime_step::Int64: The time step for which the power flow calculation is executed.\n\nReturns\n\nACPowerFlowResidual: An instance containing the residual values, net bus active power injections, \n\nand net bus reactive power injections.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)\n\nUpdate the AC power flow residuals inplace and store the result in the attribute Rv of the struct. The inputs are the values of state vector x and the current time step time_step. This function implements the functor approach for the ACPowerFlowResidual struct.  This makes the struct callable. Calling the ACPowerFlowResidual will also update the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nx::Vector{Float64}: The state vector values.\ntime_step::Int64: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}","page":"Internal API Reference","title":"PowerFlows.ACPowerFlowResidual","text":"(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)\n\nEvaluate the AC power flow residuals and store the result in Rv using the provided  state vector x and the current time step time_step. The residuals are updated inplace in the struct and additionally copied to the provided array.  This function implements the functor approach for the ACPowerFlowResidual struct.  This makes the struct callable. Calling the ACPowerFlowResidual will also update the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nRv::Vector{Float64}: The vector to store the calculated residuals.\nx::Vector{Float64}: The state vector.\ntime_step::Int64: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.KLULinSolveCache","page":"Internal API Reference","title":"PowerFlows.KLULinSolveCache","text":"A cached linear solver using KLU. Carefully written so as to minimize allocations: solve! and numeric_refactor! are completely non-allocating.\n\nFields:\n\nK: the underlying KLU object.\nreuse_symbolic::Bool: reuse the symbolic factorization. Defaults to true.\ncheck_pattern::Bool: if true, numeric_refactor! verifies that the new\n\nmatrix has the same sparsity structure. Defaults to true. -rf_common, rf_symbolic, rf_numeric: internal usage. Stored to avoid allocations.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.KLULinSolveCache-Union{Tuple{SparseArrays.SparseMatrixCSC{Float64, T}}, Tuple{T}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool}, Tuple{SparseArrays.SparseMatrixCSC{Float64, T}, Bool, Bool}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.KLULinSolveCache","text":"Constructor.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.LinearSolverCache","page":"Internal API Reference","title":"PowerFlows.LinearSolverCache","text":"Abstract supertype for all cached linear solvers. Subtypes must implement: symbolic_factor!, symbolic_refactor!, numeric_refactor! (which doubles as numeric_factor!), and solve!.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.StateVectorCache","page":"Internal API Reference","title":"PowerFlows.StateVectorCache","text":"Cache for non-linear methods\n\nFields\n\n-x::Vector{Float64}: the current state vector. -r::Vector{Float64}: the current residual. -Δx_nr::Vector{Float64}: the step under the Newton-Raphson method. The remainder of the fields are only used in the TrustRegionACPowerFlow: -r_predict::Vector{Float64}: the predicted residual at x+Δx_proposed,     under a linear approximation: i.e J_x⋅(x+Δx_proposed). -Δx_proposed::Vector{Float64}: the suggested step Δx, selected among Δx_nr,      Δx_cauchy, and the dogleg interpolation between the two. The first is chosen when     x+Δx_nr is inside the trust region, the second when both x+Δx_cauchy     and x+Δx_nr are outside the trust region, and the third when x+Δx_cauchy     is inside and x+Δx_nr outside. The dogleg step selects the point where the line     from x+Δx_cauchy to x+Δx_nr crosses the boundary of the trust region. -Δx_cauchy::Vector{Float64}: the step to the Cauchy point if the Cauchy point     lies within the trust region, otherwise a step in that direction.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows.SystemPowerFlowContainer","page":"Internal API Reference","title":"PowerFlows.SystemPowerFlowContainer","text":"A PowerFlowContainer that represents its data as a PSY.System\n\n\n\n\n\n","category":"type"},{"location":"reference/api/internal/#PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlowData}","page":"Internal API Reference","title":"PowerFlows._calculate_fixed_admittance_powers","text":"Returns a dictionary of bus index to power contribution at that bus from FixedAdmittance  components, as a tuple of (active power, reactive power).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure","text":"_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -> SparseMatrixCSC{Float64, Int32}\n\nCreate the structure of the Jacobian matrix for an AC power flow problem. Inputs are the grid model as an instance of ACPowerFlowData at a given time step.\n\nArguments\n\ndata::ACPowerFlowData: The power flow model.\ntime_step::Int64: The specific time step for which the Jacobian matrix structure is created.\n\nReturns\n\nSparseMatrixCSC{Float64, Int32}: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.\n\nDescription\n\nThis function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.\n\nUnlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus. See the example below for details.\n\nThis approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.\n\nThe function initializes three arrays (rows, columns, and values) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.\n\nFor each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (REF, PV, or PQ).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.\n\nFor REF buses, entries are added for local active and reactive power.\nFor PV buses, entries are added for active and reactive power with respect to angle, and for local reactive power.\nFor PQ buses, entries are added for active and reactive power with respect to voltage magnitude and angle.\n\nFor example, suppose we have a system with 3 buses: bus 1 is REF, bus 2 is PV, and bus 3 is PQ. Let ΔPⱼ, ΔQⱼ be the active, reactive power balance at the jth bus. Let Pⱼ and Qⱼ be the active and reactive power generated at the jth bus (REF and PV only). Then the state vector is [P₁, Q₁, Q₂, θ₂, V₃, θ₃], and the Jacobian matrix is\n\n| ∂ΔP₁/∂P₁ | ∂ΔP₁/∂Q₁ | ∂ΔP₁/∂Q₂ | ∂ΔP₁/∂θ₂ | ∂ΔP₁/∂V₃ | ∂ΔP₁/∂θ₃ |   | ∂ΔQ₁/∂P₁ | ∂ΔQ₁/∂Q₁ | ∂ΔQ₁/∂Q₂ | ∂ΔQ₁/∂θ₂ | ∂ΔQ₁/∂V₃ | ∂ΔQ₁/∂θ₃ | | ∂ΔP₂/∂P₁ | ∂ΔP₂/∂Q₁ | ∂ΔP₂/∂Q₂ | ∂ΔP₂/∂θ₂ | ∂ΔP₂/∂V₃ | ∂ΔP₂/∂θ₃ | | ∂ΔQ₂/∂P₁ | ∂ΔQ₂/∂Q₁ | ∂ΔQ₂/∂Q₂ | ∂ΔQ₂/∂θ₂ | ∂ΔQ₂/∂V₃ | ∂ΔQ₂/∂θ₃ | | ∂ΔP₃/∂P₁ | ∂ΔP₃/∂Q₁ | ∂ΔP₃/∂Q₂ | ∂ΔP₃/∂θ₂ | ∂ΔP₃/∂V₃ | ∂ΔP₃/∂θ₃ | | ∂ΔQ₃/∂P₁ | ∂ΔQ₃/∂Q₁ | ∂ΔQ₃/∂Q₂ | ∂ΔQ₃/∂θ₂ | ∂ΔQ₃/∂V₃ | ∂ΔQ₃/∂θ₃ |\n\nIn reality, for large networks, this matrix would be sparse, and each 4x4 block would only be nonzero when there's a line between the respective buses.\n\nFinally, the function constructs a sparse matrix from the collected indices and values and returns it.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a PV bus. Ignoring this because we fill all four values even for PV buses with      structural zeros using the same function as for PQ buses.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a reference bus (REF). Ignoring this because we fill all four values even for PV buses with      structiural zeros using the same function as for PQ buses.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}","page":"Internal API Reference","title":"PowerFlows._create_jacobian_matrix_structure_bus!","text":"Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn't matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -> PQ transition and then we need to fill all four values\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._dc_powerflow_fallback!-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows._dc_powerflow_fallback!","text":"When solving AC power flows, if the initial guess has large residual, we run a DC power  flow as a fallback. This runs a DC powerflow on data::ACPowerFlowData for the given time_step, and writes the solution to data.bus_angles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}","page":"Internal API Reference","title":"PowerFlows._do_refinement!","text":"Check error and do refinement.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Float64}","page":"Internal API Reference","title":"PowerFlows._dogleg!","text":"Sets Δx_proposed equal to the Δx by which we should update x. Decides between the Cauchy step Δx_cauchy, Newton-Raphson step Δx_nr, and the dogleg interpolation between the two, based on which fall within the trust region.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._first_choice_gen_id-Tuple{String}","page":"Internal API Reference","title":"PowerFlows._first_choice_gen_id","text":"Try to make an informative one or two character name for the load/generator/etc.\n\n\"generator-1234-AB\" -> \"AB\"\n\"123CT7\" -> \"7\"\n\"load1234\" -> \"34\"\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._get_load_data-Tuple{System, Bus}","page":"Internal API Reference","title":"PowerFlows._get_load_data","text":"Obtain total load on bus b\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._map_psse_container_names-Tuple{Vector{String}}","page":"Internal API Reference","title":"PowerFlows._map_psse_container_names","text":"Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}","page":"Internal API Reference","title":"PowerFlows._psse_bus_names","text":"Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}","page":"Internal API Reference","title":"PowerFlows._psse_bus_numbers","text":"Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector{Tuple{Int64, Int64}}, AbstractDict{Int64, Int64}, Any}","page":"Internal API Reference","title":"PowerFlows._psse_transformer_names","text":"Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}","page":"Internal API Reference","title":"PowerFlows._run_powerflow_method","text":"Runs the full NewtonRaphsonACPowerFlow.\n\nKeyword arguments:\n\nmaxIterations::Int: maximum iterations. Default: 30.\ntol::Float64: tolerance. The iterative search ends when norm(abs.(residual)) < tol.   Default: 1.0e-9.\nrefinement_threshold::Float64: If the solution to J_x Δx = r satisfies   norm(J_x Δx - r, 1)/norm(r, 1) > refinement_threshold, do iterative refinement to   improve the accuracy. Default: 0.05.\nrefinement_eps::Float64: run iterative refinement on J_x Δx = r until   norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) < refinement_eps. Default:    1.0e-6 \n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}","page":"Internal API Reference","title":"PowerFlows._run_powerflow_method","text":"Runs the full TrustRegionNRMethod.\n\nKeyword arguments:\n\nmaxIterations::Int: maximum iterations. Default: 30.\ntol::Float64: tolerance. The iterative search ends when maximum(abs.(residual)) < tol.   Default: 1.0e-9.\nfactor::Float64: the trust region starts out with radius factor*norm(x_0, 1),   where x_0 is our initial guess, taken from data. Default: 1.0.\neta::Float64: improvement threshold. If the observed improvement in our residual   exceeds eta times the predicted improvement, we accept the new x_i.   Default: 0.0001.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}","page":"Internal API Reference","title":"PowerFlows._set_Δx_nr!","text":"Sets the Newton-Raphson step. Usually, this is just J.Jv \\ stateVector.r, but J.Jv might be singular.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._simple_step","page":"Internal API Reference","title":"PowerFlows._simple_step","text":"Does a single iteration of NewtonRaphsonACPowerFlow. Updates the r and x fields of the stateVector, and computes the Jacobian at the new x.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows._singular_J_fallback","text":"Returns a stand-in matrix for singular J's.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}","page":"Internal API Reference","title":"PowerFlows._solve_Δx_nr!","text":"Solve for the Newton-Raphson step, given the factorization object for J.Jv  (if non-singular) or its stand-in (if singular).\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._trust_region_step","page":"Internal API Reference","title":"PowerFlows._trust_region_step","text":"Does a single iteration of the TrustRegionNRMethod: updates the x and r fields of the stateVector and computes the value of the Jacobian at the new x, if needed. Unlike  _simple_step, this has a return value, the updated value of delta`.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows._update_branch_flow!-Tuple{System}","page":"Internal API Reference","title":"PowerFlows._update_branch_flow!","text":"Updates the flow on the branches\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows._update_jacobian_matrix_values!","text":"Used to update Jv based on the bus voltages, angles, etc. in data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows._update_residual_values!","text":"_update_residual_values!(\n    F::Vector{Float64},\n    x::Vector{Float64},\n    P_net::Vector{Float64},\n    Q_net::Vector{Float64},\n    data::ACPowerFlowData,\n    time_step::Int64,\n)\n\nUpdate the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the ACPowerFlowResidual struct. This function also updates the values of P, Q, V, Θ in the data struct.\n\nArguments\n\nF::Vector{Float64}: Vector of the values of the residuals.\nx::Vector{Float64}: State vector values.\nP_net::Vector{Float64}: Vector of net active power injections at each bus.\nQ_net::Vector{Float64}: Vector of net reactive power injections at each bus.\ndata::ACPowerFlowData: Data structure representing the grid model for the AC power flow calculation.\ntime_step::Int64: The current time step for which the residual values are being updated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{<:Array{UInt8}}, Base.GenericIOBuffer{<:GenericMemory{:not_atomic, UInt8}}}, Float64}","page":"Internal API Reference","title":"PowerFlows.better_float_to_buf","text":"Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.calculate_loss_factors-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}","page":"Internal API Reference","title":"PowerFlows.calculate_loss_factors","text":"calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)\n\nCalculate and store the active power loss factors in the loss_factors matrix of the ACPowerFlowData structure for a given time step.\n\nThe loss factors are computed using the Jacobian matrix Jv and the vector dSbus_dV_ref, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injection as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.\n\nArguments\n\ndata::ACPowerFlowData: The data structure containing power flow information, including the loss_factors matrix.\nJv::SparseMatrixCSC{Float64, Int32}: The sparse Jacobian matrix of the power flow system.\ntime_step::Int: The time step index for which the loss factors are calculated.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.calculate_x0-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Internal API Reference","title":"PowerFlows.calculate_x0","text":"Calculate x0 from data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.check_33-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows.check_33","text":"Throw a NotImplementedError if the psse_version is not :v33\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T","page":"Internal API Reference","title":"PowerFlows.convert_empty","text":"If val is empty, returns T(); if not, asserts that val isa T and returns val. Has nice type checker semantics.\n\nExamples\n\nconvert_empty(Vector{String}, [])  # -> String[]\nconvert_empty(Vector{String}, [\"a\"])  # -> [\"a\"]\nconvert_empty(Vector{String}, [2])  # -> TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}\nBase.return_types(Base.Fix1(convert_empty, Vector{String}))  # -> [Vector{String}]\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{<:String}, Vector{T}}} where T","page":"Internal API Reference","title":"PowerFlows.create_component_ids","text":"Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The \"singlesto1\" flag detects components that are the only one on their bus and gives them the name \"1\".\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}","page":"Internal API Reference","title":"PowerFlows.flatten_power_flow_evaluation_model","text":"Expand a single PowerFlowEvaluationModel into its possibly multiple parts for separate evaluation. Namely, if pfem contains a non-nothing exporter, return [pfem, exporter], else return [pfem].\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_func-Tuple{ACBranch, ComplexF64, ComplexF64}","page":"Internal API Reference","title":"PowerFlows.flow_func","text":"Calculates the From - To complex power flow using external data of voltages of branch of type Line\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_func-Tuple{TapTransformer, ComplexF64, ComplexF64}","page":"Internal API Reference","title":"PowerFlows.flow_func","text":"Calculates the From - To complex power flow using external data of voltages of branch of type TapTransformer\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_func-Tuple{Transformer2W, ComplexF64, ComplexF64}","page":"Internal API Reference","title":"PowerFlows.flow_func","text":"Calculates the From - To complex power flow using external data of voltages of branch of type Transformer2W\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_val-Tuple{ACBranch}","page":"Internal API Reference","title":"PowerFlows.flow_val","text":"Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_val-Tuple{DynamicBranch}","page":"Internal API Reference","title":"PowerFlows.flow_val","text":"Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_val-Tuple{TapTransformer}","page":"Internal API Reference","title":"PowerFlows.flow_val","text":"Calculates the From - To complex power flow (Flow injected at the bus) of branch of type TapTransformer\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.flow_val-Tuple{Transformer2W}","page":"Internal API Reference","title":"PowerFlows.flow_val","text":"Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Transformer2W\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}","page":"Internal API Reference","title":"PowerFlows.get_active_power_limits_for_power_flow","text":"Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to PSY.get_active_power_limits in all but special cases.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}","page":"Internal API Reference","title":"PowerFlows.get_reactive_power_limits_for_power_flow","text":"Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to PSY.get_reactive_power_limits in all but special cases.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.improve_x0!-Tuple{Vector{Float64}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64, PowerFlows.ACPowerFlowResidual}","page":"Internal API Reference","title":"PowerFlows.improve_x0!","text":"If initial residual is large, run a DC power flow and see if that gives a better starting point for angles. Return the original or the result of the DC powerflow, whichever gives the smaller residual.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.make_power_flow_container","page":"Internal API Reference","title":"PowerFlows.make_power_flow_container","text":"Create an appropriate PowerFlowContainer for the given PowerFlowEvaluationModel and initialize it from the given PSY.System.\n\nArguments:\n\npfem::PowerFlowEvaluationModel: power flow model to construct a container for (e.g., DCPowerFlow())\nsys::PSY.System: the system from which to initialize the power flow container\ntime_steps::Int: number of time periods to consider (default is 1)\ntimestep_names::Vector{String}: names of the time periods defines by the argument \"time_steps\". Default value is String[].\ncheck_connectivity::Bool: Perform connectivity check on the network matrix. Default value is true.\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}","page":"Internal API Reference","title":"PowerFlows.my_mul_mt","text":"Similar to above: A*X where X is a matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}","page":"Internal API Reference","title":"PowerFlows.my_mul_mt","text":"Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.numeric_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.numeric_refactor!","text":"Frees numeric factorization stored by cache, if non-null. If cache.check_pattern  is true and the sparse matrix structure of A doesn't match the cached one,  throws an error. Finally, computes the numeric factorization of A and stores that to  cache.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.reset_caches-Tuple{PSSEExporter}","page":"Internal API Reference","title":"PowerFlows.reset_caches","text":"Force all cached information (serialized metadata, component lists, etc.) to be regenerated\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}","page":"Internal API Reference","title":"PowerFlows.serialize_component_ids","text":"Take the output of create_component_ids and make it more suitable for JSON serialization\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}","page":"Internal API Reference","title":"PowerFlows.supports_multi_period","text":"Trait signifying whether the PowerFlowContainer can represent multi-period data. Must be implemented for all concrete subtypes.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.symbolic_factor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.symbolic_factor!","text":"Frees up the current symbolic and numeric factorizations stored by cache, if non-null. Then computes the symbolic factorization of A and stores that to cache.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.symbolic_refactor!-Union{Tuple{T}, Tuple{PowerFlows.KLULinSolveCache{T}, SparseArrays.SparseMatrixCSC{Float64, T}}} where T<:Union{Int32, Int64}","page":"Internal API Reference","title":"PowerFlows.symbolic_refactor!","text":"Symbolic refactor. Behavior depends on the values of cache.reuse_symbol and  cache.check_pattern. There are 3 cases:\n\n!reuse_symbol: always refactor. Just calls symbolic_factor(cache, A).\nreuse_symbol && check_pattern: checks if the symbolic structure of A matches the   cached one, and throws an error if it doesn't. This is to prevent bad input: we expected    the structure to be the same, but it isn't.\nreuse_symbol && !check pattern: do nothing. Assume the structure of A matches the cached    one.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.update_system!-Tuple{System, PowerFlowData}","page":"Internal API Reference","title":"PowerFlows.update_system!","text":"Modify the values in the given System to correspond to the given PowerFlowData such that if a new PowerFlowData is constructed from the resulting system it is the same as data. See also write_powerflow_solution!. NOTE that this assumes that data was initialized from sys and then solved with no further modifications.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_powerflow_solution!","page":"Internal API Reference","title":"PowerFlows.write_powerflow_solution!","text":"Updates system voltages and powers with power flow results\n\n\n\n\n\n","category":"function"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Bus Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Case Identification Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Case Identification Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Fixed Shunt Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Fixed Bus Shunt Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Generator Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"If the exportsettings flag `sourcesasgeneratorsis set, exportPSY.Sourceinstances as PSS/E generators in addition toPSY.Generators. Same forstoragesas_generatorsandPSY.Storage`.\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Generator Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Load Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Load Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Non-Transformer Branch Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Non-Transformer Branch Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Q Record\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Transformer Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"Currently only supports two-winding transformers\n\nWRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/internal/#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(\"Zone Data\")}}","page":"Internal API Reference","title":"PowerFlows.write_to_buffers!","text":"WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Zone Data\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows","page":"Public API Reference","title":"PowerFlows","text":"","category":"section"},{"location":"reference/api/public/","page":"Public API Reference","title":"Public API Reference","text":"CurrentModule = PowerFlows\nDocTestSetup  = quote\n    using PowerFlows\nend","category":"page"},{"location":"reference/api/public/","page":"Public API Reference","title":"Public API Reference","text":"Modules = [PowerFlows]\nPublic = true\nPrivate = false","category":"page"},{"location":"reference/api/public/#PowerFlows.PSSEExporter","page":"Public API Reference","title":"PowerFlows.PSSEExporter","text":"Structure to perform an export from a Sienna System, plus optional updates from PowerFlowData, to the PSS/E format. Construct from a System and a PSS/E version, update using update_exporter with any new data as relevant, and perform the export with write_export. Writes a <name>.raw file and a <name>_export_metadata.json file with transformations that had to be made to conform to PSS/E naming rules, which can be parsed by PowerSystems.jl to perform a round trip with the names restored.\n\nArguments:\n\nbase_system::PSY.System: the system to be exported. Later updates may change power flow-related values but may not fundamentally alter the system\npsse_version::Symbol: the version of PSS/E to target, must be one of PSSE_EXPORT_SUPPORTED_VERSIONS\nwrite_comments::Bool = false: whether to add the customary-but-not-in-spec-annotations after a slash on the first line and at group boundaries\nname::AbstractString = \"export\": the base name of the export\nstep::Any = nothing: optional step data to append to the base export name. User is responsible for updating the step data. If the step data is nothing, it is not used; if it is a tuple or vector, it is joined with '' and concatted; else it is concatted after ''.\noverwrite::Bool = false: true to silently overwrite existing exports, false to throw an error if existing results are encountered\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.PowerFlowData","page":"Public API Reference","title":"PowerFlows.PowerFlowData","text":"Structure containing all the data required for the evaluation of the power flows and angles, as well as these ones.\n\nArguments:\n\nbus_lookup::Dict{Int, Int}:       dictionary linking the system's bus number with the rows of either       \"powernetworkmatrix\" or \"auxnetworkmatrix\".\nbranch_lookup::Dict{String, Int}:       dictionary linking the branch name with the column name of either the       \"powernetworkmatrix\" or \"auxnetworkmatrix\".\nbus_activepower_injection::Matrix{Float64}:       \"(b, t)\" matrix containing the bus active power injection. b: number of       buses, t: number of time period.\nbus_reactivepower_injection::Matrix{Float64}:       \"(b, t)\" matrix containing the bus reactive power injection. b: number       of buses, t: number of time period.\nbus_activepower_withdrawals::Matrix{Float64}:       \"(b, t)\" matrix containing the bus reactive power withdrawals. b:       number of buses, t: number of time period.\nbus_reactivepower_withdrawals::Matrix{Float64}:       \"(b, t)\" matrix containing the bus reactive power withdrawals. b:       number of buses, t: number of time period.\nbus_reactivepower_bounds::Matrix{Float64}:       \"(b, t)\" matrix containing upper and lower bounds for the reactive supply at each       bus at each time period.\nbus_type::Matrix{PSY.ACBusTypes}:       \"(b, t)\" matrix containing type of buses present in the system, ordered       according to \"bus_lookup,\" at each time period.\nbus_magnitude::Matrix{Float64}:       \"(b, t)\" matrix containing the bus magnitudes, ordered according to       \"bus_lookup\". b: number of buses, t: number of time period.\nbus_angles::Matrix{Float64}:       \"(b, t)\" matrix containing the bus angles, ordered according to       \"bus_lookup\". b: number of buses, t: number of time period.\nbranch_activepower_flow_from_to::Matrix{Float64}:       \"(br, t)\" matrix containing the active power flows measured at the from bus,       ordered according to \"branch_lookup\". br: number of branches, t: number of time       period.\nbranch_reactivepower_flow_from_to::Matrix{Float64}:       \"(br, t)\" matrix containing the reactive power flows measured at the from bus,       ordered according to \"branch_lookup\". br: number of branches, t: number of time       period.\nbranch_activepower_flow_to_from::Matrix{Float64}:       \"(br, t)\" matrix containing the active power flows measured at the to bus, ordered       according to \"branch_lookup\". br: number of branches, t: number of time period.\nbranch_reactivepower_flow_to_from::Matrix{Float64}:       \"(br, t)\" matrix containing the reactive power flows measured at the to bus,       ordered according to \"branch_lookup\". br: number of branches, t: number of time       period.\ntimestep_map::Dict{Int, S}:       dictonary mapping the number of the time periods (corresponding to the       column number of the previosly mentioned matrices) and their names.\nvalid_ix::Vector{Int}:       vector containing the indeces of not slack buses\npower_network_matrix::M:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.\naux_network_matrix::N:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.\nneighbors::Vector{Set{Int}}: Vector with the sets of adjacent buses.\n\n\n\n\n\n","category":"type"},{"location":"reference/api/public/#PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.PowerFlowData","text":"Function for the definition of the PowerFlowData strucure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for AC power flow computations.\n\nArguments:\n\n::ACPowerFlow:       use ACPowerFlow() to evaluate the AC PF.\nsys::PSY.System:       container storing the system data to consider in the PowerFlowData       structure.\ntime_steps::Int:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.\ntimestep_names::Vector{String}:       names of the time periods defines by the argmunet \"time_steps\". Default       value = String[].\ncheck_connectivity::Bool:       Perform connectivity check on the network matrix. Default value = true.\n\nWARNING: functions for the evaluation of the multi-period AC PF still to be implemented.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.PowerFlowData","text":"Function for the definition of the PowerFlowData strucure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for DC power flow computations.\n\nArguments:\n\n::DCPowerFlow:       use DCPowerFlow() to store the ABA matrix as powernetworkmatrix and       the BA matrix as auxnetworkmatrix.\nsys::PSY.System:       container storing the system data to consider in the PowerFlowData       structure.\ntime_steps::Int:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.\ntimestep_names::Vector{String}:       names of the time periods defines by the argmunet \"time_steps\". Default       value = String[].\ncheck_connectivity::Bool:       Perform connectivity check on the network matrix. Default value = true.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.PowerFlowData","text":"Function for the definition of the PowerFlowData strucure given the System data, number of time periods to consider and their names. Calling this function will not evaluate the power flows and angles. NOTE: use it for DC power flow computations.\n\nArguments:\n\n::PTDFDCPowerFlow:       use vPTDFDCPowerFlow() to store the Virtual PTDF matrix as       powernetworkmatrix and the ABA matrix as auxnetworkmatrix.\nsys::PSY.System:       container storing the system data to consider in the PowerFlowData       structure.\ntime_steps::Int:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = 1.\ntimestep_names::Vector{String}:       names of the time periods defines by the argmunet \"time_steps\". Default       value = String[].\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.get_psse_export_paths-Tuple{AbstractString}","page":"Public API Reference","title":"PowerFlows.get_psse_export_paths","text":"Calculate the paths of the (raw, metadata) files that would be written by a certain call to write_export\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow!-Tuple{ACPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow!","text":"solve_powerflow!(pf::ACPowerFlow{<:ACPowerFlowSolverType}, system::PSY.System; kwargs...)\n\nSolves the power flow in the system and writes the solution into the relevant structs. Updates active and reactive power setpoints for generators and active and reactive power flows for branches (calculated in the From - To direction and in the To - From direction).\n\nSupports passing kwargs to the PF solver.\n\nThe bus types can be changed from PV to PQ if the reactive power limits are violated.\n\nArguments\n\npf::ACPowerFlow{<:ACPowerFlowSolverType}: The power flow solver instance, can be NewtonRaphsonACPowerFlow or LUACPowerFlow (to be used for testing only).\nsystem::PSY.System: The power system model.\nkwargs...: Additional keyword arguments.\n\nKeyword Arguments\n\ncheck_connectivity::Bool: Checks if the grid is connected. Default is true.\n'checkreactivepower_limits': if true, the reactive power limits are enforced by changing the respective bus types from PV to PQ. Default is false.\ntol: Infinite norm of residuals under which convergence is declared. Default is 1e-9.\nmaxIterations: Maximum number of Newton-Raphson iterations. Default is 30.\n\nReturns\n\nconverged::Bool: Indicates whether the power flow solution converged.\nThe power flow results are written into the system struct.\n\nExamples\n\nsolve_ac_powerflow!(pf, sys)\n\n# Passing kwargs\nsolve_ac_powerflow!(pf, sys; check_connectivity=false)\n\n# Passing keyword arguments\nsolve_ac_powerflow!(pf, sys; maxIterations=100)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{String}}, Tuple{Dict{Int64, Int64}, Dict{String, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}","page":"Public API Reference","title":"PowerFlows.solve_powerflow!","text":"Evaluates the power flows on each system's branch and updates the PowerFlowData structure.\n\nArguments:\n\ndata::PTDFPowerFlowData:       PTDFPowerFlowData structure containing all the information related to the system's power flow.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{String}, Vector{Int64}}, Tuple{Dict{String, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}","page":"Public API Reference","title":"PowerFlows.solve_powerflow!","text":"Evaluates the power flows on each system's branch and updates the PowerFlowData structure.\n\nArguments:\n\ndata::vPTDFPowerFlowData:       vPTDFPowerFlowData structure containing all the information related to the system's power flow.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}}","page":"Public API Reference","title":"PowerFlows.solve_powerflow!","text":"solve_powerflow!(data::ACPowerFlowData; pf::ACPowerFlow{<:ACPowerFlowSolverType} = ACPowerFlow(), kwargs...)\n\nSolve the multiperiod AC power flow problem for the given power flow data.\n\nThe bus types can be changed from PV to PQ if the reactive power limits are violated.\n\nArguments\n\ndata::ACPowerFlowData: The power flow data containing netwthe grid information and initial conditions.\npf::ACPowerFlow{<:ACPowerFlowSolverType}: The power flow solver type. Defaults to NewtonRaphsonACPowerFlow.\nkwargs...: Additional keyword arguments.\n\nKeyword Arguments\n\ncheck_connectivity::Bool: Checks if the grid is connected. Default is true.\n'checkreactivepower_limits': if true, the reactive power limits are enforced by changing the respective bus types from PV to PQ. Default is false.\ntime_steps: Specifies the time steps to solve. Defaults to sorting and collecting the keys of data.timestep_map.\n\nDescription\n\nThis function solves the AC power flow problem for each time step specified in data.  It preallocates memory for the results and iterates over the sorted time steps.      For each time step, it calls the _ac_powerflow function to solve the power flow equations and updates the data object with the results.      If the power flow converges, it updates the active and reactive power injections, as well as the voltage magnitudes and angles for different bus types (REF, PV, PQ).      If the power flow does not converge, it sets the corresponding entries in data to NaN.      Finally, it calculates the branch power flows and updates the data object.\n\nNotes\n\nIf the grid topology changes (e.g., tap positions of transformers or in-service status of branches), the admittance matrices Yft and Ytf must be updated.\nIf Yft and Ytf change between time steps, the branch flow calculations must be moved inside the loop.\n\nExamples\n\nsolve_powerflow!(data)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{ACPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Similar to solve_powerflow!(pf, sys) but does not update the system struct with results. Returns the results in a dictionary of dataframes.\n\nExamples\n\nres = solve_powerflow(pf, sys)\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{DCPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of the ABA and BA matrices. Updates the PowerFlowData structure and returns a dictionary containing a DataFrame for the single timestep considered. The DataFrame containts the flows and angles related to the information stored in the PSY.System considered as input.\n\nArguments:\n\n::DCPowerFlow:       use DCPowerFlow() to evaluate the power flows according to the method       based on the ABA and BA matrices\nsys::PSY.System:       container gathering the system data used for the evaluation of flows       and angles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{PTDFDCPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of the PTDF matrix. Updates the PowerFlowData structure and returns a dictionary containing a DataFrame for the single timestep considered. The DataFrame containts the flows and angles related to the information stored in the PSY.System considered as input.\n\nArguments:\n\n::PTDFDCPowerFlow:       use PTDFDCPowerFlow() to evaluate the power flows according to the       method based on the PTDF matrix\nsys::PSY.System:       container gathering the system data used for the evaluation of flows       and angles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{String}}, Tuple{Dict{Int64, Int64}, Dict{String, Int64}}}}, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of the ABA and BA matrices. Updates the PowerFlowData structure \"data\" and returns a dictionary containing a number of DataFrames equal to the numeber of timestep considered in \"data\". Each DataFrame containts the flows and angles.\n\nArguments:\n\ndata::ABAPowerFlowData:       PowerFlowData structure containing the system's data per each timestep       considered, as well as the ABA and BA matrices.\nsys::PSY.System:       container gathering the system data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{String}}, Tuple{Dict{Int64, Int64}, Dict{String, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of the PTDF matrix. Updates the PowerFlowData structure \"data\" and returns a dictionary containing a number of DataFrames equal to the numeber of timestep considered in \"data\". Each DataFrame containts the flows and angles.\n\nArguments:\n\ndata::PTDFPowerFlowData:       PowerFlowData structure containing the system's data per each timestep       considered, as well as the PTDF matrix.\nsys::PSY.System:       container gathering the system data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{String}, Vector{Int64}}, Tuple{Dict{String, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of Virtual PTDF matrices. Updates the PowerFlowData structure \"data\" and returns a dictionary containing a number of DataFrames equal to the numeber of timestep considered in \"data\". Each DataFrame containts the flows and angles.\n\nArguments:\n\ndata::PTDFPowerFlowData:       PowerFlowData structure containing the system data per each timestep       considered, as well as the Virtual PTDF matrix.\nsys::PSY.System:       container gathering the system data.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.solve_powerflow-Tuple{vPTDFDCPowerFlow, System}","page":"Public API Reference","title":"PowerFlows.solve_powerflow","text":"Evaluates the power flows on each system's branch by means of the Virtual PTDF matrix. Updates the PowerFlowData structure \"data\" and returns a dictionary containing a number of DataFrames equal to the numeber of timestep considered in \"data\". The DataFrame containts the flows and angles related to the information stored in the PSY.System considered as input.\n\nArguments:\n\n::vPTDFDCPowerFlow:       use vPTDFDCPowerFlow() to evaluate the power flows according to the       method based on the Virtual PTDF matrix\nsys::PSY.System:       container gathering the system data used for the evaluation of flows       and angles.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlowData}","page":"Public API Reference","title":"PowerFlows.update_exporter!","text":"Update the PSSEExporter with new data.\n\nArguments:\n\nexporter::PSSEExporter: the exporter to update\ndata::PSY.PowerFlowData: the new data. Must correspond to the System with which the exporter was constructor\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.update_exporter!-Tuple{PSSEExporter, System}","page":"Public API Reference","title":"PowerFlows.update_exporter!","text":"Update the PSSEExporter with new data.\n\nArguments:\n\nexporter::PSSEExporter: the exporter to update\ndata::PSY.System: system containing the new data. Must be fundamentally the same\n\nSystem as the one with which the exporter was constructed, just with different values —   this is the user's responsibility, we do not exhaustively verify it.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}","page":"Public API Reference","title":"PowerFlows.write_export","text":"Peform an export from the data contained in a PSSEExporter to the PSS/E file format.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.write_results-Tuple{ACPowerFlow, System, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, <:Union{Nothing, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, Nothing}}}, Int64}","page":"Public API Reference","title":"PowerFlows.write_results","text":"Returns a dictionary containing the AC power flow results.\n\nOnly single-period evaluation is supported at the moment for AC Power flows. Resulting dictionary will therefore feature just one key linked to one DataFrame.\n\nArguments:\n\n::ACPowerFlow:       use ACPowerFlow() storing AC power flow results.\nsys::PSY.System:       container storing the systam information.\nresult::Vector{Float64}:       vector containing the reults for one single time-period.\n\n\n\n\n\n","category":"method"},{"location":"reference/api/public/#PowerFlows.write_results-Tuple{Union{PowerFlowData{PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}, PowerNetworkMatrices.BA_Matrix{Tuple{Vector{Int64}, Vector{String}}, Tuple{Dict{Int64, Int64}, Dict{String, Int64}}}}, PowerFlowData{PowerNetworkMatrices.PTDF{Tuple{Vector{Int64}, Vector{String}}, Tuple{Dict{Int64, Int64}, Dict{String, Int64}}, Matrix{Float64}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}, PowerFlowData{PowerNetworkMatrices.VirtualPTDF{Tuple{Vector{String}, Vector{Int64}}, Tuple{Dict{String, Int64}, Dict{Int64, Int64}}}, PowerNetworkMatrices.ABA_Matrix{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}, KLU.KLUFactorization{Float64, Int64}}}}, System}","page":"Public API Reference","title":"PowerFlows.write_results","text":"Returns a dictionary containing the DC power flow results. Each key conresponds to the name of the considered time periods, storing a DataFrame with the PF results.\n\nArguments:\n\ndata::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}:       PowerFlowData strcuture containing power flows and bus angles.\nsys::PSY.System:       container storing the systam information.\n\n\n\n\n\n","category":"method"},{"location":"explanation/stub/#Explanation","page":"Explanation","title":"Explanation","text":"","category":"section"},{"location":"explanation/stub/","page":"Explanation","title":"Explanation","text":"Refer here to find context and further explanation of the workings of PowerAnalytics. ","category":"page"},{"location":"reference/developers/developer/#Guidelines-for-Developers","page":"Code Base Developer Guide","title":"Guidelines for Developers","text":"","category":"section"},{"location":"reference/developers/developer/","page":"Code Base Developer Guide","title":"Code Base Developer Guide","text":"In order to contribute to PowerSimulationsDynamics.jl repository please read the following sections of InfrastructureSystems.jl documentation in detail:","category":"page"},{"location":"reference/developers/developer/","page":"Code Base Developer Guide","title":"Code Base Developer Guide","text":"Style Guide\nContributing Guidelines","category":"page"},{"location":"reference/developers/developer/","page":"Code Base Developer Guide","title":"Code Base Developer Guide","text":"Pull requests are always welcome to fix bugs or add additional modeling capabilities.","category":"page"},{"location":"reference/developers/developer/","page":"Code Base Developer Guide","title":"Code Base Developer Guide","text":"All the code contributions need to include tests with a minimum coverage of 70%","category":"page"},{"location":"tutorials/stub/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/stub/","page":"Tutorials","title":"Tutorials","text":"Refer here for step-by-step tutorials that will guide you through the different capabilities of PowerAnalytics. ","category":"page"},{"location":"reference/developers/power_flow/#Power-Flow","page":"Power Flow","title":"Power Flow","text":"","category":"section"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"CurrentModule = PowerFlows","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"PowerFlows.jl provides the capability to run a power flow using the Newton-Raphson method, optionally enforcing reactive power constraints of generators. This power flow routine can be used to check for AC feasibility of results of DC optimal power flow.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"The power flow solver uses KLU.jl for Jacobian matrix factorization. The solver uses the current operating point in the buses to provide the initial guess. The initial guess is then adjusted to contain voltage magnitudes within a feasible range of 0.8 p.u. - 1.2 p.u.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"Limitations: The PowerFlow solver doesn't support systems with HVDC lines or Phase Shifting transformers yet. The power flow solver can't handle systems with islands.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"using PowerFlows\nusing PowerSystems\nusing PowerSystemCaseBuilder\n\nsystem_data = build_system(PSITestSystems, \"c_sys14\")","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"PowerFlows.jl has two modes of using the power flow solver.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"Solving the power flow for the current operating point in the system. Takes the data in the buses, the active_power and reactive_power fields in the static injection devices. Returns a dictionary with results in a DataFrame that can be exported or manipulated as needed.\nSolves the power flow and updated the devices in the system to the operating condition. This model will update the values of magnitudes and angles in the system's buses. It also updates the active and reactive power flows in the branches and devices connected to PV buses. It also updates the active and reactive power of the injection devices connected to the Slack bus, and updates only the reactive power of the injection devices connected to PV buses. If multiple devices are connected to the same bus, the power is divided proportional to the base power. This utility is useful to initialize systems before serializing or checking the addition of new devices is still AC feasible.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"Solving the power flow with mode 1:","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"pf = ACPowerFlow()\nresults = solve_powerflow(pf, system_data)\nresults[\"bus_results\"]","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"Solving the power flow with mode 2:","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"Before running the power flow command these are the values of the voltages:","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"for b in get_components(Bus, system_data)\n    println(\"$(get_name(b)) - Magnitude $(get_magnitude(b)) - Angle (rad) $(get_angle(b))\")\nend","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"solve_powerflow! return true or false to signal the successful result of the power flow. This enables the integration of a power flow into functions and use the return as check.","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"solve_powerflow!(pf, system_data; method = :newton)","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"After running the power flow command this are the values of the voltages:","category":"page"},{"location":"reference/developers/power_flow/","page":"Power Flow","title":"Power Flow","text":"for b in get_components(Bus, system_data)\n    println(\"$(get_name(b)) - Magnitude $(get_magnitude(b)) - Angle (rad) $(get_angle(b))\")\nend","category":"page"},{"location":"#PowerFlows.jl","page":"Welcome Page","title":"PowerFlows.jl","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"CurrentModule = PowerFlows","category":"page"},{"location":"#Overview","page":"Welcome Page","title":"Overview","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"PowerFlows.jl is part of the National Renewable Energy Laboratory's Sienna ecosystem, an open source framework for scheduling problems and dynamic simulations for power systems. The Sienna ecosystem can be found on github. The documentation is still in progress. ","category":"page"},{"location":"#Installation","page":"Welcome Page","title":"Installation","text":"","category":"section"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"The latest stable release of PowerFlows can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerFlows","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Welcome Page","title":"Welcome Page","text":"] add PowerFlows#main","category":"page"}]
}
