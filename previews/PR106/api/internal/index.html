<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Reference · PowerFlows.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">PowerFlows.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Welcome Page</a></li><li><span class="tocitem">Modeler Guide</span><ul><li><a class="tocitem" href="../../modeler_guide/power_flow/">Power Flow</a></li></ul></li><li><span class="tocitem">Code Base Developer Guide</span><ul><li><a class="tocitem" href="../../code_base_developer_guide/developer/">Developer Guide</a></li></ul></li><li><a class="tocitem" href="../public/">Public API Reference</a></li><li class="is-active"><a class="tocitem" href>Internal API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Internal API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/api/internal.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian" href="#PowerFlows.ACPowerFlowJacobian"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ACPowerFlowJacobian</code></pre><p>A struct that represents the Jacobian matrix for AC power flow calculations.</p><p>This struct uses the functor pattern, meaning instances of <code>ACPowerFlowJacobian</code> store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data used for power flow calculations.</li><li><code>Jf!::Function</code>: A function that calculates the Jacobian matrix inplace.</li><li><code>Jv::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix, which is updated by the function <code>Jf!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(time_step::Int64)</code></pre><p>Update the Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step.</p><p>Defining this method allows an instance of <code>ACPowerFlowJacobian</code> to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
J(time_step)  # Updates the Jacobian matrix Jv</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -&gt; ACPowerFlowJacobian</code></pre><p>This is the constructor for ACPowerFlowJacobian. Create an <code>ACPowerFlowJacobian</code> instance. As soon as the instance is created, it already has the Jacobian matrix structure initialized and its values updated, stored internally as Jv. The data instance is stored internally and used to update the Jacobian matrix because the structure of the Jacobian matrix is tied to the data. Changing the data requires creating a new instance of <code>ACPowerFlowJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data used for power flow calculations.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowJacobian</code>: An instance of <code>ACPowerFlowJacobian</code>.</li></ul><p>#Example</p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.
J(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.
J.Jv  # Access the Jacobian matrix stored internally in J.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L71-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}" href="#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)</code></pre><p>Use the <code>ACPowerFlowJacobian</code> to update the provided Jacobian matrix <code>J</code> inplace.</p><p>Update the internally stored Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step, and write the updated Jacobian values to <code>J</code>.</p><p>This method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>`: A sparse matrix to be updated with new values of the Jacobian matrix.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
Jv = SparseArrays.sparse(Float64[], Int32[], Int32[])
J(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L42-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.LinearSolverCache" href="#PowerFlows.LinearSolverCache"><code>PowerFlows.LinearSolverCache</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract supertype for all cached linear solvers. Subtypes must implement: <code>symbolic_factor!</code>, <code>symbolic_refactor!</code>, <code>numeric_refactor!</code> (which doubles as <code>numeric_factor!</code>), and <code>solve!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/LinearSolverCache/linear_solver_cache.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.SystemPowerFlowContainer" href="#PowerFlows.SystemPowerFlowContainer"><code>PowerFlows.SystemPowerFlowContainer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>PowerFlowContainer</code> that represents its data as a <code>PSY.System</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/PowerFlowData.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows._create_jacobian_matrix_structure-Tuple{PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -&gt; SparseMatrixCSC{Float64, Int32}</code></pre><p>Create the structure of the Jacobian matrix for an AC power flow problem. Inputs are the grid model as an instance of <code>ACPowerFlowData</code> at a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow model.</li><li><code>time_step::Int64</code>: The specific time step for which the Jacobian matrix structure is created.</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.</li></ul><p><strong>Description</strong></p><p>This function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.</p><p>Unlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus, corresponding to the following partial derivatives:</p><p>| ∂P₁/∂V₁  | ∂P₁/∂θ₁ | ...      | ...     | ...     | ...     | ...     | | ∂Q₁/∂V₁  | ∂Q₁/∂θ₁ | ...      | ...     | ...     | ...     | ...     |  | ...      |         | ∂P₂/∂V₂  | ∂P₂/∂θ₂ | ...     | ...     | ...     | | ...      |         | ∂Q₂/∂V₂  | ∂Q₂/∂θ₂ | ...     | ...     | ...     | | ...      | ...     | ...      | ...     | ...     | ∂Pₙ/∂Vₙ  | ∂Pₙ/∂θₙ | | ...      | ...     | ...      | ...     | ...     | ∂Qₙ/∂Vₙ  | ∂Qₙ/∂θₙ |</p><p>This approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.</p><p>The function initializes three arrays (<code>rows</code>, <code>columns</code>, and <code>values</code>) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.</p><p>For each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (<code>REF</code>, <code>PV</code>, or <code>PQ</code>).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.</p><ul><li>For <code>REF</code> buses, entries are added for local active and reactive power.</li><li>For <code>PV</code> buses, entries are added for active and reactive power with respect to angle, and for local reactive power.</li><li>For <code>PQ</code> buses, entries are added for active and reactive power with respect to voltage magnitude and angle.</li></ul><p>Finally, the function constructs a sparse matrix from the collected indices and values and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L101-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._first_choice_gen_id-Tuple{String}" href="#PowerFlows._first_choice_gen_id-Tuple{String}"><code>PowerFlows._first_choice_gen_id</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Try to make an informative one or two character name for the load/generator/etc.</p><ul><li>&quot;generator-1234-AB&quot; -&gt; &quot;AB&quot;</li><li>&quot;123<em>CT</em>7&quot; -&gt; &quot;7&quot;</li><li>&quot;load1234&quot; -&gt; &quot;34&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L495-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._get_load_data-Tuple{System, Bus}" href="#PowerFlows._get_load_data-Tuple{System, Bus}"><code>PowerFlows._get_load_data</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Obtain total load on bus b</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L121-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._map_psse_container_names-Tuple{Vector{String}}" href="#PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><code>PowerFlows._map_psse_container_names</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}" href="#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><code>PowerFlows._psse_bus_names</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}" href="#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><code>PowerFlows._psse_bus_numbers</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L341-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector{Tuple{Int64, Int64}}, AbstractDict{Int64, Int64}, Any}" href="#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector{Tuple{Int64, Int64}}, AbstractDict{Int64, Int64}, Any}"><code>PowerFlows._psse_transformer_names</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L855-L860">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._update_branch_flow!-Tuple{System}" href="#PowerFlows._update_branch_flow!-Tuple{System}"><code>PowerFlows._update_branch_flow!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates the flow on the branches</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L110-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}" href="#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlowData{PowerNetworkMatrices.Ybus{Tuple{Vector{Int64}, Vector{Int64}}, Tuple{Dict{Int64, Int64}, Dict{Int64, Int64}}}, Nothing}, Int64}"><code>PowerFlows._update_jacobian_matrix_values!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Used to update Jv based on the bus voltages, angles, etc. in data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/ac_power_flow_jacobian.jl#L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}" href="#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><code>PowerFlows.better_float_to_buf</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.check_33-Tuple{PSSEExporter}" href="#PowerFlows.check_33-Tuple{PSSEExporter}"><code>PowerFlows.check_33</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Throw a <code>NotImplementedError</code> if the <code>psse_version</code> is not <code>:v33</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T" href="#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>PowerFlows.convert_empty</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If <code>val</code> is empty, returns <code>T()</code>; if not, asserts that <code>val isa T</code> and returns <code>val</code>. Has nice type checker semantics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">convert_empty(Vector{String}, [])  # -&gt; String[]
convert_empty(Vector{String}, [&quot;a&quot;])  # -&gt; [&quot;a&quot;]
convert_empty(Vector{String}, [2])  # -&gt; TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}
Base.return_types(Base.Fix1(convert_empty, Vector{String}))  # -&gt; [Vector{String}]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L249-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T" href="#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><code>PowerFlows.create_component_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The &quot;singles<em>to</em>1&quot; flag detects components that are the only one on their bus and gives them the name &quot;1&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}" href="#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><code>PowerFlows.flatten_power_flow_evaluation_model</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Expand a single <code>PowerFlowEvaluationModel</code> into its possibly multiple parts for separate evaluation. Namely, if <code>pfem</code> contains a non-nothing <code>exporter</code>, return <code>[pfem, exporter]</code>, else return <code>[pfem]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/powerflow_types.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{ACBranch, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{ACBranch, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L77-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{TapTransformer, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{TapTransformer, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type TapTransformer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L64-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_func-Tuple{Transformer2W, ComplexF64, ComplexF64}" href="#PowerFlows.flow_func-Tuple{Transformer2W, ComplexF64, ComplexF64}"><code>PowerFlows.flow_func</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow using external data of voltages of branch of type Transformer2W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L89-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{ACBranch}" href="#PowerFlows.flow_val-Tuple{ACBranch}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L21-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{DynamicBranch}" href="#PowerFlows.flow_val-Tuple{DynamicBranch}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Line</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L36-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{TapTransformer}" href="#PowerFlows.flow_val-Tuple{TapTransformer}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type TapTransformer</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L5-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.flow_val-Tuple{Transformer2W}" href="#PowerFlows.flow_val-Tuple{Transformer2W}"><code>PowerFlows.flow_val</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculates the From - To complex power flow (Flow injected at the bus) of branch of type Transformer2W</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}" href="#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_active_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_active_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/common.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}" href="#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_reactive_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_reactive_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/common.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.make_power_flow_container" href="#PowerFlows.make_power_flow_container"><code>PowerFlows.make_power_flow_container</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Create an appropriate <code>PowerFlowContainer</code> for the given <code>PowerFlowEvaluationModel</code> and initialize it from the given <code>PSY.System</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pfem::PowerFlowEvaluationModel</code>: power flow model to construct a container for (e.g., <code>DCPowerFlow()</code>)</li><li><code>sys::PSY.System</code>: the system from which to initialize the power flow container</li><li><code>time_steps::Int</code>: number of time periods to consider (default is <code>1</code>)</li><li><code>timestep_names::Vector{String}</code>: names of the time periods defines by the argument &quot;time_steps&quot;. Default value is <code>String[]</code>.</li><li><code>check_connectivity::Bool</code>: Perform connectivity check on the network matrix. Default value is <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/PowerFlowData.jl#L478-L487">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Similar to above: A*X where X is a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/common.jl#L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/common.jl#L148-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.penalty_factors!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, SubArray{Float64}, Vector{Int64}}" href="#PowerFlows.penalty_factors!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, SubArray{Float64}, Vector{Int64}}"><code>PowerFlows.penalty_factors!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">penalty_factors!(J::SparseMatrixCSC{Float64, Int32}, dSbus_dV_ref::Vector{Float64}, destination::SubArray{Float64})</code></pre><p>Compute the penalty factors (active power loss factors) and store the result in <code>destination</code>, which is the view in the <code>loss_factors</code><code>matrix of the</code>PowerFlowData`<code>. The loss factors are computed using the Jacobian matrix</code>J<code>and the vector of partial derivatives of  slack power with respect to bus voltages (angle and magnitude)</code>dSbus<em>dV</em>ref`. The approach is interpreting the change in slack active power injection as the change of the grid active power losses. The function uses the KLU library for sparse matrix factorization to calculate the loss factors. The loss factors are a linear approximation of the change in slack active power injection respect to the change in active power injections at each bus.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix in sparse format.</li><li><code>dSbus_dV_ref::Vector{Float64}</code>: The reference vector for the change in slack bus power with respect to bus voltages (PV, PQ buses for voltage angle, PQ buses for voltage magnitude).</li><li><code>destination::SubArray{Float64}</code>: The view in the penalty factors matrix where the computed penalty factors will be stored.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L733-L748">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.reset_caches-Tuple{PSSEExporter}" href="#PowerFlows.reset_caches-Tuple{PSSEExporter}"><code>PowerFlows.reset_caches</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Force all cached information (serialized metadata, component lists, etc.) to be regenerated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}" href="#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><code>PowerFlows.serialize_component_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Take the output of <code>create_component_ids</code> and make it more suitable for JSON serialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}" href="#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><code>PowerFlows.supports_multi_period</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Trait signifying whether the <code>PowerFlowContainer</code> can represent multi-period data. Must be implemented for all concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/PowerFlowData.jl#L3-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.update_system!-Tuple{System, PowerFlowData}" href="#PowerFlows.update_system!-Tuple{System, PowerFlowData}"><code>PowerFlows.update_system!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Modify the values in the given <code>System</code> to correspond to the given <code>PowerFlowData</code> such that if a new <code>PowerFlowData</code> is constructed from the resulting system it is the same as <code>data</code>. See also <code>write_powerflow_solution!</code>. NOTE that this assumes that <code>data</code> was initialized from <code>sys</code> and then solved with no further modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L695-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_powerflow_solution!-Tuple{System, Vector{Float64}, PowerFlowData, Int64}" href="#PowerFlows.write_powerflow_solution!-Tuple{System, Vector{Float64}, PowerFlowData, Int64}"><code>PowerFlows.write_powerflow_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Updates system voltages and powers with power flow results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/post_processing.jl#L433-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L420-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Case Identification Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Fixed Bus Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L616-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>If the export<em>settings flag `sources</em>as<em>generators<code>is set, export</code>PSY.Source<code>instances as PSS/E generators in addition to</code>PSY.Generator<code>s. Same for</code>storages</em>as_generators<code>and</code>PSY.Storage`.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Generator Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L671-L677">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Load Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L574-L576">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Non-Transformer Branch Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L783-L785">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L1037-L1039">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Currently only supports two-winding transformers</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L900-L904">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Zone Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/9043a84608f479bf40914f21babba3081727fc2d/src/psse_export.jl#L1009-L1011">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 February 2025 22:28">Monday 24 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
