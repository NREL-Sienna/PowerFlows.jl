<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API Reference · PowerFlows.jl</title><meta name="title" content="Public API Reference · PowerFlows.jl"/><meta property="og:title" content="Public API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Public API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><a class="tocitem" href="../../../tutorials/stub/">Tutorials</a></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li><a class="tocitem" href="../../developers/lcc_model/">LCC Model Implementation</a></li><li class="is-active"><a class="tocitem" href>Public API Reference</a><ul class="internal"><li><a class="tocitem" href="#Powerflow-Evalution-Models-and-AC-Solvers"><span>Powerflow Evalution Models and AC Solvers</span></a></li><li><a class="tocitem" href="#Solving-Powerflows"><span>Solving Powerflows</span></a></li><li><a class="tocitem" href="#PowerFlowData"><span>PowerFlowData</span></a></li></ul></li><li><a class="tocitem" href="../internal/">Internal API Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Public API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/public.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlows"><a class="docs-heading-anchor" href="#PowerFlows">PowerFlows</a><a id="PowerFlows-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlows" title="Permalink"></a></h1><h2 id="Powerflow-Evalution-Models-and-AC-Solvers"><a class="docs-heading-anchor" href="#Powerflow-Evalution-Models-and-AC-Solvers">Powerflow Evalution Models and AC Solvers</a><a id="Powerflow-Evalution-Models-and-AC-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Powerflow-Evalution-Models-and-AC-Solvers" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlow"><a class="docstring-binding" href="#PowerFlows.ACPowerFlow"><code>PowerFlows.ACPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A struct for evaluating power flow solutions in AC systems.</p><p>This struct is parameterized by the type of AC power flow solver to use, which must be a subtype of <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a>. It also contains a few  fields that control whether to compute certain additional data, like loss factors:  see the constructor for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L39-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlow-Union{Tuple{}, Tuple{ACSolver}} where ACSolver&lt;:ACPowerFlowSolverType"><a class="docstring-binding" href="#PowerFlows.ACPowerFlow-Union{Tuple{}, Tuple{ACSolver}} where ACSolver&lt;:ACPowerFlowSolverType"><code>PowerFlows.ACPowerFlow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlow{ACSolver}(
    check_reactive_power_limits::Bool = false,
    exporter::Union{Nothing, PowerFlowEvaluationModel} = nothing,
    calculate_loss_factors::Bool = false,
    generator_slack_participation_factors::Union{
        Nothing,
        Dict{Tuple{DataType, String}, Float64},
        Vector{Dict{Tuple{DataType, String}, Float64}},
    } = nothing,
) where {ACSolver &lt;: ACPowerFlowSolverType}</code></pre><p>An evaluation model for a standard  <a href="https://en.wikipedia.org/wiki/Power-flow_study#Power-flow_problem_formulation">AC powerflow</a>  with the specified solver type.</p><p><strong>Arguments</strong></p><ul><li><code>ACSolver</code>: The type of AC power flow solver to use, which must be a subtype of <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a>.   Default is <a href="#PowerFlows.NewtonRaphsonACPowerFlow"><code>NewtonRaphsonACPowerFlow</code></a>.</li><li><code>check_reactive_power_limits::Bool</code>: Whether to check reactive power limits during the power flow solution.   Default is <code>false</code>.</li><li><code>exporter::Union{Nothing, PowerFlowEvaluationModel}</code>: An optional exporter for the power flow results.    If not <code>nothing</code>, it should be a <a href="#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><code>PSSEExportPowerFlow</code></a>.</li><li><code>calculate_loss_factors::Bool</code>: Whether to calculate loss factors during the power flow solution.   Default is <code>false</code>.</li><li><code>generator_slack_participation_factors::Union{Nothing, Dict{Tuple{DataType, String}, Float64}, Vector{Dict{Tuple{DataType, String}, Float64}}}</code>:   An optional parameter that specifies the participation factors for generator slack in the power flow solution.   If <code>nothing</code>, all slack is picked up by the reference bus. If a <code>Dict</code>, it should map <code>(component_type, component_name)</code>   tuples to participation factors. If a <code>Vector</code>, it should contain multiple such dictionaries,    allowing for different participation factors for different time steps.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L61-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowSolverType"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowSolverType"><code>PowerFlows.ACPowerFlowSolverType</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An abstract supertype for all iterative methods. Subtypes: <a href="#PowerFlows.NewtonRaphsonACPowerFlow"><code>NewtonRaphsonACPowerFlow</code></a>, <a href="#PowerFlows.TrustRegionACPowerFlow"><code>TrustRegionACPowerFlow</code></a>,  <a href="#PowerFlows.LevenbergMarquardtACPowerFlow"><code>LevenbergMarquardtACPowerFlow</code></a>, and <a href="#PowerFlows.RobustHomotopyPowerFlow"><code>RobustHomotopyPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L5-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.DCPowerFlow"><a class="docstring-binding" href="#PowerFlows.DCPowerFlow"><code>PowerFlows.DCPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DCPowerFlow(
    exporter::Union{Nothing, PowerFlowEvaluationModel} = nothing,
)</code></pre><p>An evaluation model for a standard DC powerflow.</p><p>This provides a fast approximate solution to the AC powerflow problem, by solving for the  bus voltage angles under some simplifying assumptions (lossless lines, constant voltage  magnitudes, etc.). For details, see  <a href="https://en.wikipedia.org/wiki/Power-flow_study#DC_power_flow">Wikipedia</a> or section 4 of the <a href="https://matpower.org/docs/MATPOWER-manual-4.1.pdf">MATPOWER docs</a>. If  not <code>nothing</code>, the <code>exporter</code> should be a <a href="#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><code>PSSEExportPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L167-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.LevenbergMarquardtACPowerFlow"><a class="docstring-binding" href="#PowerFlows.LevenbergMarquardtACPowerFlow"><code>PowerFlows.LevenbergMarquardtACPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LevenbergMarquardtACPowerFlow &lt;: ACPowerFlowSolverType</code></pre><p>An <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a> corresponding to the Levenberg-Marquardt iterative method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L25-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.NewtonRaphsonACPowerFlow"><a class="docstring-binding" href="#PowerFlows.NewtonRaphsonACPowerFlow"><code>PowerFlows.NewtonRaphsonACPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NewtonRaphsonACPowerFlow &lt;: ACPowerFlowSolverType</code></pre><p>An <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a> corresponding to a basic Newton-Raphson iterative method.  The Newton step is taken verbatim at each iteration: no line search is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L11-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PTDFDCPowerFlow"><a class="docstring-binding" href="#PowerFlows.PTDFDCPowerFlow"><code>PowerFlows.PTDFDCPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PTDFDCPowerFlow(
    exporter::Union{Nothing, PowerFlowEvaluationModel} = nothing,
)</code></pre><p>An evaluation model that calculates line flows using the Power Transfer Distribution Factor  Matrix.</p><p>This approximates the branch flows in the power grid, under some simplifying assumptions (lossless lines, constant voltage magnitudes, etc.). See section 4 of the  <a href="https://matpower.org/docs/MATPOWER-manual-4.1.pdf">MATPOWER docs</a> for details. If not  <code>nothing</code>, the <code>exporter</code> should be a <a href="#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><code>PSSEExportPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L185-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.RobustHomotopyPowerFlow"><a class="docstring-binding" href="#PowerFlows.RobustHomotopyPowerFlow"><code>PowerFlows.RobustHomotopyPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RobustHomotopyPowerFlow &lt;: ACPowerFlowSolverType</code></pre><p>An <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a> corresponding to a homotopy iterative method, based on the paper <a href="https://ieeexplore.ieee.org/document/6666905">&quot;Improving the robustness of Newton-based power flow methods to cope with poor  initial points&quot;</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L31-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.TrustRegionACPowerFlow"><a class="docstring-binding" href="#PowerFlows.TrustRegionACPowerFlow"><code>PowerFlows.TrustRegionACPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TrustRegionACPowerFlow &lt;: ACPowerFlowSolverType</code></pre><p>An <a href="#PowerFlows.ACPowerFlowSolverType"><code>ACPowerFlowSolverType</code></a> corresponding to the Powell dogleg iterative method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L19-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.vPTDFDCPowerFlow"><a class="docstring-binding" href="#PowerFlows.vPTDFDCPowerFlow"><code>PowerFlows.vPTDFDCPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">vPTDFDCPowerFlow(
    exporter::Union{Nothing, PowerFlowEvaluationModel} = nothing,
)</code></pre><p>An evaluation model that calculates line flows using a virtual Power Transfer Distribution  Factor Matrix.</p><p>This is a replacement for the <a href="#PowerFlows.PTDFDCPowerFlow">PTDFDCPowerFlow</a> for large grids,  where creating and storing the full PTDF matrix would be infeasible or slow. See the  <a href="https://nrel-sienna.github.io/PowerNetworkMatrices.jl/stable/">PowerNetworkMatrices.jl docs</a> for details.  If not <code>nothing</code>, the <code>exporter</code> should be a <a href="#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><code>PSSEExportPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L202-L214">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><a class="docstring-binding" href="#PowerFlows.PSSEExportPowerFlow-Tuple{Symbol, AbstractString}"><code>PowerFlows.PSSEExportPowerFlow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PSSEExportPowerFlow(psse_version::Symbol, export_dir::AbstractString; kwargs...)</code></pre><p>An evaluation model for exporting power flow results to PSSE format.</p><p>Arguments:</p><ul><li><code>psse_version::Symbol</code>: The version of PSSE to export to. Must be among <code>[:v33, :v35]</code>.</li><li><code>export_dir::AbstractString</code>: The directory where the PSSE files will be exported.</li></ul><p>Optional keyword arguments:</p><ul><li><code>name::AbstractString</code>: The base name for the exported files. Defaults to <code>&quot;export&quot;</code>.</li><li><code>write_comments::Bool</code>: Whether to write comments in the exported files. Defaults to <code>false</code>.</li><li><code>overwrite::Bool</code>: Whether to overwrite the file if it exists already. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L101-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PSSEExporter"><a class="docstring-binding" href="#PowerFlows.PSSEExporter"><code>PowerFlows.PSSEExporter</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Structure to perform an export from a Sienna System, plus optional updates from <code>PowerFlowData</code>, to the PSS/E format.</p><p>Construct this object from a <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> and a PSS/E version,  update using <code>update_exporter</code> with any new data as relevant, and perform the export with <code>write_export</code>. Writes a <code>&lt;name&gt;.raw</code> file and a <code>&lt;name&gt;_export_metadata.json</code> file with transformations that had to be made to conform to PSS/E naming rules, which can be parsed by PowerSystems.jl to perform a round trip with the names restored.</p><p><strong>Arguments:</strong></p><ul><li><code>base_system::PSY.System</code>: the system to be exported. Later updates may change power flow-related values but may not fundamentally alter the system</li><li><code>psse_version::Symbol</code>: the version of PSS/E to target, must be one of <code>[:v33, :v35]</code></li><li><code>write_comments::Bool = false</code>: whether to add the customary-but-not-in-spec-annotations after a slash on the first line and at group boundaries</li><li><code>name::AbstractString = &quot;export&quot;</code>: the base name of the export</li><li><code>step::Any = nothing</code>: optional step data to append to the base export name. User is responsible for updating the step data. If the step data is <code>nothing</code>, it is not used; if it is a tuple or vector, it is joined with _ and concatted; else it is concatted after _.</li><li><code>overwrite::Bool = false</code>: <code>true</code> to silently overwrite existing exports, <code>false</code> to throw an error if existing results are encountered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L134-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_psse_export_paths-Tuple{AbstractString}"><a class="docstring-binding" href="#PowerFlows.get_psse_export_paths-Tuple{AbstractString}"><code>PowerFlows.get_psse_export_paths</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Calculate the paths of the (raw, metadata) files that would be written by a certain call to <code>write_export</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2842">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.update_exporter!-Tuple{PSSEExporter, PowerFlowData}"><code>PowerFlows.update_exporter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the <code>PSSEExporter</code> with new <code>data</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>exporter::PSSEExporter</code>: the exporter to update</li><li><code>data::PSY.PowerFlowData</code>: the new data. Must correspond to the  <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> with which the exporter was constructed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L227-L234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_exporter!-Tuple{PSSEExporter, System}"><a class="docstring-binding" href="#PowerFlows.update_exporter!-Tuple{PSSEExporter, System}"><code>PowerFlows.update_exporter!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the <code>PSSEExporter</code> with new <code>data</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>exporter::PSSEExporter</code>: the exporter to update</li><li><code>data::PSY.System</code>: system containing the new data. Must be fundamentally the same <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> as the one with which the exporter was  constructed, just with different values — this is the user&#39;s responsibility, we do not  exhaustively verify it.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L248-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}"><a class="docstring-binding" href="#PowerFlows.write_export-Tuple{PSSEExporter, AbstractString}"><code>PowerFlows.write_export</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Perform an export from the data contained in a <code>PSSEExporter</code> to the PSS/E file format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2753">source</a></section></details></article><h2 id="Solving-Powerflows"><a class="docs-heading-anchor" href="#Solving-Powerflows">Solving Powerflows</a><a id="Solving-Powerflows-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Powerflows" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_powerflow!(data::PTDFPowerFlowData)</code></pre><p>Evaluates the PTDF power flow and writes the result to the fields of the  <a href="../internal/#PowerFlows.PTDFPowerFlowData"><code>PTDFPowerFlowData</code></a> structure.</p><p>This function modifies the following fields of <code>data</code>, setting them to the computed values:</p><ul><li><code>data.bus_angles</code>: the bus angles for each bus in the system.</li><li><code>data.branch_activepower_flow_from_to</code>: the active power flow from the &quot;from&quot; bus to the &quot;to&quot; bus of each branch</li><li><code>data.branch_activepower_flow_to_from</code>: the active power flow from the &quot;to&quot; bus to the &quot;from&quot; bus of each branch</li></ul><p>Additionally, it sets <code>data.converged</code> to <code>true</code>, indicating that the power flow calculation was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_dc_powerflow.jl#L22-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow!-Tuple{PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_powerflow!(data::vPTDFPowerFlowData)</code></pre><p>Evaluates the virtual PTDF power flow and writes the results to the fields  of the <a href="../internal/#PowerFlows.vPTDFPowerFlowData"><code>vPTDFPowerFlowData</code></a> structure.</p><p>This function modifies the following fields of <code>data</code>, setting them to the computed values:</p><ul><li><code>data.bus_angles</code>: the bus angles for each bus in the system.</li><li><code>data.branch_activepower_flow_from_to</code>: the active power flow from the &quot;from&quot; bus to the &quot;to&quot; bus of each branch</li><li><code>data.branch_activepower_flow_to_from</code>: the active power flow from the &quot;to&quot; bus to the &quot;from&quot; bus of each branch</li></ul><p>Additionally, it sets <code>data.converged</code> to <code>true</code>, indicating that the power flow calculation was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_dc_powerflow.jl#L59-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow-Tuple{Union{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, ABAPowerFlowData}, System}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow-Tuple{Union{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, ABAPowerFlowData}, System}"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Evaluates the power flows on the system&#39;s branches by means of the method associated with the <code>PowerFlowData</code> structure <code>data</code>, which can be one of <code>PTDFPowerFlowData</code>, <code>vPTDFPowerFlowData</code>, or <code>ABAPowerFlowData</code>. Returns a dictionary of <code>DataFrame</code>s, each containing the branch flows and bus voltages for the input <code>PSY.System</code> at that timestep.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}</code>:       <code>PowerFlowData</code> structure containing the system&#39;s data per each timestep       considered, as well as the associated matrix for the power flow.</li><li><code>sys::PSY.System</code>:       container gathering the system data.</li></ul><p>Note that <code>data</code> must have been created from the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System">System</a>  <code>sys</code> using one of the <a href="#PowerFlowData"><code>PowerFlowData</code></a> constructors.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PowerFlows, PowerSystemCaseBuilder
sys = build_system(PSITestSystems, &quot;c_sys14&quot;)
data = PowerFlowData(PTDFDCPowerFlow(), sys, time_steps = 2)
d = solve_powerflow(data, sys)
display(d[&quot;2&quot;][&quot;flow_results&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_dc_powerflow.jl#L171-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow-Union{Tuple{T}, Tuple{T, System}} where T&lt;:PowerFlows.AbstractDCPowerFlow"><a class="docstring-binding" href="#PowerFlows.solve_powerflow-Union{Tuple{T}, Tuple{T, System}} where T&lt;:PowerFlows.AbstractDCPowerFlow"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_powerflow(
    ::T,
    sys::PSY.System;
) where T &lt;: Union{PTDFDCPowerFlow, vPTDFDCPowerFlow, DCPowerFlow}</code></pre><p>Evaluates the provided DC power flow method <code>T</code> on the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System">PowerSystems.System</a> <code>sys</code>,  returning a dictionary of <code>DataFrame</code>s containing the calculated branch flows and bus angles.</p><p>Provided for convenience: this interface bypasses the need to create a <code>PowerFlowData</code>  struct, but that&#39;s still what&#39;s happening under the hood.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using PowerFlows, PowerSystemCaseBuilder
sys = build_system(PSITestSystems, &quot;c_sys5&quot;)
d = solve_powerflow(DCPowerFlow(), sys)
display(d[&quot;1&quot;][&quot;flow_results&quot;])
display(d[&quot;1&quot;][&quot;bus_results&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_dc_powerflow.jl#L135-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow!-Tuple{ACPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow!-Tuple{ACPowerFlow, System}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_powerflow!(pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}, system::PSY.System; kwargs...)</code></pre><p>Solves the power flow in the system and writes the solution into the relevant structs. Updates active and reactive power setpoints for generators and active and reactive power flows for branches (calculated in the From - To direction and in the To - From direction).</p><p>Supports passing kwargs to the PF solver.</p><p>The bus types can be changed from PV to PQ if the reactive power limits are violated.</p><p><strong>Arguments</strong></p><ul><li><a href="#PowerFlows.ACPowerFlow"><code>pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}</code></a>: The power flow solver instance.</li><li><code>system::PSY.System</code>: The power system model, a <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>PowerSystems.System</code></a> struct.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>check_connectivity::Bool</code>: Checks if the grid is connected. Default is <code>true</code>.</li><li><code>check_reactive_power_limits::Bool</code>: if <code>true</code>, the reactive power limits are    enforced by changing the respective bus types from PV to PQ. Default is <code>false</code>.</li><li><code>tol</code>: Infinite norm of residuals under which convergence is declared. Default is <code>1e-9</code>.</li><li><code>maxIterations</code>: Maximum number of Newton-Raphson iterations. Default is <code>30</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>converged::Bool</code>: Indicates whether the power flow solution converged.</li><li>The power flow results are written into the system struct.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">solve_powerflow!(pf, sys)

# Passing kwargs
solve_powerflow!(pf, sys; correct_bustypes = true)

# Passing keyword arguments
solve_powerflow!(pf, sys; maxIterations=100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_ac_powerflow.jl#L1-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow!-Tuple{ACPowerFlowData}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow!-Tuple{ACPowerFlowData}"><code>PowerFlows.solve_powerflow!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve_powerflow!(data::ACPowerFlowData; pf::ACPowerFlow{&lt;:ACPowerFlowSolverType} = ACPowerFlow(), kwargs...)</code></pre><p>Solve the multiperiod AC power flow problem for the given power flow data.</p><p>The bus types can be changed from PV to PQ if the reactive power limits are violated.</p><p><strong>Arguments</strong></p><ul><li><a href="#PowerFlows.ACPowerFlowData"><code>data::ACPowerFlowData</code></a>: The power flow data containing the grid information and initial conditions.</li><li><code>pf::ACPowerFlow{&lt;:ACPowerFlowSolverType}</code>: The power flow solver type. Defaults to <a href="#PowerFlows.NewtonRaphsonACPowerFlow"><code>NewtonRaphsonACPowerFlow</code></a>.</li><li><code>kwargs...</code>: Additional keyword arguments.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>check_connectivity::Bool</code>: Checks if the grid is connected. Default is <code>true</code>.</li><li><code>check_reactive_power_limits::Bool</code>: if <code>true</code>, the reactive power limits are    enforced by changing the respective bus types from PV to PQ. Default is <code>false</code>.</li><li><code>time_steps</code>: Specifies the time steps to solve. Defaults to sorting and collecting the keys of <code>data.timestep_map</code>.</li></ul><p><strong>Description</strong></p><p>This function solves the AC power flow problem for each time step specified in <code>data</code>.  It preallocates memory for the results and iterates over the sorted time steps.      For each time step, it calls the <code>_ac_powerflow</code> function to solve the power flow equations and updates the <code>data</code> object with the results.      If the power flow converges, it updates the active and reactive power injections, as well as the voltage magnitudes and angles for different bus types (REF, PV, PQ).      If the power flow does not converge, it sets the corresponding entries in <code>data</code> to <code>NaN</code>.      Finally, it calculates the branch power flows and updates the <code>data</code> object.</p><p><strong>Notes</strong></p><ul><li>If the grid topology changes (e.g., tap positions of transformers or in-service status of branches), the admittance matrices <code>Yft</code> and <code>Ytf</code> must be updated.</li><li>If <code>Yft</code> and <code>Ytf</code> change between time steps, the branch flow calculations must be moved inside the loop.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">solve_powerflow!(data)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_ac_powerflow.jl#L114-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.solve_powerflow-Tuple{ACPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.solve_powerflow-Tuple{ACPowerFlow, System}"><code>PowerFlows.solve_powerflow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Similar to solve_powerflow!(pf, sys) but does not update the system struct with results. Returns the results in a dictionary of dataframes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">res = solve_powerflow(pf, sys)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_ac_powerflow.jl#L73-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_results-Tuple{ACPowerFlow, System, ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows.write_results-Tuple{ACPowerFlow, System, ACPowerFlowData, Int64}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_results(
    ::ACPowerFlow{&lt;:ACPowerFlowSolverType},
    sys::PSY.System,
    data::ACPowerFlowData,
    time_step::Int64,
) -&gt; Dict{String, DataFrames.DataFrame}</code></pre><p>Returns a dictionary containing the AC power flow results.</p><p>Only single-period evaluation is supported at the moment for AC Power flows. The resulting dictionary will therefore feature just one key linked to one <code>DataFrame</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>::ACPowerFlow</code>:       use ACPowerFlow() storing AC power flow results.</li><li><code>sys::PSY.System</code>:       container storing the system information.</li><li><code>result::Vector{Float64}</code>:       vector containing the results for one single time-period.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L913-L933">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_results-Tuple{Union{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, ABAPowerFlowData}, System}"><a class="docstring-binding" href="#PowerFlows.write_results-Tuple{Union{PowerFlowData{PowerNetworkMatrices.DC_PTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, PowerFlowData{PowerNetworkMatrices.DC_vPTDF_Matrix, PowerNetworkMatrices.DC_ABA_Matrix_Factorized}, ABAPowerFlowData}, System}"><code>PowerFlows.write_results</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">write_results(
    data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData},
    sys::PSY.System,
)</code></pre><p>Returns a dictionary containing the DC power flow results. Each key corresponds to the name of the considered time periods, storing a <code>DataFrame</code> with the powerflow results.</p><p><strong>Arguments:</strong></p><ul><li><code>data::Union{PTDFPowerFlowData, vPTDFPowerFlowData, ABAPowerFlowData}</code>:       PowerFlowData structure containing power flows and bus angles.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>PowerSystems.System</code></a> object storing the system information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L847-L862">source</a></section></details></article><h2 id="PowerFlowData"><a class="docs-heading-anchor" href="#PowerFlowData">PowerFlowData</a><a id="PowerFlowData-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlowData" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ABAPowerFlowData"><a class="docstring-binding" href="#PowerFlows.ABAPowerFlowData"><code>PowerFlows.ABAPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>DCPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L173-L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowData"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowData"><code>PowerFlows.ACPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>ACPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L125-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData"><a class="docstring-binding" href="#PowerFlows.PowerFlowData"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData{M &lt;: PNM.PowerNetworkMatrix, N &lt;: Union{PNM.PowerNetworkMatrix, Nothing}}</code></pre><p>Structure containing all the data required for the evaluation of the power flows and angles, as well as these ones.</p><p>All fields starting with <code>bus_</code> are ordered according to <code>bus_lookup</code>, and all fields  starting with <code>arc_</code> are ordered according to <code>arc_lookup</code>: one row per bus/arc,  one column per time period. Here, buses should be understood as &quot;buses remaining, after  the network reduction.&quot; Similarly, we use &quot;arcs&quot; instead of &quot;branches&quot; to distinguish  between network elements (post-reduction) and system objects (pre-reduction).</p><p>Generally, do not construct this directly. Instead, use one of the later constructors to  pass in a <code>PowerFlowEvaluationModel</code> and a <code>PowerSystems.System</code>.  <code>aux\_network\_matrix</code> and <code>power\_network\_matrix</code> will then be set to the appropriate  matrices that are needed for computing that type of powerflow. See also <code>ACPowerFlowData</code>, <code>ABAPowerFlowData</code>, <code>PTDFPowerFlowData</code>, and <code>vPTDFPowerFlowData</code>:  these are all aliases for <code>PowerFlowData{N, M}</code> with specific <code>N</code>,<code>M</code>, that are used for  the respective type of power flow evaluations.</p><p><strong>Fields:</strong></p><ul><li><code>bus_activepower_injection::Matrix{Float64}</code>:       matrix containing the bus active power injection.</li><li><code>bus_reactivepower_injection::Matrix{Float64}</code>:       matrix containing the bus reactive power injection.</li><li><code>bus_activepower_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power withdrawals.</li><li><code>bus_reactivepower_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power withdrawals.</li><li><code>bus_activepower_constant_current_withdrawals::Matrix{Float64}</code>:       matrix containing the bus active power constant current       withdrawals.</li><li><code>bus_reactivepower_constant_current_withdrawals::Matrix{Float64}</code>:       matrix containing the bus reactive power constant current       withdrawals.</li><li><code>bus_activepower_constant_impedance_withdrawals::Matrix{Float64}</code>:       matrix containing the bus active power constant impedance       withdrawals.</li><li><code>bus_reactivepower_constant_impedance_withdrawals::Matrix{Float64}</code>:         matrix containing the bus reactive power constant impedance       withdrawals.</li><li><code>bus_reactivepower_bounds::Matrix{Float64}</code>:       matrix containing upper and lower bounds for the reactive supply at each       bus at each time period.</li><li><code>bus_type::Matrix{PSY.ACBusTypes}</code>:       matrix containing type of buses present in the system.</li><li><code>bus_magnitude::Matrix{Float64}</code>:       matrix containing the bus voltage magnitudes.</li><li><code>bus_angles::Matrix{Float64}</code>:       matrix containing the bus voltage angles.</li><li><code>arc_activepower_flow_from_to::Matrix{Float64}</code>:       matrix containing the active power flows measured at the <code>from</code> bus.</li><li><code>arc_reactivepower_flow_from_to::Matrix{Float64}</code>:       matrix containing the reactive power flows measured at the <code>from</code> bus.</li><li><code>arc_activepower_flow_to_from::Matrix{Float64}</code>:       matrix containing the active power flows measured at the <code>to</code> bus.</li><li><code>arc_reactivepower_flow_to_from::Matrix{Float64}</code>:       matrix containing the reactive power flows measured at the <code>to</code> bus.</li><li><code>timestep_map::Dict{Int, String}</code>:       dictionary mapping the number of the time periods (corresponding to the       column number of the previously mentioned matrices) and their names.</li><li><code>power_network_matrix::M</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>aux_network_matrix::N</code>:       matrix used for the evaluation of either the power flows or bus angles,       depending on the method considered.</li><li><code>neighbors::Vector{Set{Int}}</code>: Vector with the sets of adjacent buses.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L18-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{ACPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    pf::ACPowerFlow{&lt;:ACPowerFlowSolverType},
    sys::PSY.System;
    time_steps::Int = 1,
    timestep_names::Vector{String} = String[],
    check_connectivity::Bool = true
) -&gt; ACPowerFlowData{&lt;:ACPowerFlowSolverType}</code></pre><p>Creates the structure for an AC power flow calculation, given the  <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>, the number of time periods to  consider, and their names.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="#PowerFlows.ACPowerFlow"><code>ACPowerFlow</code></a>: this version is used to solve  AC powerflows, and returns an <a href="#PowerFlows.ACPowerFlowData"><code>ACPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="#PowerFlows.ACPowerFlow"><code>pf::ACPowerFlow</code></a>:       the settings for the AC power flow solver.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power        grid under consideration.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the <code>PowerFlowData</code> structure. It       defines the number of columns of the matrices used to store data.       Default value = <code>1</code>.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defined by the argument <code>time_steps</code>. Default       value = <code>String[]</code>.</li><li><code>check_connectivity::Bool</code>:       Perform connectivity check on the network matrix. Default value = <code>true</code>.</li></ul><p>WARNING: functions for the evaluation of the multi-period AC PF still to be implemented.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L455-L489">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{DCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">PowerFlowData(
    ::DCPowerFlow,
    sys::PSY.System;
    time_steps::Int = 1,
    timestep_names::Vector{String} = String[],
    check_connectivity::Bool = true
) -&gt; ABAPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a stnadard DC power flow calculation,  given the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>, the number of time periods to  consider, and their names.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="#PowerFlows.DCPowerFlow"><code>DCPowerFlow</code></a>: this version is  used to solve DC powerflows, and returns an <a href="#PowerFlows.ABAPowerFlowData"><code>ABAPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="#PowerFlows.DCPowerFlow"><code>::DCPowerFlow</code></a>:       Run a DC powerflow: internally, store the ABA matrix as <code>power_network_matrix</code> and       the BA matrix as <code>aux_network_matrix</code>.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power        grid under consideration.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the <code>PowerFlowData</code> structure. It       defines the number of columns of the matrices used to store data.       Default value = <code>1</code>.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defined by the argument <code>time_steps</code>. Default       value = <code>String[]</code>.</li><li><code>check_connectivity::Bool</code>:       Perform connectivity check on the network matrix. Default value = <code>true</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L526-L559">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{PTDFDCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{PTDFDCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function PowerFlowData(
    ::PTDFDCPowerFlow,
    sys::PSY.System;
    time_steps::Int = 1,
    timestep_names::Vector{String} = String[]
) -&gt; PTDFPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a Partial Transfer  Distribution Factor Matrix DC power flow calculation, given the  <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>, the number of time periods to  consider, and their names.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="#PowerFlows.PTDFDCPowerFlow"><code>PTDFDCPowerFlow</code></a>: this version is used to solve  DC powerflows via the Power Transfer Distribution Factor (PTDF) matrix. This function  returns an <a href="../internal/#PowerFlows.PTDFPowerFlowData"><code>PTDFPowerFlowData</code></a> object.</p><p><strong>Arguments:</strong></p><ul><li><a href="#PowerFlows.PTDFDCPowerFlow"><code>::PTDFDCPowerFlow</code></a>:       Run a DC powerflow with PTDF matrix: internally, store the PTDF matrix       as <code>power_network_matrix</code> and the ABA matrix as <code>aux_network_matrix</code>.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power        grid under consideration.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the <code>PowerFlowData</code> structure. It       defines the number of columns of the matrices used to store data.       Default value = <code>1</code>.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defined by the argument <code>time_steps</code>. Default       value = <code>String[]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L585-L617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Tuple{vPTDFDCPowerFlow, System}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">function PowerFlowData(
    ::vPTDFDCPowerFlow,
    sys::PSY.System;
    time_steps::Int = 1,
    timestep_names::Vector{String} = String[]
) -&gt; vPTDFPowerFlowData</code></pre><p>Creates a <code>PowerFlowData</code> structure configured for a virtual Partial Transfer  Distribution Factor Matrix DC power flow calculation, given the  <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> <code>sys</code>, the number of time periods to consider, and  their names.</p><p>Calling this function will not evaluate the power flows and angles. Note that first input is of type <a href="#PowerFlows.vPTDFDCPowerFlow"><code>vPTDFDCPowerFlow</code></a>: this version is used to solve  DC powerflows using a virtual Power Transfer Distribution Factor (PTDF) matrix. This  function returns a <a href="../internal/#PowerFlows.vPTDFPowerFlowData"><code>vPTDFPowerFlowData</code></a> object.</p><p>For internal usage: generally, do not construct this directly.</p><p><strong>Arguments:</strong></p><ul><li><a href="#PowerFlows.PTDFDCPowerFlow"><code>::PTDFDCPowerFlow</code></a>:       Run a virtual PTDF powerflow: internally, store the virtual PTDF matrix       <code>power_network_matrix</code> and the ABA matrix as <code>aux_network_matrix</code>.</li><li><code>sys::PSY.System</code>:       A <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> object that represents the power        grid under consideration.</li><li><code>time_steps::Int</code>:       number of time periods to consider in the PowerFlowData structure. It       defines the number of columns of the matrices used to store data.       Default value = <code>1</code>.</li><li><code>timestep_names::Vector{String}</code>:       names of the time periods defined by the argument &quot;time_steps&quot;. Default       value = <code>String[]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L643-L677">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64, Int64}} where {T&lt;:PowerFlows.PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}"><a class="docstring-binding" href="#PowerFlows.PowerFlowData-Union{Tuple{N}, Tuple{M}, Tuple{T}, Tuple{T, M, N, Int64, Int64}} where {T&lt;:PowerFlows.PowerFlowEvaluationModel, M&lt;:PowerNetworkMatrices.PowerNetworkMatrix, N&lt;:Union{Nothing, PowerNetworkMatrices.PowerNetworkMatrix}}"><code>PowerFlows.PowerFlowData</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the two <code>PowerNetworkMatrix</code> fields and a few others (<code>timesteps</code>, <code>timestep_map</code>),  then creates arrays of default values (usually zeros) for the rest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L295-L298">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../developers/lcc_model/">« LCC Model Implementation</a><a class="docs-footer-nextpage" href="../internal/">Internal API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 21:35">Wednesday 3 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
