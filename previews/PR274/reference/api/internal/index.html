<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal API Reference · PowerFlows.jl</title><meta name="title" content="Internal API Reference · PowerFlows.jl"/><meta property="og:title" content="Internal API Reference · PowerFlows.jl"/><meta property="twitter:title" content="Internal API Reference · PowerFlows.jl"/><meta name="description" content="Documentation for PowerFlows.jl."/><meta property="og:description" content="Documentation for PowerFlows.jl."/><meta property="twitter:description" content="Documentation for PowerFlows.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="PowerFlows.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">PowerFlows.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Welcome Page</a></li><li><a class="tocitem" href="../../../how-tos/stub/">How-to-Guides</a></li><li><a class="tocitem" href="../../../tutorials/stub/">Tutorials</a></li><li><a class="tocitem" href="../../../explanation/stub/">Explanation</a></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../../developers/developer/">Code Base Developer Guide</a></li><li><a class="tocitem" href="../../developers/lcc_model/">LCC Model Implementation</a></li><li><a class="tocitem" href="../public/">Public API Reference</a></li><li class="is-active"><a class="tocitem" href>Internal API Reference</a><ul class="internal"><li><a class="tocitem" href="#Power-Flow-Data-Structures"><span>Power Flow Data Structures</span></a></li><li><a class="tocitem" href="#LCC-HVDC-Parameters-and-Utilities"><span>LCC HVDC Parameters and Utilities</span></a></li><li><a class="tocitem" href="#Power-Flow-Initialization"><span>Power Flow Initialization</span></a></li><li><a class="tocitem" href="#AC-Power-Flow-Residuals"><span>AC Power Flow - Residuals</span></a></li><li><a class="tocitem" href="#AC-Power-Flow-Jacobian"><span>AC Power Flow - Jacobian</span></a></li><li><a class="tocitem" href="#DC-Power-Flow"><span>DC Power Flow</span></a></li><li><a class="tocitem" href="#Robust-Homotopy-Method"><span>Robust Homotopy Method</span></a></li><li><a class="tocitem" href="#Post-Processing"><span>Post-Processing</span></a></li><li><a class="tocitem" href="#PSSE-Export"><span>PSSE Export</span></a></li><li><a class="tocitem" href="#Power-Systems-Utilities"><span>Power Systems Utilities</span></a></li><li><a class="tocitem" href="#Common-Utilities-and-Definitions"><span>Common Utilities and Definitions</span></a></li><li><a class="tocitem" href="#Power-Flow-Types"><span>Power Flow Types</span></a></li><li><a class="tocitem" href="#Power-Flow-Methods"><span>Power Flow Methods</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Internal API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Internal API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/main/docs/src/reference/api/internal.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h1><h2 id="Power-Flow-Data-Structures"><a class="docs-heading-anchor" href="#Power-Flow-Data-Structures">Power Flow Data Structures</a><a id="Power-Flow-Data-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Data-Structures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.PTDFPowerFlowData"><a class="docstring-binding" href="#PowerFlows.PTDFPowerFlowData"><code>PowerFlows.PTDFPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>PTDFDCPowerFlow</code> method .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L141-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.SystemPowerFlowContainer"><a class="docstring-binding" href="#PowerFlows.SystemPowerFlowContainer"><code>PowerFlows.SystemPowerFlowContainer</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A <code>PowerFlowContainer</code> that represents its data as a <code>PSY.System</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.vPTDFPowerFlowData"><a class="docstring-binding" href="#PowerFlows.vPTDFPowerFlowData"><code>PowerFlows.vPTDFPowerFlowData</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>A type alias for a <code>PowerFlowData</code> struct whose type parameters are configured for the <code>vPTDFDCPowerFlow</code> method.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L156-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.make_power_flow_container"><a class="docstring-binding" href="#PowerFlows.make_power_flow_container"><code>PowerFlows.make_power_flow_container</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Create an appropriate <code>PowerFlowContainer</code> for the given <code>PowerFlowEvaluationModel</code> and initialize it from the given <code>PSY.System</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>pfem::PowerFlowEvaluationModel</code>: power flow model to construct a container for (e.g., <code>DCPowerFlow()</code>)</li><li><code>sys::PSY.System</code>: the <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System">System</a> from which to initialize the    power flow container</li><li><code>time_steps::Int</code>: number of time periods to consider (default is <code>1</code>)</li><li><code>timestep_names::Vector{String}</code>: names of the time periods defines by the argument &quot;time_steps&quot;. Default value is <code>String[]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L703-L712">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><a class="docstring-binding" href="#PowerFlows.supports_multi_period-Tuple{PowerFlows.PowerFlowContainer}"><code>PowerFlows.supports_multi_period</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Trait signifying whether the <code>PowerFlowContainer</code> can represent multi-period data. Must be implemented for all concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/PowerFlowData.jl#L3-L6">source</a></section></details></article><h2 id="LCC-HVDC-Parameters-and-Utilities"><a class="docs-heading-anchor" href="#LCC-HVDC-Parameters-and-Utilities">LCC HVDC Parameters and Utilities</a><a id="LCC-HVDC-Parameters-and-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#LCC-HVDC-Parameters-and-Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dV_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dV_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dV_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to voltage magnitude Vm for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dt_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_dQ_dt_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dt_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to transformer tap t for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L41-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_dQ_dα_lcc-NTuple{6, Float64}"><code>PowerFlows._calculate_dQ_dα_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_dQ_dα_lcc(t::Float64, I_dc::Float64, x_t::Float64, Vm::Float64, ϕ::Float64, α::Float64) -&gt; Float64</code></pre><p>Compute the derivative of reactive power Q with respect to firing/extinction angle α for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L57-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_y_lcc-NTuple{4, Float64}"><code>PowerFlows._calculate_y_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_y_lcc(t::Float64, I_dc::Float64, Vm::Float64, ϕ::Float64) -&gt; ComplexF64</code></pre><p>Compute the admittance value Y for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><a class="docstring-binding" href="#PowerFlows._calculate_ϕ_lcc-NTuple{5, Float64}"><code>PowerFlows._calculate_ϕ_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_calculate_ϕ_lcc(α::Float64, I_dc::Float64, x_t::Float64, Vm::Float64) -&gt; Float64</code></pre><p>Compute the phase angle ϕ for LCC converter calculations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows.initialize_LCC_arcs_and_buses!-Tuple{PowerFlowData, Vector{TwoTerminalLCCLine}, Dict{Int64, Int64}, Dict{Int64, Int64}}"><code>PowerFlows.initialize_LCC_arcs_and_buses!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Initialize the <code>arcs</code> and <code>bus_indices</code> fields of the LCCParameters structure in the PowerFlowData.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/lcc_utils.jl#L107-L109">source</a></section></details></article><h2 id="Power-Flow-Initialization"><a class="docs-heading-anchor" href="#Power-Flow-Initialization">Power Flow Initialization</a><a id="Power-Flow-Initialization-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Initialization" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.initialize_powerflow_data!-Tuple{PowerFlowData, PowerFlows.PowerFlowEvaluationModel, System}"><a class="docstring-binding" href="#PowerFlows.initialize_powerflow_data!-Tuple{PowerFlowData, PowerFlows.PowerFlowEvaluationModel, System}"><code>PowerFlows.initialize_powerflow_data!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the fields of a PowerFlowData struct to match the given System.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/initialize_powerflow_data.jl#L1-L3">source</a></section></details></article><h2 id="AC-Power-Flow-Residuals"><a class="docs-heading-anchor" href="#AC-Power-Flow-Residuals">AC Power Flow - Residuals</a><a id="AC-Power-Flow-Residuals-1"></a><a class="docs-heading-anchor-permalink" href="#AC-Power-Flow-Residuals" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowResidual</code></pre><p>A struct to keep track of the residuals in the Newton-Raphson AC power flow calculation.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data.</li><li><code>Rf!::Function</code>: A function that updates the residuals based on the latest values stored in the grid at the given iteration.</li><li><code>Rv::Vector{Float64}</code>: A vector of the values of the residuals.</li><li><code>P_net::Vector{Float64}</code>: A vector of net active power injections.</li><li><code>Q_net::Vector{Float64}</code>: A vector of net reactive power injections.</li><li><code>P_net_set::Vector{Float64}</code>: A vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: A sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>subnetworks::Dict{Int64, Vector{Int64}}</code>: The dictionary that identifies subnetworks (connected components), with the key defining the REF bus, values defining the corresponding buses in the subnetwork.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_residual.jl#L1-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{ACPowerFlowData, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowResidual(data::ACPowerFlowData, time_step::Int64)</code></pre><p>Create an instance of <code>ACPowerFlowResidual</code> for a given time step.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data representing the power system model.</li><li><code>time_step::Int64</code>: The time step for which the power flow calculation is executed.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowResidual</code>: An instance containing the residual values, net bus active power injections,    and net bus reactive power injections.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_residual.jl#L27-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(x::Vector{Float64}, time_step::Int64)</code></pre><p>Update the AC power flow residuals inplace and store the result in the attribute <code>Rv</code> of the struct. The inputs are the values of state vector <code>x</code> and the current time step <code>time_step</code>. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Float64}</code>: The state vector values.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_residual.jl#L146-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowResidual-Tuple{Vector{Float64}, Vector{Float64}, Int64}"><code>PowerFlows.ACPowerFlowResidual</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(Residual::ACPowerFlowResidual)(Rv::Vector{Float64}, x::Vector{Float64}, time_step::Int64)</code></pre><p>Evaluate the AC power flow residuals and store the result in <code>Rv</code> using the provided state vector <code>x</code> and the current time step <code>time_step</code>. The residuals are updated inplace in the struct and additionally copied to the provided array. This function implements the functor approach for the <code>ACPowerFlowResidual</code> struct. This makes the struct callable. Calling the <code>ACPowerFlowResidual</code> will also update the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>Rv::Vector{Float64}</code>: The vector to store the calculated residuals.</li><li><code>x::Vector{Float64}</code>: The state vector.</li><li><code>time_step::Int64</code>: The current time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_residual.jl#L111-L125">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._update_residual_values!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseVector{Float64, Int64}, Dict{Int64, Vector{Int64}}, ACPowerFlowData, Int64}"><code>PowerFlows._update_residual_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_residual_values!(
    F::Vector{Float64},
    x::Vector{Float64},
    P_net::Vector{Float64},
    Q_net::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64,
)</code></pre><p>Update the residual values for the Newton-Raphson AC power flow calculation. This function is used internally in the <code>ACPowerFlowResidual</code> struct. This function also updates the values of P, Q, V, Θ in the <code>data</code> struct.</p><p><strong>Arguments</strong></p><ul><li><code>F::Vector{Float64}</code>: Vector of the values of the residuals.</li><li><code>x::Vector{Float64}</code>: State vector values.</li><li><code>P_net::Vector{Float64}</code>: Vector of net active power injections at each bus.</li><li><code>Q_net::Vector{Float64}</code>: Vector of net reactive power injections at each bus.</li><li><code>P_net_set::Vector{Float64}</code>: Vector of the set-points for active power injections (their initial values before power flow calculation).</li><li><code>bus_slack_participation_factors::SparseVector{Float64, Int}</code>: Sparse vector of the slack participation factors aggregated at the bus level.</li><li><code>ref_bus::Int</code>: The index of the reference bus to be used for the total slack power.</li><li><code>data::ACPowerFlowData</code>: Data structure representing the grid model for the AC power flow calculation.</li><li><code>time_step::Int64</code>: The current time step for which the residual values are being updated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_residual.jl#L270-L293">source</a></section></details></article><h2 id="AC-Power-Flow-Jacobian"><a class="docs-heading-anchor" href="#AC-Power-Flow-Jacobian">AC Power Flow - Jacobian</a><a id="AC-Power-Flow-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#AC-Power-Flow-Jacobian" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ACPowerFlowJacobian</code></pre><p>A struct that represents the Jacobian matrix for AC power flow calculations.</p><p>This struct uses the functor pattern, meaning instances of <code>ACPowerFlowJacobian</code> store the data (Jacobian matrix) internally and can be called as a function at the same time. Calling the instance as a function updates the stored Jacobian matrix.</p><p><strong>Fields</strong></p><ul><li><code>data::ACPowerFlowData</code>: The grid model data used for power flow calculations.</li><li><code>Jf!::Function</code>: A function that calculates the Jacobian matrix inplace.</li><li><code>Jv::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>: The Jacobian matrix, which is updated by the function <code>Jf!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L1-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{ACPowerFlowData, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ACPowerFlowJacobian(data::ACPowerFlowData, time_step::Int64) -&gt; ACPowerFlowJacobian</code></pre><p>This is the constructor for ACPowerFlowJacobian. Create an <code>ACPowerFlowJacobian</code> instance. As soon as the instance is created, it already has  the Jacobian matrix structure initialized and its values updated, stored internally as <code>Jv</code>. The data instance is stored internally and used to update the Jacobian matrix because the  structure of the Jacobian matrix is tied to the data. Changing the data requires creating a  new instance of <code>ACPowerFlowJacobian</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data used for power flow calculations.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Returns</strong></p><ul><li><code>ACPowerFlowJacobian</code>: An instance of <code>ACPowerFlowJacobian</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)  # Creates an instance J of ACPowerFlowJacobian, with the Jacobian matrix stored internally as J.Jv initialized and updated.
J(time_step)  # Updates the Jacobian matrix stored internally in J (J.Jv) with the latest state of the `data` (`ACPowerFlowData` instance) and the provided time step.
J.Jv  # Access the Jacobian matrix stored internally in J.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L72-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(time_step::Int64)</code></pre><p>Update the Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step.</p><p>Defining this method allows an instance of <code>ACPowerFlowJacobian</code> to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
J(time_step)  # Updates the Jacobian matrix Jv</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L22-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows.ACPowerFlowJacobian-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows.ACPowerFlowJacobian</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">(J::ACPowerFlowJacobian)(J::SparseArrays.SparseMatrixCSC{Float64, Int32}, time_step::Int64)</code></pre><p>Use the <code>ACPowerFlowJacobian</code> to update the provided Jacobian matrix <code>J</code> inplace.</p><p>Update the internally stored Jacobian matrix <code>Jv</code> using the function <code>Jf!</code> and the provided data and time step, and write the updated Jacobian values to <code>J</code>.</p><p>This method allows an instance of ACPowerFlowJacobian to be called as a function, following the functor pattern.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseArrays.SparseMatrixCSC{Float64, Int32}</code>`: A sparse matrix to be updated with new values of the Jacobian matrix.</li><li><code>time_step::Int64</code>: The time step for the calculations.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">J = ACPowerFlowJacobian(data, time_step)
Jv = SparseArrays.sparse(Float64[], Int32[], Int32[])
J(Jv, time_step)  # Updates the Jacobian matrix Jv and writes it to J</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L43-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><a class="docstring-binding" href="#PowerFlows._block_J_indices-Tuple{Vector{&lt;:Integer}, Vector{&lt;:Integer}}"><code>PowerFlows._block_J_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_block_J_indices(data::ACPowerFlowData, time_step::Int) -&gt; (Vector{Int32}, Vector{Int32})</code></pre><p>Get the indices to reindex the Jacobian matrix from the interleaved form to the block form:</p><p class="math-container">\[\begin{bmatrix}
\frac{\partial P}{\partial \theta} &amp; \frac{\partial P}{\partial V} \\
\frac{\partial Q}{\partial \theta} &amp; \frac{\partial Q}{\partial V}
\end{bmatrix}\]</p><p><strong>Arguments</strong></p><ul><li><code>pvpq::Vector{Int32}</code>: Indices of the buses that are PV or PQ buses.</li><li><code>pq::Vector{Int32}</code>: Indices of the buses that are PQ buses.</li></ul><p><strong>Returns</strong></p><ul><li><code>rows::Vector{Int32}</code>: Row indices for the block Jacobian matrix.</li><li><code>cols::Vector{Int32}</code>: Column indices for the block Jacobian matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L731-L750">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_loss_factors-Tuple{ACPowerFlowData, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_loss_factors-Tuple{ACPowerFlowData, SparseArrays.SparseMatrixCSC{Float64, Int32}, Int64}"><code>PowerFlows._calculate_loss_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_loss_factors(data::ACPowerFlowData, Jv::SparseMatrixCSC{Float64, Int32}, time_step::Int)</code></pre><p>Calculate and store the active power loss factors in the <code>loss_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step.</p><p>The loss factors are computed using the Jacobian matrix <code>Jv</code> and the vector <code>dSbus_dV_ref</code>, which contains the  partial derivatives of slack power with respect to bus voltages. The function interprets changes in  slack active power injection as indicative of changes in grid active power losses.  KLU is used to factorize the sparse Jacobian matrix to solve for the loss factors.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The data structure containing power flow information, including the <code>loss_factors</code> matrix.</li><li><code>Jv::SparseMatrixCSC{Float64, Int32}</code>: The sparse Jacobian matrix of the power flow system.</li><li><code>time_step::Int</code>: The time step index for which the loss factors are calculated.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L660-L674">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_voltage_stability_factors-Tuple{ACPowerFlowData, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._calculate_voltage_stability_factors-Tuple{ACPowerFlowData, SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._calculate_voltage_stability_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">calculate_voltage_stability_factors(data::ACPowerFlowData, J::ACPowerFlowJacobian, time_step::Integer)</code></pre><p>Calculate and store the voltage stability factors in the <code>voltage_stability_factors</code> matrix of the <code>ACPowerFlowData</code> structure for a given time step. The voltage stability factors are computed using the Jacobian matrix <code>J</code> in block format after a converged power flow calculation.  The results are stored in the <code>voltage_stability_factors</code> matrix in the <code>data</code> instance. The factor for the grid as a whole (σ) is stored in the position of the REF bus. The values of the singular vector <code>v</code> indicate the sensitivity of the buses and are stored in the positions of the PQ buses. The values of <code>v</code> for PV buses are set to zero.  The function uses the method described in &quot;Fast calculation of a voltage stability index&quot; by PA Lof et. al.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The instance containing the grid model data.</li><li><code>J::ACPowerFlowJacobian</code>: The Jacobian matrix cache.</li><li><code>time_step::Integer</code>: The calculated time step.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L699-L713">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure-Tuple{ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure-Tuple{ACPowerFlowData, Int64}"><code>PowerFlows._create_jacobian_matrix_structure</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure(data::ACPowerFlowData, time_step::Int64) -&gt; SparseMatrixCSC{Float64, Int32}</code></pre><p>Create the structure of the Jacobian matrix for an AC power flow problem.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow model.</li><li><code>time_step::Int64</code>: The specific time step for which the Jacobian matrix structure is created.</li></ul><p><strong>Returns</strong></p><ul><li><code>SparseMatrixCSC{Float64, Int32}</code>: A sparse matrix with structural zeros representing the structure of the Jacobian matrix.</li></ul><p><strong>Description</strong></p><p>This function initializes the structure of the Jacobian matrix for an AC power flow problem.  The Jacobian matrix is used in power flow analysis to represent the partial derivatives of bus active and reactive power injections with respect to bus voltage magnitudes and angles.</p><p>Unlike some commonly used approaches where the Jacobian matrix is constructed as four submatrices, each grouping values for the four types of partial derivatives, this function groups the partial derivatives by bus. The structure is organized as groups of 4 values per bus.</p><p>This approach is more memory-efficient. Furthermore, this structure results in a more efficient factorization because the values are more likely to be grouped close to the diagonal. Refer to Electric Energy Systems: Analysis and Operation by Antonio Gomez-Exposito and Fernando L. Alvarado for more details.</p><p>The function initializes three arrays (<code>rows</code>, <code>columns</code>, and <code>values</code>) to store the row indices, column indices, and values of the non-zero elements of the Jacobian matrix, respectively.</p><p>For each bus in the system, the function iterates over its neighboring buses and determines the type of each neighboring bus (<code>REF</code>, <code>PV</code>, or <code>PQ</code>).  Depending on the bus type, the function adds the appropriate entries to the Jacobian matrix structure.</p><ul><li>For <code>REF</code> buses, entries are added for local active and reactive power.</li><li>For <code>PV</code> buses, entries are added for active and reactive power with respect to angle, and for local reactive power.</li><li>For <code>PQ</code> buses, entries are added for active and reactive power with respect to voltage magnitude and angle.</li></ul><p><strong>Example Structure</strong></p><p>For a system with 3 buses where bus 1 is <code>REF</code>, bus 2 is <code>PV</code>, and bus 3 is <code>PQ</code>:</p><p>Let <span>$\Delta P_j$</span>, <span>$\Delta Q_j$</span> be the active, reactive power balance at the <span>$j$</span>th bus. Let <span>$P_j$</span> and <span>$Q_j$</span> be the active and reactive power generated at the <span>$j$</span>th bus (<code>REF</code> and <code>PV</code> only). The state vector is <span>$x = [P_1, Q_1, Q_2, \theta_2, V_3, \theta_3]$</span>, and the residual vector is <span>$F(x) = [\Delta P_1, \Delta Q_1, \Delta P_2, \Delta Q_2, \Delta P_3, \Delta Q_3]$</span>.</p><p>The Jacobian matrix <span>$J = \nabla F(x)$</span> has the structure:</p><p class="math-container">\[J = \begin{bmatrix}
\frac{\partial \vec{F}}{\partial P_1} &amp; 
\frac{\partial \vec{F}}{\partial Q_1} &amp; 
\frac{\partial \vec{F}}{\partial Q_2} &amp; 
\frac{\partial \vec{F}}{\partial \theta_2} &amp; 
\frac{\partial \vec{F}}{\partial V_3} &amp; 
\frac{\partial \vec{F}}{\partial \theta_3}
\end{bmatrix}\]</p><p>In reality, for large networks, this matrix would be sparse, and each 2×2 block would only be nonzero when there&#39;s a line between the respective buses.</p><p>Finally, the function constructs a sparse matrix from the collected indices and values and returns it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L306-L363">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.PV = 2}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PV bus. Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L137-L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64, Int64, Int64, Int64, Int64, Int64, Val{ACBusTypes.REF = 3}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a reference bus (REF). Currently unused: we fill all four values even for PV buses with structiural zeros using the same function as for PQ buses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L110-L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_bus!-Tuple{Vector{Int32}, Vector{Int32}, Vector{Float64}, Vararg{Int64, 6}}"><code>PowerFlows._create_jacobian_matrix_structure_bus!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create the Jacobian matrix structure for a PQ bus. Using this for all buses because      a) for REF buses it doesn&#39;t matter if there are 2 values or 4 values - there are not many of them in the grid     b) for PV buses we fill all four values because we can have a PV -&gt; PQ transition and then we need to fill all four values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L168-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{ACPowerFlowData, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><a class="docstring-binding" href="#PowerFlows._create_jacobian_matrix_structure_lcc-Tuple{ACPowerFlowData, Vector{Int32}, Vector{Int32}, Vector{Float64}, Int64}"><code>PowerFlows._create_jacobian_matrix_structure_lcc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_jacobian_matrix_structure_lcc(
    data::ACPowerFlowData,
    rows::Vector{Int32},
    columns::Vector{Int32},
    values::Vector{Float64},
    num_buses::Int
)</code></pre><p>Create the Jacobian matrix structure for LCC HVDC systems.</p><p><strong>Description</strong></p><p>The function iterates over each LCC system and adds the non-zero entries to the Jacobian matrix structure. The state vector for every LCC contains 4 variables: tap position and thyristor angle for both the rectifier and inverter sides. The indices of non-zero entries correspond to the positions of these variables in the extended state vector.</p><p>For an LCC system connecting bus <span>$i$</span> (rectifier side) and bus <span>$j$</span> (inverter side), the state variables are:</p><ul><li><span>$t_i$</span>: tap position at rectifier</li><li><span>$t_j$</span>: tap position at inverter  </li><li><span>$\alpha_i$</span>: thyristor angle at rectifier</li><li><span>$\alpha_j$</span>: thyristor angle at inverter</li></ul><p>The residuals include:</p><ul><li><span>$F_{t_i}$</span>: Active power balance at rectifier (controls <span>$P_i$</span> to match setpoint)</li><li><span>$F_{t_j}$</span>: Total active power balance across LCC system</li><li><span>$F_{\alpha_i}$</span>: Rectifier thyristor angle constraint (maintains <span>$\alpha_i$</span> at minimum)</li><li><span>$F_{\alpha_j}$</span>: Inverter thyristor angle constraint (maintains <span>$\alpha_j$</span> at minimum)</li></ul><p><strong>Example Structure</strong></p><p>For a system with 2 buses connected by one LCC where bus 1 is the rectifier side and bus 2 is the inverter side, the Jacobian matrix would have non-zero entries at positions like:</p><p class="math-container">\[\begin{array}{c|cccccccc}
 &amp; V_1 &amp; \delta_1 &amp; V_2 &amp; \delta_2 &amp; t_1 &amp; t_2 &amp; \alpha_1 &amp; \alpha_2 \\
\hline
P_1 &amp; \frac{\partial P_1}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial P_1}{\partial t_1} &amp; &amp; \frac{\partial P_1}{\partial \alpha_1} &amp; \\
Q_1 &amp; \frac{\partial Q_1}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial Q_1}{\partial t_1} &amp; &amp; \frac{\partial Q_1}{\partial \alpha_1} &amp; \\
P_2 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
Q_2 &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \\
F_{t_1} &amp; \frac{\partial F_{t_1}}{\partial V_1} &amp; &amp; &amp; &amp; \frac{\partial F_{t_1}}{\partial t_1} &amp; &amp; \frac{\partial F_{t_1}}{\partial \alpha_1} &amp; \\
F_{t_2} &amp; \frac{\partial F_{t_2}}{\partial V_1} &amp; &amp; \frac{\partial F_{t_2}}{\partial V_2} &amp; &amp; \frac{\partial F_{t_2}}{\partial t_1} &amp; \frac{\partial F_{t_2}}{\partial t_2} &amp; \frac{\partial F_{t_2}}{\partial \alpha_1} &amp; \frac{\partial F_{t_2}}{\partial \alpha_2} \\
F_{\alpha_1} &amp; &amp; &amp; &amp; &amp; &amp; &amp; \frac{\partial F_{\alpha_1}}{\partial \alpha_1} &amp; \\
F_{\alpha_2} &amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; \frac{\partial F_{\alpha_2}}{\partial \alpha_2}
\end{array}\]</p><p>This function sets up the indices of these non-zero entries in the sparse Jacobian matrix structure.</p><p><strong>Arguments</strong></p><ul><li><code>data::ACPowerFlowData</code>: The power flow data containing LCC system information.</li><li><code>rows::Vector{Int32}</code>: Vector to store row indices of non-zero Jacobian entries.</li><li><code>columns::Vector{Int32}</code>: Vector to store column indices of non-zero Jacobian entries.</li><li><code>values::Vector{Float64}</code>: Vector to store initial values of non-zero Jacobian entries.</li><li><code>num_buses::Int</code>: Total number of buses in the system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L203-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><a class="docstring-binding" href="#PowerFlows._singular_value_decomposition-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Integer}"><code>PowerFlows._singular_value_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_singular_value_decomposition(J::SparseMatrixCSC{Float64, Int32}, npvpq::Integer; tol::Float64 = 1e-9, max_iter::Integer = 100,)</code></pre><p>Estimate the smallest singular value <code>σ</code> and corresponding left and right singular vectors <code>u</code> and <code>v</code> of a sparse matrix <code>G_s</code> (a sub-matrix of <code>J</code>). This function uses an iterative method involving LU factorization of the Jacobian matrix to estimate the smallest singular value of <code>G_s</code>.  The algorithm alternates between updating <code>u</code> and <code>v</code>, normalizing, and checking for convergence based on the change in the estimated singular value <code>σ</code>. The function uses the method described in <code>Algorithm 3</code> of &quot;Fast calculation of a voltage stability index&quot; by PA Lof et. al.</p><p><strong>Arguments</strong></p><ul><li><code>J::SparseMatrixCSC{Float64, Int32}</code>: The sparse block-form Jacobian matrix.</li><li><code>npvpq::Integer</code>: Number of PV and PQ buses in J.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tol::Float64=1e-9</code>: Convergence tolerance for the iterative algorithm.</li><li><code>max_iter::Integer=100</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>σ::Float64</code>: The estimated smallest singular value.</li><li><code>left::Vector{Float64}</code>: The estimated left singular vector (referred to as <code>u</code> in the cited paper).</li><li><code>right::Vector{Float64}</code>: The estimated right singular vector (referred to as <code>v</code> in the cited paper).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L758-L778">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, ACPowerFlowData, Int64, StaticArraysCore.MVector{4, Float64}}"><a class="docstring-binding" href="#PowerFlows._update_jacobian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, ACPowerFlowData, Int64, StaticArraysCore.MVector{4, Float64}}"><code>PowerFlows._update_jacobian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Used to update Jv based on the bus voltages, angles, etc. in data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/ac_power_flow_jacobian.jl#L569">source</a></section></details></article><h2 id="DC-Power-Flow"><a class="docs-heading-anchor" href="#DC-Power-Flow">DC Power Flow</a><a id="DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#DC-Power-Flow" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.adjust_power_injection_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><a class="docstring-binding" href="#PowerFlows.adjust_power_injection_for_lccs!-Tuple{Matrix{Float64}, PowerFlows.LCCParameters}"><code>PowerFlows.adjust_power_injection_for_lccs!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Adjust the power injection vector to account for the power flows through LCCs.</p><p>Relies on the fact that we calculate those flows during initialization and save them to the <code>active_powerflow_from_to</code> and <code>active_powerflow_to_from</code> fields of the <code>LCCParameters</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/solve_dc_powerflow.jl#L1-L7">source</a></section></details></article><h2 id="Robust-Homotopy-Method"><a class="docs-heading-anchor" href="#Robust-Homotopy-Method">Robust Homotopy Method</a><a id="Robust-Homotopy-Method-1"></a><a class="docs-heading-anchor-permalink" href="#Robust-Homotopy-Method" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><a class="docstring-binding" href="#PowerFlows.HomotopyHessian-Tuple{Vector{Float64}, Float64, Int64}"><code>PowerFlows.HomotopyHessian</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute value of gradient and Hessian at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/RobustHomotopy/homotopy_hessian.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#PowerFlows.A_plus_eq_BT_B!-Tuple{SparseArrays.SparseMatrixCSC, SparseArrays.SparseMatrixCSC}"><code>PowerFlows.A_plus_eq_BT_B!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does <code>A += B&#39; * B</code>, in a way that preserves the sparse structure of <code>A</code>, if possible. A workaround for the fact that Julia seems to run <code>dropzeros!(A)</code> automatically if I just  do <code>A .+= B&#39; * B</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/RobustHomotopy/homotopy_hessian.jl#L11-L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._update_hessian_matrix_values!-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, ACPowerFlowData, Int64}"><code>PowerFlows._update_hessian_matrix_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_update_hessian_matrix_values!(
    Hv::SparseMatrixCSC{Float64, Int32},
    F_value::Vector{Float64},
    data::ACPowerFlowData,
    time_step::Int64
)</code></pre><p>Update the Hessian matrix values for the robust homotopy power flow solver.</p><p><strong>Description</strong></p><p>This function sets <code>Hv</code> equal to:</p><p class="math-container">\[\sum_{k=1}^{2n} F_k(x) H_{F_k}(x)\]</p><p>where <span>$F_k$</span> denotes the <span>$k$</span>th power balance equation and <span>$H_{F_k}$</span> denotes its Hessian matrix.</p><p>This computes only the terms in the Hessian that come from the second derivatives of the power balance equations.  The full Hessian of the objective function also includes a <span>$J^T J$</span> term, which is computed separately.</p><p><strong>Sparse Structure</strong></p><p>The Hessian is organized into 2×2 blocks, each corresponding to a pair of buses. For a pair of buses <span>$i$</span> and <span>$k$</span>  connected by a branch, the sparse structure of their block depends on the bus types:</p><p class="math-container">\[\begin{array}{c|cc|cc|cc}
 &amp; \text{REF} &amp; &amp; \text{PV} &amp; &amp; \text{PQ} &amp; \\
 &amp; P_i &amp; Q_i &amp; Q_i &amp; V_i &amp; V_i &amp; \theta_i \\
\hline
\text{REF: } P_k &amp; &amp; &amp; &amp; &amp; &amp; \\
Q_k &amp; &amp; &amp; &amp; &amp; &amp; \\
\hline
\text{PV: } Q_k &amp; &amp; &amp; &amp; &amp; &amp; \\
V_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet \\
\hline
\text{PQ: } V_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet \\
\theta_k &amp; &amp; &amp; &amp; \bullet &amp; \bullet &amp; \bullet
\end{array}\]</p><p>where <span>$\bullet$</span> represents a potentially non-zero entry.</p><p>Diagonal blocks (where <span>$i = k$</span>) follow the same pattern as if each bus is its own neighbor. Off-diagonal blocks for pairs of buses not connected by a branch are structurally zero.</p><p><strong>Arguments</strong></p><ul><li><code>Hv::SparseMatrixCSC{Float64, Int32}</code>: The Hessian matrix to be updated (modified in-place).</li><li><code>F_value::Vector{Float64}</code>: Current values of the power balance residuals.</li><li><code>data::ACPowerFlowData</code>: The power flow data containing bus and network information.</li><li><code>time_step::Int64</code>: The time step for which to compute the Hessian.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/RobustHomotopy/homotopy_hessian.jl#L129-L183">source</a></section></details></article><h2 id="Post-Processing"><a class="docs-heading-anchor" href="#Post-Processing">Post-Processing</a><a id="Post-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Processing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows._calculate_fixed_admittance_powers-Tuple{System, PowerFlowData, Int64}"><code>PowerFlows._calculate_fixed_admittance_powers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a dictionary of bus index to power contribution at that bus from FixedAdmittance components, as a tuple of (active power, reactive power).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L7-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><a class="docstring-binding" href="#PowerFlows._set_series_voltages_and_flows!-Tuple{System, PowerNetworkMatrices.BranchesSeries, Tuple{Int64, Int64}, Tuple{ComplexF64, ComplexF64}, Dict{Int64, String}}"><code>PowerFlows._set_series_voltages_and_flows!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_set_series_voltages_and_flows!(
    sys::PSY.System,
    segment_sequence::PNM.BranchesSeries,
    equivalent_arc::Tuple{Int, Int},
    V_endpoints::Tuple{ComplexF64, ComplexF64},
    temp_bus_map::Dict{Int, String},
)</code></pre><p>Calculate series voltages at buses removed in degree 2 reduction.</p><p><strong>Method</strong></p><p>Number the nodes in the series segment 0, 1, ..., n. Number the segments by their concluding node: 1, 2, ... n. The currents in the segments are given by:</p><p class="math-container">\[\begin{bmatrix} y^i_{ff} &amp; y^i_{ft} \\ y^i_{tf} &amp; y^i_{tt} \end{bmatrix} 
\begin{bmatrix} V_{i-1} \\ V_i \end{bmatrix} = 
\begin{bmatrix} I_{i-1, i} \\ I_{i, i-1} \end{bmatrix}\]</p><p>where upper indices denote the segment number.</p><p>There are no loads or generators at the internal nodes, so <span>$I_{i, i+1} + I_{i, i-1} = 0$</span>. Substitute the above expressions for the currents and group by <span>$V_i$</span>:</p><p class="math-container">\[y^i_{tf} V_{i-1} + (y_{tt}^i + y_{ff}^{i+1}) V_i + y_{ft}^{i+1} V_{i+1} = 0\]</p><p>For <span>$i = 1$</span> and <span>$i = n-1$</span>, move the terms involving <span>$V_0$</span> and <span>$V_n$</span> (known) to  the other side. This gives a tridiagonal system for <span>$x = [V_1, \ldots, V_{n-1}]$</span>:</p><p class="math-container">\[A x = [-y^1_{tf} V_0, 0, \ldots, 0, -y^{n}_{ft} V_n]\]</p><p>where <span>$A$</span> has diagonal entries <span>$y_{tt}^i + y_{ff}^{i+1}$</span>, subdiagonal entries <span>$y_{tf}^{i+1}$</span>, and superdiagonal entries <span>$y_{ft}^i$</span>.</p><p>In the implementation, <span>$y_{11}$</span> is used instead of <span>$y_{ff}$</span>, <span>$y_{12}$</span> instead of  <span>$y_{ft}$</span>, etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L345-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_arc_names-Tuple{PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.get_arc_names-Tuple{PowerFlowData}"><code>PowerFlows.get_arc_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the names of the arcs in the power flow data: those that correspond to branches in the system will get the branch names, others will get a placeholder name of the form from-to.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L806-L808">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, ACPowerFlowData, Int64}"><a class="docstring-binding" href="#PowerFlows.set_branch_flows_for_dict!-Tuple{Dict{Tuple{Int64, Int64}, ACTransmission}, ACPowerFlowData, Int64}"><code>PowerFlows.set_branch_flows_for_dict!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Set the power flow in the arcs that remain after network reduction. Called on the  <code>direct_branch_map</code> and <code>transformer3W_map</code> dictionaries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L465-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.update_system!-Tuple{System, PowerFlowData}"><a class="docstring-binding" href="#PowerFlows.update_system!-Tuple{System, PowerFlowData}"><code>PowerFlows.update_system!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs"> update_system!(sys::PSY.System, data::PowerFlowData; time_step = 1)</code></pre><p>Modify the values in the given <a href="https://nrel-sienna.github.io/PowerSystems.jl/stable/api/public/#PowerSystems.System"><code>System</code></a> to correspond to the  given <code>PowerFlowData</code> such that if a new <code>PowerFlowData</code> is constructed from the resulting  system it is the same as <code>data</code>. See also <a href="#PowerFlows.write_powerflow_solution!"><code>write_powerflow_solution!</code></a>. NOTE this  assumes that <code>data</code> was initialized from <code>sys</code> and then solved with no further  modifications.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L992-L1000">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_powerflow_solution!"><a class="docstring-binding" href="#PowerFlows.write_powerflow_solution!"><code>PowerFlows.write_powerflow_solution!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Updates system voltages and powers with power flow results</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/post_processing.jl#L487-L489">source</a></section></details></article><h2 id="PSSE-Export"><a class="docs-heading-anchor" href="#PSSE-Export">PSSE Export</a><a id="PSSE-Export-1"></a><a class="docs-heading-anchor-permalink" href="#PSSE-Export" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows._first_choice_gen_id-Tuple{String}"><a class="docstring-binding" href="#PowerFlows._first_choice_gen_id-Tuple{String}"><code>PowerFlows._first_choice_gen_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Try to make an informative one or two character name for the load/generator/etc.</p><ul><li>generator-1234-AB -&gt; AB</li><li>123_CT_7 -&gt; 7</li><li>load1234 -&gt; 34</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L679-L685">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><a class="docstring-binding" href="#PowerFlows._fix_3w_transformer_rating-Tuple{Any}"><code>PowerFlows._fix_3w_transformer_rating</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Setting a value of zero 0.0 when having a value greater than or equal to INFINITE_BOUND reverses the operation done in the PSY parsing side, according to PSSE Manual.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L438-L441">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><a class="docstring-binding" href="#PowerFlows._make_gens_from_hvdc-NTuple{8, Any}"><code>PowerFlows._make_gens_from_hvdc</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Create a synthetic generator (<code>PSY.ThermalStandard</code>) representing one end of a TwoTerminalGenericHVDCLine for export purposes. The generator is initialized with parameters reflecting the HVDC line&#39;s state. </p><p><strong>Notes</strong></p><pre><code class="language-julia hljs">- The generator&#39;s name is constructed as &quot;&lt;hvdc_line_name&gt;_&lt;suffix&gt;&quot;.
- The `ext` field includes `&quot;HVDC_END&quot;` to indicate the end (&quot;FR&quot;/&quot;TO&quot;).</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L896-L902">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><a class="docstring-binding" href="#PowerFlows._map_psse_container_names-Tuple{Vector{String}}"><code>PowerFlows._map_psse_container_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate that the Sienna area/zone names parse as PSS/E-compatible area/zone numbers, output a mapping</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_names-Tuple{Vector{String}, Vector{Int64}, AbstractDict{Int64, Int64}}"><code>PowerFlows._psse_bus_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus names, create a dictionary from Sienna bus name to PSS/E-compatible bus name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L545-L550">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#PowerFlows._psse_bus_numbers-Tuple{Vector{Int64}}"><code>PowerFlows._psse_bus_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna bus numbers, create a dictionary from Sienna bus number to PSS/E-compatible bus number. Assumes that the Sienna bus numbers are positive and unique. Guarantees determinism: if the input contains the same bus numbers in the same order, the output will. Guarantees minimal changes: that if an existing bus number is compliant, it will not be changed.</p><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Bus Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L496-L504">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><a class="docstring-binding" href="#PowerFlows._psse_transformer_names-Tuple{Vector{String}, Vector, AbstractDict{Int64, Int64}, Any}"><code>PowerFlows._psse_transformer_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of Sienna transformer names, create a dictionary from Sienna transformer name to PSS/E-compatible transformer name. Guarantees determinism and minimal changes.</p><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1451-L1456">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><a class="docstring-binding" href="#PowerFlows._update_gens_from_hvdc!-Tuple{Vector{ThermalStandard}, Dict{ThermalStandard, Tuple{TwoTerminalGenericHVDCLine, String}}, Any}"><code>PowerFlows._update_gens_from_hvdc!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Update the parameters of synthetic generators created from HVDC lines, so they reflect the current setpoints and limits of the HVDC devices in the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L935-L938">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><a class="docstring-binding" href="#PowerFlows.better_float_to_buf-Tuple{Union{Base.GenericIOBuffer{&lt;:Array{UInt8}}, Base.GenericIOBuffer{&lt;:GenericMemory{:not_atomic, UInt8}}}, Float64}"><code>PowerFlows.better_float_to_buf</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Temporary, very specialized proof of concept patch for https://github.com/JuliaLang/julia/issues/55835</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.check_supported_version-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.check_supported_version-Tuple{PSSEExporter}"><code>PowerFlows.check_supported_version</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Throw a <code>NotImplementedError</code> if the <code>psse_version</code> is not supported</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L397">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><a class="docstring-binding" href="#PowerFlows.convert_empty-Union{Tuple{T}, Tuple{Type{T}, Any}} where T"><code>PowerFlows.convert_empty</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If <code>val</code> is empty, returns <code>T()</code>; if not, asserts that <code>val isa T</code> and returns <code>val</code>. Has nice type checker semantics.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">convert_empty(Vector{String}, [])  # -&gt; String[]
convert_empty(Vector{String}, [&quot;a&quot;])  # -&gt; [&quot;a&quot;]
convert_empty(Vector{String}, [2])  # -&gt; TypeError: in typeassert, expected Vector{String}, got a value of type Vector{Int64}
Base.return_types(Base.Fix1(convert_empty, Vector{String}))  # -&gt; [Vector{String}]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L364-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><a class="docstring-binding" href="#PowerFlows.create_component_ids-Union{Tuple{T}, Tuple{Vector{&lt;:String}, Vector{T}}} where T"><code>PowerFlows.create_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Given a vector of component names and a corresponding vector of container IDs (e.g., bus numbers), create unique-per-container PSS/E-compatible IDs, output a dictionary from (container ID, component name) to PSS/E-compatible component ID. The &quot;singles<em>to</em>1&quot; flag detects components that are the only one on their bus and gives them the name &quot;1&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L691-L696">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><a class="docstring-binding" href="#PowerFlows.flatten_power_flow_evaluation_model-Tuple{PowerFlows.PowerFlowEvaluationModel}"><code>PowerFlows.flatten_power_flow_evaluation_model</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Expand a single <code>PowerFlowEvaluationModel</code> into its possibly multiple parts for separate evaluation. Namely, if <code>pfem</code> contains a non-nothing <code>exporter</code>, return <code>[pfem, exporter]</code>, else return <code>[pfem]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L120-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.get_branches_with_numbers-Tuple{PSSEExporter}"><code>PowerFlows.get_branches_with_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Collects all AC branches (Line, MonitoredLine, DiscreteControlledACBranch) from the system, sorts them by their bus numbers, and returns a vector of tuples (branch, bus_numbers).</p><p><strong>Arguments</strong></p><ul><li><code>exporter::PSSEExporter</code>: The exporter containing the system.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Tuple{&lt;:PSY.Branch, Tuple}}</code>: Each tuple contains a branch and its associated bus numbers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1215-L1224">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.reset_caches-Tuple{PSSEExporter}"><a class="docstring-binding" href="#PowerFlows.reset_caches-Tuple{PSSEExporter}"><code>PowerFlows.reset_caches</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Force all cached information (serialized metadata, component lists, etc.) to be regenerated</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><a class="docstring-binding" href="#PowerFlows.serialize_component_ids-Tuple{Dict{Tuple{Int64, String}, String}}"><code>PowerFlows.serialize_component_ids</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Take the output of <code>create_component_ids</code> and make it more suitable for JSON serialization</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L726">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Bus Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Bus Data. Sienna voltage limits treated as PSS/E normal voltage limits; PSSE emergency voltage limits left as default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L583-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Case Identification Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Case Identification Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;FACTS Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 FACTS Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2496-L2498">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Fixed Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Fixed Bus Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L837-L839">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Generator Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Generator Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L977-L979">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Load Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Load Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L768-L770">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Non-Transformer Branch Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Non-Transformer Branch Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1239-L1241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Q Record&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3 POM 5.2.1 Q Record</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2715-L2717">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switched Shunt Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Switched Shunt Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2576-L2578">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Switching Device Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 35.4 POM 5.2.1 System Switching Device Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1357-L1359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1507-L1509">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Transformer Impedance Correction Tables&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Transformer Impedance Correction Tables</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2350-L2352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Two-Terminal DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Two-Terminal DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L1997-L1999">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Voltage Source Converter (VSC) DC Transmission Line Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Voltage Source Converter (VSC) DC Transmission Line Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2152-L2154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><a class="docstring-binding" href="#PowerFlows.write_to_buffers!-Tuple{PSSEExporter, Val{Symbol(&quot;Zone Data&quot;)}}"><code>PowerFlows.write_to_buffers!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>WRITTEN TO SPEC: PSS/E 33.3/35.4 POM 5.2.1 Zone Data</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psse_export.jl#L2463-L2465">source</a></section></details></article><h2 id="Power-Systems-Utilities"><a class="docs-heading-anchor" href="#Power-Systems-Utilities">Power Systems Utilities</a><a id="Power-Systems-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Systems-Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.can_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.can_be_PV-Tuple{System}"><code>PowerFlows.can_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that can be PV: i.e. have an available generator, or certain voltage regulation devices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powersystems_utils.jl#L60-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.must_be_PV-Tuple{System}"><a class="docstring-binding" href="#PowerFlows.must_be_PV-Tuple{System}"><code>PowerFlows.must_be_PV</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return set of all bus numbers that must be PV: i.e. have an available generator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powersystems_utils.jl#L44">source</a></section></details></article><h2 id="Common-Utilities-and-Definitions"><a class="docs-heading-anchor" href="#Common-Utilities-and-Definitions">Common Utilities and Definitions</a><a id="Common-Utilities-and-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-Utilities-and-Definitions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><a class="docstring-binding" href="#PowerFlows.get_active_and_reactive_power_from_generator-Tuple{SynchronousCondenser}"><code>PowerFlows.get_active_and_reactive_power_from_generator</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active and reactive power generation from a generator component. It&#39;s pg=0 as default for synchronous condensers since there&#39;s no field in the component for active power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L47-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_active_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_active_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the active power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_active_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L23-L26">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><a class="docstring-binding" href="#PowerFlows.get_reactive_power_limits_for_power_flow-Tuple{Device}"><code>PowerFlows.get_reactive_power_limits_for_power_flow</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Return the reactive power limits that should be used in power flow calculations and PSS/E exports. Redirects to <code>PSY.get_reactive_power_limits</code> in all but special cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L3-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Matrix{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Similar to above: A*X where X is a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L354">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.my_mul_mt-Tuple{PowerNetworkMatrices.VirtualPTDF, Vector{Float64}}"><code>PowerFlows.my_mul_mt</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Matrix multiplication A*x. Written this way because a VirtualPTDF  matrix does not store all of its entries: instead, it calculates them (or retrieves them from cache), one element or one row at a time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L339-L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.siground-Tuple{Float64}"><a class="docstring-binding" href="#PowerFlows.siground-Tuple{Float64}"><code>PowerFlows.siground</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>For pretty printing floats in debugging messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wdot-NTuple{4, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wdot-NTuple{4, Vector{Float64}}"><code>PowerFlows.wdot</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted dot product of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L548">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows.wnorm-Tuple{Vector{Float64}, Vector{Float64}}"><code>PowerFlows.wnorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Weighted norm of two vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/common.jl#L552">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><a class="docstring-binding" href="#PowerFlows.contributes_active_power-Tuple{T} where T&lt;:Device"><code>PowerFlows.contributes_active_power</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check if a device has attribute &#39;active_power&#39; for active power consumption or generation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/psi_utils.jl#L1-L3">source</a></section></details></article><h2 id="Power-Flow-Types"><a class="docs-heading-anchor" href="#Power-Flow-Types">Power Flow Types</a><a id="Power-Flow-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.AbstractDCPowerFlow"><a class="docstring-binding" href="#PowerFlows.AbstractDCPowerFlow"><code>PowerFlows.AbstractDCPowerFlow</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An abstract supertype for all DC power flow evaluation models. Subtypes: <a href="../public/#PowerFlows.DCPowerFlow"><code>DCPowerFlow</code></a>, <a href="../public/#PowerFlows.PTDFDCPowerFlow"><code>PTDFDCPowerFlow</code></a>, and <a href="../public/#PowerFlows.vPTDFDCPowerFlow"><code>vPTDFDCPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L156-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows.PowerFlowEvaluationModel"><a class="docstring-binding" href="#PowerFlows.PowerFlowEvaluationModel"><code>PowerFlows.PowerFlowEvaluationModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>An abstract supertype for all types of power flows. Subtypes: <a href="../public/#PowerFlows.ACPowerFlow"><code>ACPowerFlow</code></a> and <a href="#PowerFlows.AbstractDCPowerFlow"><code>AbstractDCPowerFlow</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_types.jl#L1-L3">source</a></section></details></article><h2 id="Power-Flow-Methods"><a class="docs-heading-anchor" href="#Power-Flow-Methods">Power Flow Methods</a><a id="Power-Flow-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="PowerFlows.StateVectorCache"><a class="docstring-binding" href="#PowerFlows.StateVectorCache"><code>PowerFlows.StateVectorCache</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>Cache for non-linear methods.</p><p><strong>Fields</strong></p><ul><li><code>x::Vector{Float64}</code>: the current state vector.</li><li><code>r::Vector{Float64}</code>: the current residual.</li><li><code>Δx_nr::Vector{Float64}</code>: the step under the Newton-Raphson method.</li></ul><p>The remainder of the fields are only used in the <code>TrustRegionACPowerFlow</code>:</p><ul><li><code>r_predict::Vector{Float64}</code>: the predicted residual at <code>x+Δx_proposed</code>,   under a linear approximation: i.e <code>J_x⋅(x+Δx_proposed)</code>.</li><li><code>Δx_proposed::Vector{Float64}</code>: the suggested step <code>Δx</code>, selected among <code>Δx_nr</code>,    <code>Δx_cauchy</code>, and the dogleg interpolation between the two. The first is chosen when   <code>x+Δx_nr</code> is inside the trust region, the second when both <code>x+Δx_cauchy</code>   and <code>x+Δx_nr</code> are outside the trust region, and the third when <code>x+Δx_cauchy</code>   is inside and <code>x+Δx_nr</code> outside. The dogleg step selects the point where the line   from <code>x+Δx_cauchy</code> to <code>x+Δx_nr</code> crosses the boundary of the trust region.</li><li><code>Δx_cauchy::Vector{Float64}</code>: the step to the Cauchy point if the Cauchy point   lies within the trust region, otherwise a step in that direction.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L1-L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._do_refinement!-Tuple{PowerFlows.StateVectorCache, SparseArrays.SparseMatrixCSC{Float64, Int32}, PowerFlows.KLULinSolveCache{Int32}, Float64, Float64}"><code>PowerFlows._do_refinement!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Check error and do refinement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><a class="docstring-binding" href="#PowerFlows._dogleg!-Tuple{Vector{Float64}, Vector{Float64}, Vector{Float64}, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}, Float64}"><code>PowerFlows._dogleg!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets <code>Δx_proposed</code> equal to the <code>Δx</code> by which we should update <code>x</code>. Decides between the Cauchy step <code>Δx_cauchy</code>, Newton-Raphson step <code>Δx_nr</code>, and the dogleg interpolation between the two, based on which fall within the trust region.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L113-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{NewtonRaphsonACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>NewtonRaphsonACPowerFlow</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>norm(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>refinement_threshold::Float64</code>: If the solution to <code>J_x Δx = r</code> satisfies   <code>norm(J_x Δx - r, 1)/norm(r, 1) &gt; refinement_threshold</code>, do iterative refinement to   improve the accuracy. Default: 0.05.</li><li><code>refinement_eps::Float64</code>: run iterative refinement on <code>J_x Δx = r</code> until   <code>norm(Δx_{i}-Δx_{i+1}, 1)/norm(r,1) &lt; refinement_eps</code>. Default:    1.0e-6 </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L284-L295">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><a class="docstring-binding" href="#PowerFlows._run_powerflow_method-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Type{TrustRegionACPowerFlow}}"><code>PowerFlows._run_powerflow_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Runs the full <code>TrustRegionNRMethod</code>.</p><p><strong>Keyword arguments:</strong></p><ul><li><code>maxIterations::Int</code>: maximum iterations. Default: 50.</li><li><code>tol::Float64</code>: tolerance. The iterative search ends when <code>maximum(abs.(residual)) &lt; tol</code>.   Default: 1.0e-9.</li><li><code>factor::Float64</code>: the trust region starts out with radius <code>factor*norm(x_0, 1)</code>,   where <code>x_0</code> is our initial guess, taken from <code>data</code>. Default: 1.0.</li><li><code>eta::Float64</code>: improvement threshold. If the observed improvement in our residual   exceeds <code>eta</code> times the predicted improvement, we accept the new <code>x_i</code>.   Default: 0.0001.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L339-L349">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><a class="docstring-binding" href="#PowerFlows._set_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.ACPowerFlowJacobian, PowerFlows.KLULinSolveCache{Int32}, ACPowerFlowSolverType, Float64, Float64}"><code>PowerFlows._set_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Sets the Newton-Raphson step. Usually, this is just <code>J.Jv \ stateVector.r</code>, but <code>J.Jv</code> might be singular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L67-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._simple_step"><a class="docstring-binding" href="#PowerFlows._simple_step"><code>PowerFlows._simple_step</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Does a single iteration of <code>NewtonRaphsonACPowerFlow</code>. Updates the <code>r</code> and <code>x</code> fields of the <code>stateVector</code>, and computes the Jacobian at the new <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L255-L257">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><a class="docstring-binding" href="#PowerFlows._singular_J_fallback-Tuple{SparseArrays.SparseMatrixCSC{Float64, Int32}, Vector{Float64}}"><code>PowerFlows._singular_J_fallback</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns a stand-in matrix for singular J&#39;s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><a class="docstring-binding" href="#PowerFlows._solve_Δx_nr!-Tuple{PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}}"><code>PowerFlows._solve_Δx_nr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Solve for the Newton-Raphson step, given the factorization object for <code>J.Jv</code>  (if non-singular) or its stand-in (if singular).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L38-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><a class="docstring-binding" href="#PowerFlows._trust_region_step-Tuple{Int64, PowerFlows.StateVectorCache, PowerFlows.KLULinSolveCache{Int32}, PowerFlows.ACPowerFlowResidual, PowerFlows.ACPowerFlowJacobian, Float64, Float64, Bool}"><code>PowerFlows._trust_region_step</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Does a single iteration of the <code>TrustRegionNRMethod</code>: updates the <code>x</code> and <code>r</code> fields of the <code>stateVector</code> and computes the value of the Jacobian at the new <code>x</code>, if needed. Unlike  <code>_simple_step</code>, this has a return value, the updated value of <code>delta</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/NREL-Sienna/PowerFlows.jl/blob/bb0a0e4529b5533c55c8039bd11a350adcfc5e35/src/powerflow_method.jl#L166-L170">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../public/">« Public API Reference</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 21:35">Wednesday 3 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
